{"mappings":"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","sources":["<anon>","dist/client/cjm/client.js","src/client/cjm/client.ts","dist/client/cjm/util.js","src/client/cjm/util.ts","dist/client/cjm/xml.js","src/client/cjm/xml.ts","dist/client/cjm/molecule.js","src/client/cjm/molecule.ts","dist/client/cjm/classes.js","src/client/cjm/classes.ts","dist/client/cjm/html.js","src/client/cjm/html.ts","dist/client/cjm/functions.js","src/client/cjm/functions.ts","dist/client/cjm/reaction.js","src/client/cjm/reaction.ts","dist/client/cjm/canvas.js","src/client/cjm/canvas.ts","dist/client/cjm/conditions.js","src/client/cjm/conditions.ts","dist/client/cjm/modelParameters.js","src/client/cjm/modelParameters.ts","dist/client/cjm/control.js","src/client/cjm/control.ts","node_modules/@parcel/runtime-js/lib/runtime-2c2aba71dc4bb2d4.js"],"sourcesContent":["/**\n * Thow an error if the key is not in the map otherwise return the value mapped to the key.\n * @param map The map to search in.\n * @param key The key to search for.\n * @returns The value mapped to the key.\n * @throws An error if the key is not in the map.\n */ function $5a4e4b2707638a1c$export$3988ae62b71be9a3(map, key) {\n    if (!map.has(key)) throw new Error(`Key ${key} not found in map`);\n    return map.get(key);\n}\nfunction $5a4e4b2707638a1c$export$bd2782c820638828(min, range, newMin, newRange, value) {\n    // The + 0.0 is to force the division to be a floating point division.\n    //return (((value - min) / (range + 0.0)) * (newRange)) + newMin;\n    return (value - min) * newRange / (range + 0.0) + newMin;\n}\n\n\n/**\n * Get the attribute of an xml element.\n * @param xml The xml element to search in.\n * @param name The name of the attribute to search for.\n * @returns The value of the attribute.\n * @throws An error if the attribute is not found.\n */ function $2772ddfff48d4e5b$export$735ee1799fd02602(xml, name) {\n    let v = xml.getAttribute(name);\n    if (!v) throw new Error(name + \" attribute not found\");\n    return v;\n}\nfunction $2772ddfff48d4e5b$export$91e73a91db22e6a2(element, tagName) {\n    let el = element.getElementsByTagName(tagName)[0];\n    if (el == null) throw new Error(tagName + \" element not found\");\n    return el;\n}\nfunction $2772ddfff48d4e5b$export$4e07613bf412feb7(element) {\n    let cn = element.childNodes;\n    if (cn == null) throw new Error(\"Element has no childNodes\");\n    return cn[0];\n}\nfunction $2772ddfff48d4e5b$export$13cb40e9b656ab9e(node) {\n    let nodeValue = node.nodeValue;\n    if (nodeValue == null) throw new Error(\"nodeValue is null\");\n    return nodeValue;\n}\nfunction $2772ddfff48d4e5b$export$2cd488e9ab180ce2(tagName, attributes, attributeName, attributeValue, padding) {\n    let s = \"\";\n    if (padding != undefined) s += \"\\n\" + padding;\n    s += \"<\" + tagName;\n    if (attributes) for (let [k, v] of attributes)s += \" \" + k + '=\"' + v.toString() + '\"';\n    if (attributeName && attributeValue) s += \" \" + attributeName + '=\"' + attributeValue.toString() + '\"';\n    return s + \">\";\n}\nfunction $2772ddfff48d4e5b$export$34b7e1ae786b72b0(tagName, padding, padValue) {\n    let s = \"\";\n    if (padValue) {\n        if (padding != undefined) s += \"\\n\" + padding;\n    }\n    return s + \"</\" + tagName + \">\";\n}\nfunction $2772ddfff48d4e5b$export$dad497fe1f6e27c0(content, tagName, attributes, attributeName, attributeValue, padding, padValue) {\n    let startTag = $2772ddfff48d4e5b$export$2cd488e9ab180ce2(tagName, attributes, attributeName, attributeValue, padding);\n    let endTag = $2772ddfff48d4e5b$export$34b7e1ae786b72b0(tagName, padding, padValue);\n    return startTag + content + endTag;\n}\nfunction $2772ddfff48d4e5b$export$fe94072fee8a6976(element) {\n    let attributeNames = element.getAttributeNames();\n    let attributes = new Map();\n    attributeNames.forEach(function(attributeName) {\n        let attributeValue = element.getAttribute(attributeName);\n        if (attributeValue != null) attributes.set(attributeName, attributeValue);\n    });\n    return attributes;\n}\nfunction $2772ddfff48d4e5b$export$b7531b8ff18dc588(xml, tagName) {\n    let e = xml.getElementsByTagName(tagName);\n    if (e.length != 1) throw new Error(\"Expecting 1 \" + tagName + \" but finding \" + e.length);\n    return e[0];\n}\nfunction $2772ddfff48d4e5b$export$438fa7935f716bdf(text) {\n    return text.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\\n/g, \"<br>\").replace(/\\t/g, \"&nbsp;&nbsp;&nbsp;&nbsp;\").replace(/  /g, \"&nbsp;&nbsp;\");\n}\n\n\n/**\n * Create a table header row.\n * @param {string[]} headings The headings.\n * @returns {string} Table row with headings.\n */ function $b78502e6136d7337$export$3359980f21752184(headings) {\n    var th = \"\";\n    for(let i = 0; i < headings.length; i++)th += \"<th>\" + headings[i] + \"</th>\";\n    return $b78502e6136d7337$export$b5ad96d32b19f99(th);\n}\nfunction $b78502e6136d7337$export$983f4376b55e6517(x, contentEditable = false) {\n    let r = \"<td\";\n    if (contentEditable) r += ' contenteditable=\"true\"';\n    r += \">\" + x + \"</td>\";\n    return r;\n}\nfunction $b78502e6136d7337$export$b5ad96d32b19f99(x) {\n    return \"<tr>\" + x + \"</tr>\\n\";\n}\nfunction $b78502e6136d7337$export$71b553ef914ccf29(x) {\n    return \"<table>\" + x + \"</table>\";\n}\nfunction $b78502e6136d7337$export$d0a97d36ec56002f(x, id, html_class) {\n    let r = \"<div\";\n    if (id !== null) r += ' id=\"' + id + '\"';\n    if (html_class !== null) r += ' class=\"' + html_class + '\"';\n    return r + \">\" + x + \"</div>\";\n}\nfunction $b78502e6136d7337$export$7c112ceec8941e67(type, id, func, value) {\n    let r = '<input type=\"' + type + '\"';\n    if (id !== null) r += ' id=\"' + id + '\"';\n    if (func !== null) r += ' onchange=\"' + func + '\"';\n    if (value !== null) r += ' value=\"' + value + '\"';\n    return r + \">\";\n}\nfunction $b78502e6136d7337$export$ff083c49da8fe0f9(attributes, tagName) {\n    let s = \"<\" + tagName;\n    if (attributes) for (let [key, value] of attributes)s += \" \" + key + '=\"' + value + '\"';\n    return s + \" />\";\n}\n\n\n\nclass $736d23970649c300$export$21991851b0bb231f {\n    /**\n     * The attributes.\n     */ attributes;\n    /**\n     * @param attributes The attributes.\n     */ constructor(attributes){\n        this.attributes = attributes;\n    }\n    /**\n     * @returns The name in lower case.\n     */ /*\n    get name(): string {\n        return this.constructor.name.toLowerCase().trim();\n    }\n    */ /**\n     * @returns A string representation.\n     */ toString() {\n        let r = this.constructor.name + `(`;\n        this.attributes.forEach((value, key)=>{\n            r += `${key}(${value}), `;\n        });\n        return r;\n    }\n    /**\n     * Get the tag representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns A tag representation.\n     */ toTag(tagName, padding) {\n        let s = (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(this.attributes, tagName);\n        if (padding) return \"\\n\" + padding + s;\n        return \"\\n\" + s;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, padding) {\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(\"\", tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\nclass $736d23970649c300$export$bf6a5b951c66187b extends $736d23970649c300$export$21991851b0bb231f {\n    value;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value.\n     */ constructor(attributes, value){\n        super(attributes);\n        this.value = value;\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        return super.toString() + `, ${this.value.toString()})`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, padding) {\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.value.toString().trim(), tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\nclass $736d23970649c300$export$a66b3a80833b522b extends $736d23970649c300$export$21991851b0bb231f {\n    /**\n     * The values.\n     */ values;\n    /**\n     * The delimiter of the values.\n     */ delimiter = \",\";\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number[]} values The values.\n     * @param {string} delimiter The delimiter of the values (Optional - default will be \",\").\n     */ constructor(attributes, values, delimiter){\n        super(attributes);\n        this.values = values;\n        if (delimiter) this.delimiter = delimiter;\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        return super.toString() + `, ${this.values.toString()})`;\n    }\n    /**\n     * Set the delimiter.\n     * @param {string} delimiter The delimiter.\n     */ setDelimiter(delimiter) {\n        this.delimiter = delimiter;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, padding) {\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.values.toString().replaceAll(\",\", this.delimiter), tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\n\n\n/**\n * For convertina a map to a string.\n * @param map The map to convert to a string.\n * @returns A string representation of all the entries in the map.\n */ function $be2031a98996b20c$export$dc22ec7f8e0b9ac(map) {\n    if (map == null) return \"\";\n    return Array.from(map.entries()).map(([key, value])=>`${key == null ? \"null\" : key.toString()}(${value == null ? \"null\" : value.toString()})`).join(\", \");\n}\nfunction $be2031a98996b20c$export$4323cc4280d5be7(array, delimiter) {\n    if (array == null) return \"\";\n    if (delimiter == null) delimiter = \", \";\n    return array.map((value)=>value == null ? \"null\" : value.toString()).join(delimiter);\n}\nfunction $be2031a98996b20c$export$8cfbaad830aa9e0a(s) {\n    let r = [];\n    for(let i = 0; i < s.length; i++)r.push(parseFloat(s[i]));\n    return r;\n}\nfunction $be2031a98996b20c$export$e90fb89750dba83f(s) {\n    return !isNaN(parseFloat(s));\n}\n\n\n\nclass $7d93ba3ef281f49d$export$80986e6afdd7e0cb extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * @param attributes The attributes. If there is no \"id\" or \"elementType\" key an error will be thrown.\n     */ constructor(attributes){\n        super(attributes);\n        let id = attributes.get(\"id\");\n        if (id == undefined) throw new Error(\"id is undefined\");\n        let elementType = attributes.get(\"elementType\");\n        if (elementType == undefined) throw new Error(\"elementType is undefined\");\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        let s = super.toString();\n        return s + `)`;\n    }\n    /**\n     * @returns The id of the atom.\n     */ get id() {\n        return this.attributes.get(\"id\");\n    }\n    /**\n     * @returns The element type of the atom.\n     */ get elementType() {\n        return this.attributes.get(\"elementType\");\n    }\n}\nclass $7d93ba3ef281f49d$export$153327fc99ac0c53 extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */ constructor(attributes){\n        super(attributes);\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        let s = super.toString();\n        return s + `)`;\n    }\n}\nclass $7d93ba3ef281f49d$export$41b04b3a73e7216d extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * The property value.\n     */ property;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {NumberWithAttributes | NumberArrayWithAttributes} property The property.\n     */ constructor(attributes, property){\n        super(attributes);\n        this.property = property;\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        return super.toString() + ` property(${this.property.toString()}))`;\n    }\n    /**\n     * @param padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(pad, padding) {\n        let padding1 = undefined;\n        if (pad != undefined) {\n            if (padding != undefined) padding1 = padding + pad;\n        }\n        if (this.property instanceof (0, $736d23970649c300$export$bf6a5b951c66187b)) return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.property.toXML(\"scalar\", padding1), \"property\", this.attributes, undefined, undefined, padding, true);\n        else return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.property.toXML(\"array\", padding1), \"property\", this.attributes, undefined, undefined, padding, true);\n    }\n}\nclass $7d93ba3ef281f49d$export$16fc56ab40b12b45 extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * @param attributes The attributes.\n     * @param units The units.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n}\nclass $7d93ba3ef281f49d$export$499950da20810ac9 extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * The DeltaEDown.\n     */ deltaEDown;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {DeltaEDown} deltaEDown The DeltaEDown.\n     */ constructor(attributes, deltaEDown){\n        super(attributes);\n        this.deltaEDown = deltaEDown;\n    }\n    /**\n     * @param padding - Optional padding string for formatting the XML output.\n     * @returns An XML representation.\n     */ toXML(pad, padding) {\n        if (pad == undefined) return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.deltaEDown.toXML(\"me.deltaEDown\", padding), \"me:energyTransferModel\", this.attributes, undefined, undefined, padding, false);\n        else return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.deltaEDown.toXML(\"me.deltaEDown\", padding), \"energyTransferModel\", undefined, undefined, undefined, padding, true);\n    }\n}\nclass $7d93ba3ef281f49d$export$bbdce6c921702068 {\n    type;\n    constructor(type){\n        this.type = type;\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        return `DOSCMethod(type(${this.type}))`;\n    }\n    /**\n     * @param padding The padding (Optional).\n     * @returns A tag representation.\n     */ toTag(padding) {\n        let s = `<me.DOSCMethod xsi:type=\"${this.type}\"/>`;\n        if (padding) return \"\\n\" + padding + s;\n        return \"\\n\" + s;\n    }\n}\nclass $7d93ba3ef281f49d$export$3da9759ad07746a3 extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    id;\n    // Atoms\n    atoms;\n    // Bonds\n    bonds;\n    // Properties\n    properties;\n    // EnergyTransferModel\n    energyTransferModel;\n    // DOSCMethod\n    dOSCMethod;\n    /**\n     * Create a molecule.\n     * @param {Map<string, string>} attributes The attributes. If there is no \"id\" key an error will be thrown.\n     * Additional attributes known about are \"description\" and \"active\", but these do not exist for all molecules\n     * in Mesmer XML input/output files.\n     * @param {Map<string, Atom>} atoms A Map of atoms with keys as ids.\n     * @param {Map<string, Bond>} bonds A Map of bonds with. The keys combine the ids of the two bonded atoms.\n     * @param {Map<string, Property>} properties A map of properties.\n     * @param {EnergyTransferModel | null} energyTransferModel The energy transfer model.\n     * @param {DOSCMethod | null} dOSCMethod The method for calculating density of states.\n     */ constructor(attributes, atoms, bonds, properties, energyTransferModel, dOSCMethod){\n        super(attributes);\n        let id = this.attributes.get(\"id\");\n        if (id == undefined) throw new Error(\"id is undefined\");\n        this.id = id;\n        this.atoms = atoms;\n        this.bonds = bonds;\n        this.properties = properties;\n        this.energyTransferModel = energyTransferModel;\n        this.dOSCMethod = dOSCMethod;\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        let r = `Molecule(id(${this.getID()}), `;\n        let description = this.getDescription();\n        if (description != undefined) r += `description(${description}), `;\n        let active = this.getActive();\n        if (active != undefined) r += `active(${active}), `;\n        if (this.atoms.size > 0) r += `atoms(${(0, $be2031a98996b20c$export$dc22ec7f8e0b9ac)(this.atoms)}), `;\n        if (this.bonds.size > 0) r += `bonds(${(0, $be2031a98996b20c$export$dc22ec7f8e0b9ac)(this.bonds)}), `;\n        if (this.properties.size > 0) r += `properties(${(0, $be2031a98996b20c$export$dc22ec7f8e0b9ac)(this.properties)}), `;\n        if (this.energyTransferModel) r += `energyTransferModel(${this.energyTransferModel.toString()}), `;\n        if (this.dOSCMethod) r += `dOSCMethod(${this.dOSCMethod.toString()}), `;\n        return r + `)`;\n    }\n    /**\n     * @return The id of the molecule.\n     */ getID() {\n        return this.attributes.get(\"id\");\n    }\n    /**\n     * Gets the description of the molecule.\n     * @returns The description of the molecule, or undefined if it is not set.\n     */ getDescription() {\n        return this.attributes.get(\"description\");\n    }\n    /**\n     * Gets the active status of the molecule.\n     * @returns The active status of the molecule, or undefined if it is not set.\n     */ getActive() {\n        let active = this.attributes.get(\"active\");\n        if (active != undefined) return true;\n        return active;\n    }\n    /**\n     * @returns {number} The energy of the molecule or zero if the energy is not set.\n     * @throws An error if \"me.ZPE\" is a property, but is not mapped to a PropertyScalar.\n     */ getEnergy() {\n        let zpe = this.properties.get(\"me:ZPE\");\n        if (zpe == undefined) return 0;\n        if (zpe.property instanceof (0, $736d23970649c300$export$bf6a5b951c66187b)) return zpe.property.value;\n        else throw new Error(\"Expected a PropertyScalar but got a PropertyArray and not sure how to handle that.\");\n    }\n    /**\n     * Set the Energy of the molecule.\n     * @param {number} energy The energy of the molecule in kcal/mol.\n     */ setEnergy(energy) {\n        let property = this.properties.get(\"me:ZPE\");\n        if (property == undefined) throw new Error(\"No me.ZPE property found\");\n        if (property.property instanceof (0, $736d23970649c300$export$a66b3a80833b522b)) throw new Error(\"Expected a NumberWithAttributes but got a NumberArrayWithAttributes and not sure how to handle that.\");\n        else property.property.value = energy;\n    }\n    /**\n     * Get the RotationConstants of the molecule.\n     * @returns The RotationConstants of the molecule.\n     */ getRotationConstants() {\n        let property = this.properties.get(\"me:rotConsts\");\n        if (property != undefined) {\n            if (property.property != null) {\n                if (property.property instanceof (0, $736d23970649c300$export$bf6a5b951c66187b)) return [\n                    property.property.value\n                ];\n                else return property.property.values;\n            } else return undefined;\n        }\n        return property;\n    }\n    /**\n     * Get the VibrationFrequencies of the molecule.\n     * @returns The VibrationFrequencies of the molecule.\n     */ getVibrationFrequencies() {\n        let property = this.properties.get(\"me:vibFreqs\");\n        if (property != undefined) {\n            if (property.property instanceof (0, $736d23970649c300$export$bf6a5b951c66187b)) return [\n                property.property.value\n            ];\n            else if (property.property instanceof (0, $736d23970649c300$export$a66b3a80833b522b)) return property.property.values;\n            else return undefined;\n        }\n        return property;\n    }\n    /**\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad (Optional).\n     * @param {number} level The level of padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, pad, level) {\n        // Padding\n        let padding0 = \"\";\n        let padding1 = \"\";\n        let padding2 = \"\";\n        let padding3 = \"\";\n        if (pad != undefined && level != undefined) {\n            padding0 = pad.repeat(level);\n            padding1 = padding0 + pad;\n            padding2 = padding1 + pad;\n            padding3 = padding2 + pad;\n        }\n        // Atoms\n        let atoms_xml = \"\";\n        for (let atom of this.atoms.values())atoms_xml += atom.toTag(\"atom\", padding2);\n        if (this.atoms.size > 1) {\n            if (atoms_xml != \"\") atoms_xml = (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(atoms_xml, \"atomArray\", undefined, undefined, undefined, padding1, true);\n        }\n        // Bonds\n        let bonds_xml = \"\";\n        for (let bond of this.bonds.values())bonds_xml += bond.toTag(\"bond\", padding2);\n        if (bonds_xml != \"\") bonds_xml = (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(bonds_xml, \"bondArray\", undefined, undefined, undefined, padding1, true);\n        // Properties\n        let properties_xml = \"\";\n        this.properties.forEach((property)=>{\n            let property_xml = \"\";\n            if (property.property instanceof (0, $736d23970649c300$export$bf6a5b951c66187b)) property_xml += property.property.toXML(\"scalar\", padding3);\n            else property_xml += property.property.toXML(\"array\", padding3);\n            properties_xml += (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(property_xml, \"property\", property.attributes, undefined, undefined, padding2, true);\n        });\n        if (this.properties.size > 1) {\n            if (properties_xml != \"\") properties_xml = (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(properties_xml, \"propertyList\", undefined, undefined, undefined, padding1, true);\n        }\n        // EnergyTransferModel\n        let energyTransferModel_xml = \"\";\n        if (this.energyTransferModel) energyTransferModel_xml = this.energyTransferModel.toXML(pad, padding1);\n        // DOSCMethod\n        let dOSCMethod_xml = \"\";\n        if (this.dOSCMethod) dOSCMethod_xml = this.dOSCMethod.toTag(padding1);\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(atoms_xml + bonds_xml + properties_xml + energyTransferModel_xml + dOSCMethod_xml, tagName, this.attributes, undefined, undefined, padding0, true);\n    }\n}\n\n\n\n\n\nclass $8f7fe2903675adfb$export$e8a062bb2fc9e2ba extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * A reference to the molecule.\n     */ molecule;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */ constructor(attributes, molecule){\n        super(attributes);\n        this.molecule = molecule;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad for an extra level of padding (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, pad, padding) {\n        let padding1 = \"\";\n        if (pad != undefined && padding != undefined) padding1 = padding + pad;\n        let s = this.toTag(\"molecule\", padding1);\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(s, tagName, undefined, undefined, undefined, padding, true);\n    }\n}\nclass $8f7fe2903675adfb$export$dcfd4302d04b7fb6 extends $8f7fe2903675adfb$export$e8a062bb2fc9e2ba {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */ constructor(attributes, molecule){\n        super(attributes, molecule);\n    }\n}\nclass $8f7fe2903675adfb$export$264ad599d7cef668 extends $8f7fe2903675adfb$export$e8a062bb2fc9e2ba {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */ constructor(attributes, molecule){\n        super(attributes, molecule);\n    }\n}\nclass $8f7fe2903675adfb$export$145c1ed87b1a2216 extends $8f7fe2903675adfb$export$e8a062bb2fc9e2ba {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */ constructor(attributes, molecule){\n        super(attributes, molecule);\n    }\n    /**\n     * A convenience method to get the ref (the molecule ID) of the transition state.\n     * @returns The ref of the transition state.\n     */ getRef() {\n        let s = this.attributes.get(\"ref\");\n        if (s == null) throw new Error('Attribute \"ref\" is undefined.');\n        return s;\n    }\n}\nclass $8f7fe2903675adfb$export$38ce90ac8b004d85 extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * A class for representing the Arrhenius pre-exponential factor.\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n}\nclass $8f7fe2903675adfb$export$1bdc69d2439d749d extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * A class for representing the Arrhenius pre-exponential factor.\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n}\nclass $8f7fe2903675adfb$export$8d95dd32819bc86c extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n}\nclass $8f7fe2903675adfb$export$d08982dd841d496f extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n}\nclass $8f7fe2903675adfb$export$c3cf6f96dac11421 extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */ constructor(attributes){\n        super(attributes);\n    }\n}\nclass $8f7fe2903675adfb$export$6fa70ee10f356b6 extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * The name of the method.\n     */ mCRCMethodName;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {string} name The name or xsi:type of the method.\n     */ constructor(attributes, name){\n        super(attributes);\n        this.mCRCMethodName = name;\n    }\n    toString() {\n        return `MCRCMethod(name(${this.mCRCMethodName}))`;\n    }\n}\nclass $8f7fe2903675adfb$export$191e95ebb11cc88 extends $8f7fe2903675adfb$export$6fa70ee10f356b6 {\n    /**\n     * The pre-exponential factor.\n     */ preExponential;\n    /**\n     * The activation energy.\n     */ activationEnergy;\n    /**\n     * The TInfinity.\n     */ tInfinity;\n    /**\n     * The nInfinity.\n     */ nInfinity;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {PreExponential | undefined} preExponential The pre-exponential factor.\n     * @param {ActivationEnergy | undefined} activationEnergy The activation energy.\n     * @param {TInfinity | undefined} tInfinity The TInfinity.\n     * @param {NInfinity | undefined} nInfinity The nInfinity.\n     */ constructor(attributes, preExponential, activationEnergy, tInfinity, nInfinity){\n        super(attributes, \"MesmerILT\");\n        this.preExponential = preExponential;\n        this.activationEnergy = activationEnergy;\n        this.tInfinity = tInfinity;\n        this.nInfinity = nInfinity;\n    }\n    toString() {\n        return `MesmerILT(${super.toString()}, ` + `preExponential(${this.preExponential}), ` + `activationEnergy(${this.activationEnergy}), ` + `TInfinity(${this.tInfinity}), ` + `nInfinity(${this.nInfinity}))`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, padding) {\n        let padding1 = \"\";\n        if (padding != undefined) padding1 = padding + \"  \";\n        let preExponential_xml = \"\";\n        if (this.preExponential != undefined) preExponential_xml = this.preExponential.toXML(\"me.preExponential\", padding1);\n        let activationEnergy_xml = \"\";\n        if (this.activationEnergy != undefined) activationEnergy_xml = this.activationEnergy.toXML(\"me.activationEnergy\", padding1);\n        let tInfinity_xml = \"\";\n        if (this.tInfinity != undefined) tInfinity_xml = this.tInfinity.toXML(\"me.nInfinity\", padding1);\n        let nInfinity_xml = \"\";\n        if (this.nInfinity != undefined) nInfinity_xml = this.nInfinity.toXML(\"me.nInfinity\", padding1);\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(preExponential_xml + activationEnergy_xml + tInfinity_xml + nInfinity_xml, tagName, this.attributes, undefined, undefined, padding, true);\n    }\n}\nclass $8f7fe2903675adfb$export$1dd2ea318727eda extends $8f7fe2903675adfb$export$6fa70ee10f356b6 {\n    harmonicReactantDiabat_FC;\n    harmonicReactantDiabat_XO;\n    harmonicProductDiabat_DE;\n    exponentialProductDiabat_A;\n    exponentialProductDiabat_B;\n    exponentialProductDiabat_DE;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} harmonicReactantDiabat_FC The harmonic reactant diabatic FC.\n     * @param {number} harmonicReactantDiabat_XO The harmonic reactant diabatic XO.\n     * @param {number} harmonicProductDiabat_DE The harmonic product diabatic DE.\n     * @param {number} exponentialProductDiabat_A The exponential product diabatic A.\n     * @param {number} exponentialProductDiabat_B The exponential product diabatic B.\n     * @param {number} exponentialProductDiabat_DE The exponential product diabatic DE.\n     */ constructor(attributes, harmonicReactantDiabat_FC, harmonicReactantDiabat_XO, harmonicProductDiabat_DE, exponentialProductDiabat_A, exponentialProductDiabat_B, exponentialProductDiabat_DE){\n        super(attributes, \"ZhuNakamuraCrossing\");\n        this.harmonicReactantDiabat_FC = harmonicReactantDiabat_FC;\n        this.harmonicReactantDiabat_XO = harmonicReactantDiabat_XO;\n        this.harmonicProductDiabat_DE = harmonicProductDiabat_DE;\n        this.exponentialProductDiabat_A = exponentialProductDiabat_A;\n        this.exponentialProductDiabat_B = exponentialProductDiabat_B;\n        this.exponentialProductDiabat_DE = exponentialProductDiabat_DE;\n    }\n    toString() {\n        return `ZhuNakamuraCrossing(${super.toString()}, ` + `harmonicReactantDiabat_FC(${this.harmonicReactantDiabat_FC.toString()}), ` + `harmonicReactantDiabat_XO(${this.harmonicReactantDiabat_XO.toString()}), ` + `harmonicProductDiabat_DE(${this.harmonicProductDiabat_DE.toString()}), ` + `exponentialProductDiabat_A(${this.exponentialProductDiabat_A.toString()}), ` + `exponentialProductDiabat_B(${this.exponentialProductDiabat_B.toString()}), ` + `exponentialProductDiabat_DE(${this.exponentialProductDiabat_DE.toString()}))`;\n    }\n}\nclass $8f7fe2903675adfb$export$d2ae4167a30cf6bb extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * The id of the reaction. This is also stored in the attributes, but is hee for convenience...\n     */ id;\n    /**\n     * The reactants in the reaction.\n     */ reactants;\n    /**\n     * The products of the reaction.\n     */ products;\n    /**\n     * The MCRCMethod.\n     */ mCRCMethod;\n    /**\n     * The transition state.\n     */ transitionState;\n    /**\n     * The tunneling.\n     */ tunneling;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {string} id The id of the reaction.\n     * @param {Map<string, Reactant>} reactants The reactants in the reaction.\n     * @param {Map<string, Product>} products The products of the reaction.\n     * @param {MCRCMethod | undefined} mCRCMethod The MCRCMethod (optional).\n     * @param {TransitionState | undefined} transitionState The transition state (optional).\n     * @param {Tunneling | undefined} tunneling The tunneling (optional).\n     */ constructor(attributes, id, reactants, products, mCRCMethod, transitionState, tunneling){\n        super(attributes);\n        this.id = id;\n        this.reactants = reactants;\n        this.products = products;\n        this.mCRCMethod = mCRCMethod;\n        this.transitionState = transitionState;\n        this.tunneling = tunneling;\n    }\n    /**\n     * Convert the product to a string.\n     * @returns String representation of the product.\n     */ toString() {\n        let s = super.toString();\n        return super.toString() + `id(${this.id}), ` + `reactants(${(0, $be2031a98996b20c$export$dc22ec7f8e0b9ac)(this.reactants)}), ` + `products(${(0, $be2031a98996b20c$export$dc22ec7f8e0b9ac)(this.products)}), ` + `mCRCMethod(${this.mCRCMethod?.toString()}), ` + `transitionState(${this.transitionState?.toString()}), ` + `tunneling(${this.tunneling?.toString()}))`;\n    }\n    /**\n     * Get the label of the reactants.\n     * @returns The label of the reactants.\n     */ getReactantsLabel() {\n        return Array.from(this.reactants.values()).map((reactant)=>reactant.molecule.id).join(\" + \");\n    }\n    /**\n     * Get the combined energy of the reactants.\n     * @returns The combined energy of the reactants.\n     */ getReactantsEnergy() {\n        return Array.from(this.reactants.values()).map((reactant)=>reactant.molecule.getEnergy()).reduce((a, b)=>a + b, 0);\n    }\n    /**\n     * Returns the label for the products.\n     * @returns The label for the products.\n     */ getProductsLabel() {\n        return Array.from(this.products.values()).map((product)=>product.molecule.id).join(\" + \");\n    }\n    /**\n     * Returns the total energy of all products.\n     * @returns The total energy of all products.\n     */ getProductsEnergy() {\n        return Array.from(this.products.values()).map((product)=>product.molecule.getEnergy()).reduce((a, b)=>a + b, 0);\n    }\n    /**\n     * Get the label of the reaction.\n     * @returns The label of the reaction.\n     */ getLabel() {\n        let label = this.getReactantsLabel() + \" -> \" + this.getProductsLabel();\n        return label;\n    }\n    /**\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad (Optional).\n     * @param {number} level The level of padding (Optional).\n     * @returns An XML representation.\n     */ toXML(tagName, pad, level) {\n        // Padding\n        let padding0 = \"\";\n        let padding1 = \"\";\n        let padding2 = \"\";\n        let padding3 = \"\";\n        if (pad != undefined && level != undefined) {\n            padding0 = pad.repeat(level);\n            padding1 = padding0 + pad;\n            padding2 = padding1 + pad;\n            padding3 = padding2 + pad;\n        }\n        // Reactants\n        let reactants_xml = \"\";\n        this.reactants.forEach((reactant)=>{\n            reactants_xml += reactant.toXML(\"reactant\", pad, padding1);\n        });\n        // Products\n        let products_xml = \"\";\n        this.products.forEach((product)=>{\n            products_xml += product.toXML(\"product\", pad, padding1);\n        });\n        // Tunneling\n        let tunneling_xml = \"\";\n        if (this.tunneling != undefined) tunneling_xml = this.tunneling.toTag(\"me.tunneling\", padding1);\n        // TransitionState\n        let transitionState_xml = \"\";\n        if (this.transitionState != undefined) transitionState_xml = this.transitionState.toXML(\"transitionState\", pad, padding1);\n        // MCRCMethod\n        let mCRCMethod_xml = \"\";\n        if (this.mCRCMethod != undefined) {\n            if (this.mCRCMethod instanceof $8f7fe2903675adfb$export$191e95ebb11cc88) mCRCMethod_xml = this.mCRCMethod.toXML(\"mCRCMethod\", padding1);\n            else mCRCMethod_xml = this.mCRCMethod.toTag(\"mCRCMethod\", padding1);\n        }\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(reactants_xml + products_xml + tunneling_xml + transitionState_xml + mCRCMethod_xml, tagName, this.attributes, undefined, undefined, padding0, true);\n    }\n}\n\n\n\n\n/**\n * Draw a horizontal line and add labels.\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} strokeStyle The name of a style to use for the line.\n * @param {number} strokewidth The width of the line.\n * @param {number} x0 The start x-coordinate of the line.\n * @param {number} y0 The start y-coordinate of the line. Also used for an energy label.\n * @param {number} x1 The end x-coordinate of the line.\n * @param {number} y1 The end y-coordinate of the line.\n * @param {string} font The font to use.\n * @param {number} th The height of the text in pixels.\n * @param {string} label The label.\n * @param {string} energyString The energy.\n */ function $3342a40c3ce9ada4$export$479ac392a7fb4419(ctx, strokeStyle, strokewidth, x0, y0, x1, y1, font, th, label, energyString) {\n    let x_centre = x0 + (x1 - x0) / 2;\n    $3342a40c3ce9ada4$export$bec150f75a9b8f11(ctx, energyString, font, strokeStyle, $3342a40c3ce9ada4$var$getTextStartX(ctx, energyString, font, x_centre), y1 + th);\n    $3342a40c3ce9ada4$export$bec150f75a9b8f11(ctx, label, font, strokeStyle, $3342a40c3ce9ada4$var$getTextStartX(ctx, label, font, x_centre), y1 + 3 * th);\n    $3342a40c3ce9ada4$export$819db45aec5fcbe5(ctx, strokeStyle, strokewidth, x0, y0, x1, y1);\n}\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the start x-coordinate of.\n * @param {string} font The font to use.\n * @param {number} x_centre The x-coordinate of the centre of the text.\n * @returns The x-coordinate of the start of the text.\n */ function $3342a40c3ce9ada4$var$getTextStartX(ctx, text, font, x_centre) {\n    let tw = $3342a40c3ce9ada4$export$37827d046293d309(ctx, text, font);\n    return x_centre - tw / 2;\n}\nfunction $3342a40c3ce9ada4$export$819db45aec5fcbe5(ctx, strokeStyle, strokewidth, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = strokewidth;\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\nfunction $3342a40c3ce9ada4$export$bec150f75a9b8f11(ctx, text, font, colour, x, y) {\n    // Save the context (to restore after).\n    ctx.save();\n    // Translate to the point where text is to be added.\n    ctx.translate(x, y);\n    // Invert Y-axis.\n    ctx.scale(1, -1);\n    // Set the text font.\n    ctx.font = font;\n    // Set the text colour.\n    ctx.fillStyle = colour;\n    // Write the text.\n    ctx.fillText(text, 0, 0);\n    // Restore the context.\n    ctx.restore();\n}\nfunction $3342a40c3ce9ada4$export$c398604a09be5382(ctx, text, font) {\n    ctx.font = font;\n    var fontMetric = ctx.measureText(text);\n    return fontMetric.actualBoundingBoxAscent + fontMetric.actualBoundingBoxDescent;\n}\nfunction $3342a40c3ce9ada4$export$37827d046293d309(ctx, text, font) {\n    ctx.font = font;\n    return ctx.measureText(text).width;\n}\n\n\n\n\n\n\nclass $e684439c17ac535a$export$3fe97ecb6b172244 extends (0, $736d23970649c300$export$21991851b0bb231f) {\n    /**\n     * The pressure also stored as a string in the attributes.\n     */ P;\n    /**\n     * The temperature also stored as a string in the attributes.\n     */ T;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */ constructor(attributes){\n        super(attributes);\n        let p = attributes.get(\"P\");\n        if (p) this.P = parseFloat(p);\n        else throw new Error(\"P is undefined\");\n        let t = attributes.get(\"T\");\n        if (t) this.T = parseFloat(t);\n        else throw new Error(\"T is undefined\");\n    }\n}\nclass $e684439c17ac535a$export$b33a132661f4be58 extends (0, $8f7fe2903675adfb$export$e8a062bb2fc9e2ba) {\n    constructor(attributes, molecule){\n        super(attributes, molecule);\n    }\n}\nclass $e684439c17ac535a$export$363c7374d425f4ad {\n    /**\n     * The bath gas.\n     */ bathGas;\n    /**\n     * The Pressure and Temperature pair.\n     */ pTs;\n    /**\n     * @param {BathGas} bathGas The bath gas.\n     * @param {PTpair} pTs The Pressure and Temperature pairs.\n     */ constructor(bathGas, pTs){\n        this.bathGas = bathGas;\n        this.pTs = pTs;\n    }\n    /**\n     * @returns A string representation.\n     */ toString() {\n        return `Conditions(` + `bathGas(${this.bathGas.toString()}), ` + `pTs(${this.pTs.toString()}))`;\n    }\n    /**\n     * @param padding The padding (optional).\n     * @returns An XML representation.\n     */ toXML(pad, padding) {\n        let padding1 = \"\";\n        if (pad != undefined && padding != undefined) padding1 = padding + pad;\n        let s = this.bathGas.toXML(\"bathGas\", pad, padding1);\n        this.pTs.forEach((pt)=>{\n            s += pt.toTag(\"PTpair\", padding1);\n        });\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(s, \"conditions\", undefined, undefined, undefined, padding, true);\n    }\n}\n\n\n\n\nclass $bdb7ec0f19c747d8$export$26e33f0df9ce919d extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * @param {string} units The units.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n    toString() {\n        return `GrainSize(${super.toString()})`;\n    }\n}\nclass $bdb7ec0f19c747d8$export$77f098867dc64198 {\n    /**\n     * The grain size.\n     */ grainSize;\n    /**\n     * The energy above the top hill.\n     */ energyAboveTheTopHill;\n    /**\n     * @param {GrainSize} grainSize The grain size.\n     * @param {number} energyAboveTheTopHill The energy above the top hill.\n     */ constructor(grainSize, energyAboveTheTopHill){\n        this.grainSize = grainSize;\n        this.energyAboveTheTopHill = energyAboveTheTopHill;\n    }\n    toString() {\n        return `ModelParameters(` + `grainSize(${this.grainSize.toString()}), ` + `energyAboveTheTopHill(${this.energyAboveTheTopHill.toString()}))`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} pad The pad (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(pad, padding) {\n        let padding2 = \"\";\n        if (pad != undefined && padding != undefined) padding2 = padding + pad;\n        let s = this.grainSize.toXML(\"me:GrainSize\", padding2);\n        s += (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(this.energyAboveTheTopHill.toString(), \"me:EnergyAboveTheTopHill\", undefined, undefined, undefined, padding2, false);\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(s, \"me:modelParameters\", undefined, undefined, undefined, padding, true);\n    }\n}\n\n\n\n\n\nclass $fa7565c9b69426dc$export$159b5d3263f1049a extends (0, $736d23970649c300$export$bf6a5b951c66187b) {\n    /**\n     * @param {Map<string, string>} attributes The attributes (ref refers to a particular reaction).\n     * @param {number} value The value.\n     */ constructor(attributes, value){\n        super(attributes, value);\n    }\n}\nclass $fa7565c9b69426dc$export$7a7fa4424cb20976 {\n    testDOS;\n    printSpeciesProfile;\n    testMicroRates;\n    testRateConstant;\n    printGrainDOS;\n    printCellDOS;\n    printReactionOperatorColumnSums;\n    printTunnellingCoefficients;\n    printGrainkfE;\n    printGrainBoltzmann;\n    printGrainkbE;\n    eigenvalues;\n    hideInactive;\n    diagramEnergyOffset;\n    constructor(testDOS, printSpeciesProfile, testMicroRates, testRateConstant, printGrainDOS, printCellDOS, printReactionOperatorColumnSums, printTunnellingCoefficients, printGrainkfE, printGrainBoltzmann, printGrainkbE, eigenvalues, hideInactive, diagramEnergyOffset){\n        this.testDOS = testDOS;\n        this.printSpeciesProfile = printSpeciesProfile;\n        this.testMicroRates = testMicroRates;\n        this.testRateConstant = testRateConstant;\n        this.printGrainDOS = printGrainDOS;\n        this.printCellDOS = printCellDOS;\n        this.printReactionOperatorColumnSums = printReactionOperatorColumnSums;\n        this.printTunnellingCoefficients = printTunnellingCoefficients;\n        this.printGrainkfE = printGrainkfE;\n        this.printGrainBoltzmann = printGrainBoltzmann;\n        this.printGrainkbE = printGrainkbE;\n        this.eigenvalues = eigenvalues;\n        this.hideInactive = hideInactive;\n        this.diagramEnergyOffset = diagramEnergyOffset;\n    }\n    toString() {\n        return `Control(` + `testDOS(${this.testDOS?.toString()}), ` + `printSpeciesProfile(${this.printSpeciesProfile?.toString()}), ` + `testMicroRates(${this.testMicroRates?.toString()}), ` + `testRateConstant(${this.testRateConstant?.toString()}), ` + `printGrainDOS(${this.printGrainDOS?.toString()}), ` + `printCellDOS(${this.printCellDOS?.toString()}), ` + `printReactionOperatorColumnSums(${this.printReactionOperatorColumnSums?.toString()}), ` + `printTunnellingCoefficients(${this.printTunnellingCoefficients?.toString()}), ` + `printGrainkfE(${this.printGrainkfE?.toString()}), ` + `printGrainBoltzmann(${this.printGrainBoltzmann?.toString()}), ` + `printGrainkbE(${this.printGrainkbE?.toString()}), ` + `eigenvalues(${this.eigenvalues?.toString()}), ` + `hideInactive(${this.hideInactive?.toString()}))`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} pad The pad (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */ toXML(pad, padding) {\n        let padding1 = \"\";\n        if (pad != undefined && padding != undefined) padding1 = padding + pad;\n        let s = \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:testDOS\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printSpeciesProfile\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:testMicroRates\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:testRateConstant\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printGrainDOS\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printCellDOS\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printReactionOperatorColumnSums\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printTunnellingCoefficients\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printGrainkfE\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printGrainBoltzmann\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:printGrainkbE\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:eigenvalues\") + \"\\n\";\n        s += padding1 + (0, $b78502e6136d7337$export$ff083c49da8fe0f9)(null, \"me:hideInactive\");\n        s += this.diagramEnergyOffset?.toXML(\"me:diagramEnergyOffset\", padding1);\n        return (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(s, \"control\", undefined, undefined, null, padding, true);\n    }\n}\n\n\nvar $1fcfddc64feeb124$exports = {};\n$1fcfddc64feeb124$exports = new URL(\"sw.464808ce.js\", import.meta.url).toString();\n\n\n// Code for service worker for Progressive Web App (PWA).\nif (\"serviceWorker\" in navigator) window.addEventListener(\"load\", function() {\n    const swUrl = new URL($1fcfddc64feeb124$exports);\n    //const swUrl = new URL('../../../sw.js', document.baseURI);\n    navigator.serviceWorker.register(swUrl);\n});\n// Expected XML tags strings.\nlet $850cc5ea4a4ae46d$var$me_title_s = \"me:title\";\n/**\n * For storing me.title.\n */ let $850cc5ea4a4ae46d$var$title;\n/**\n * For storing the XML root start tag.\n */ let $850cc5ea4a4ae46d$var$mesmerStartTag;\n/**\n * For storing the XML root end tag.\n */ let $850cc5ea4a4ae46d$var$mesmerEndTag;\n/**\n * A map of molecules with Molecule.id as key and Molecules as values.\n */ let $850cc5ea4a4ae46d$var$molecules = new Map([]);\n/**\n * For storing the maximum molecule energy in a reaction.\n */ let $850cc5ea4a4ae46d$var$maxMoleculeEnergy = -Infinity;\n/**\n * For storing the minimum molecule energy in a reaction.\n */ let $850cc5ea4a4ae46d$var$minMoleculeEnergy = Infinity;\n/**\n * A map of reactions with Reaction.id as keys and Reactions as values.\n */ let $850cc5ea4a4ae46d$var$reactions = new Map([]);\n/**\n * The header of the XML file.\n */ const $850cc5ea4a4ae46d$var$header = `<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<?xml-stylesheet type='text/xsl' href='../../mesmer2.xsl' media='other'?>\n<?xml-stylesheet type='text/xsl' href='../../mesmer1.xsl' media='screen'?>`;\n/**\n * The filename of the mesmer input file loaded.\n */ let $850cc5ea4a4ae46d$var$input_xml_filename;\n/**\n * The load button.\n */ let $850cc5ea4a4ae46d$var$loadButton;\n/**\n * The save button.\n */ let $850cc5ea4a4ae46d$var$saveButton;\n/**\n * The XML text element.\n */ let $850cc5ea4a4ae46d$var$me_title;\nlet $850cc5ea4a4ae46d$var$molecules_title;\nlet $850cc5ea4a4ae46d$var$molecules_table;\nlet $850cc5ea4a4ae46d$var$reactions_title;\nlet $850cc5ea4a4ae46d$var$reactions_table;\nlet $850cc5ea4a4ae46d$var$reactions_diagram_title;\nlet $850cc5ea4a4ae46d$var$conditions_title;\nlet $850cc5ea4a4ae46d$var$conditions_table;\nlet $850cc5ea4a4ae46d$var$modelParameters_title;\nlet $850cc5ea4a4ae46d$var$modelParameters_table;\nlet $850cc5ea4a4ae46d$var$xml_title;\nlet $850cc5ea4a4ae46d$var$xml_text;\n/**\n * Display the XML.\n * @param {string} xml The XML to display.\n */ function $850cc5ea4a4ae46d$var$displayXML(xml) {\n    //console.log(\"xml=\" + xml);\n    if ($850cc5ea4a4ae46d$var$xml_title != null) $850cc5ea4a4ae46d$var$xml_title.innerHTML = $850cc5ea4a4ae46d$var$input_xml_filename;\n    if ($850cc5ea4a4ae46d$var$xml_text != null) $850cc5ea4a4ae46d$var$xml_text.innerHTML = (0, $2772ddfff48d4e5b$export$438fa7935f716bdf)(xml);\n}\n/**\n * Parses xml to initilise molecules.\n * @param {XMLDocument} xml The XML document.\n */ function $850cc5ea4a4ae46d$var$initMolecules(xml) {\n    let moleculeList_s = \"moleculeList\";\n    console.log(moleculeList_s);\n    let xml_moleculeList = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml, moleculeList_s);\n    // Set molecules_title.\n    $850cc5ea4a4ae46d$var$molecules_title = document.getElementById(\"molecules_title\");\n    if ($850cc5ea4a4ae46d$var$molecules_title != null) $850cc5ea4a4ae46d$var$molecules_title.innerHTML = \"Molecules\";\n    // xml_moleculeList should have one or more molecule elements and no other elements.\n    let moleculeListTagNames = new Set();\n    xml_moleculeList.childNodes.forEach(function(node) {\n        moleculeListTagNames.add(node.nodeName);\n    });\n    if (moleculeListTagNames.size != 1) {\n        if (!(moleculeListTagNames.size == 2 && moleculeListTagNames.has(\"#text\"))) {\n            console.error(\"moleculeListTagNames:\");\n            moleculeListTagNames.forEach((x)=>console.error(x));\n            throw new Error(\"Additional tag names in moleculeList:\");\n        }\n    }\n    if (!moleculeListTagNames.has(\"molecule\")) throw new Error(\"Expecting molecule tagName but it is not present!\");\n    let xml_molecules = xml_moleculeList.getElementsByTagName(\"molecule\");\n    let xml_molecules_length = xml_molecules.length;\n    console.log(\"Number of molecules=\" + xml_molecules_length);\n    // Process each molecule.\n    //xml_molecules.forEach(function (xml_molecule) { // Cannot iterate over HTMLCollectionOf like this.\n    for(let i = 0; i < xml_molecules.length; i++){\n        // Set attributes.\n        let attributes = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_molecules[i]);\n        let moleculeTagNames = new Set();\n        let cns = xml_molecules[i].childNodes;\n        cns.forEach(function(node) {\n            moleculeTagNames.add(node.nodeName);\n        });\n        //console.log(\"moleculeTagNames:\");\n        //moleculeTagNames.forEach(x => console.log(x));\n        // Set atoms.\n        const atoms = new Map();\n        // Sometimes there is an individual atom not in an atomArray.\n        //let xml_atomArray = xml_molecules[i].getElementsByTagName(\"atomArray\")[0];\n        //if (xml_atomArray != null) {\n        moleculeTagNames.delete(\"atom\");\n        moleculeTagNames.delete(\"atomArray\");\n        let xml_atoms = xml_molecules[i].getElementsByTagName(\"atom\");\n        for(let j = 0; j < xml_atoms.length; j++){\n            let attribs = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_atoms[j]);\n            let id = attribs.get(\"id\");\n            if (id != undefined) {\n                let atom = new (0, $7d93ba3ef281f49d$export$80986e6afdd7e0cb)(attribs);\n                //console.log(atom.toString());\n                atoms.set(id, atom);\n            }\n        }\n        //}\n        // Read bondArray.\n        moleculeTagNames.delete(\"bond\");\n        moleculeTagNames.delete(\"bondArray\");\n        const bonds = new Map();\n        let xml_bonds = xml_molecules[i].getElementsByTagName(\"bond\");\n        for(let j = 0; j < xml_bonds.length; j++){\n            let attribs = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_bonds[j]);\n            let id = attribs.get(\"atomRefs2\");\n            if (id != undefined) {\n                let bond = new (0, $7d93ba3ef281f49d$export$153327fc99ac0c53)(attribs);\n                //console.log(bond.toString());\n                bonds.set(id, bond);\n            }\n        }\n        // Read propertyList.\n        const properties = new Map();\n        // Sometimes there is a single property not in propertyList!\n        //let xml_propertyList = xml_molecules[i].getElementsByTagName(\"propertyList\")[0];\n        //if (xml_propertyList != null) {\n        //    let xml_properties = xml_propertyList.getElementsByTagName(\"property\");\n        moleculeTagNames.delete(\"property\");\n        moleculeTagNames.delete(\"propertyList\");\n        let xml_properties = xml_molecules[i].getElementsByTagName(\"property\");\n        for(let j = 0; j < xml_properties.length; j++){\n            let attribs = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_properties[j]);\n            let children = xml_properties[j].children;\n            if (children.length != 1) throw new Error(\"Expecting 1 child but finding \" + children.length);\n            let nodeAttributes = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(children[0]);\n            let nodeName = children[0].nodeName; // Expecting scalar or array\n            let textContent = children[0].textContent;\n            if (textContent == null) {\n                console.error(\"nodeName\");\n                throw new Error(\"textContent is null\");\n            }\n            textContent = textContent.trim();\n            let dictRef = attribs.get(\"dictRef\");\n            //console.log(\"dictRef=\" + dictRef);\n            if (dictRef == null) throw new Error(\"dictRef is null\");\n            //console.log(\"fcnn=\" + fcnn);\n            if (nodeName == \"scalar\") {\n                moleculeTagNames.delete(\"scalar\");\n                let value = parseFloat(textContent);\n                properties.set(dictRef, new (0, $7d93ba3ef281f49d$export$41b04b3a73e7216d)(attribs, new (0, $736d23970649c300$export$bf6a5b951c66187b)(nodeAttributes, value)));\n                if (dictRef === \"me:ZPE\") {\n                    $850cc5ea4a4ae46d$var$minMoleculeEnergy = Math.min($850cc5ea4a4ae46d$var$minMoleculeEnergy, value);\n                    $850cc5ea4a4ae46d$var$maxMoleculeEnergy = Math.max($850cc5ea4a4ae46d$var$maxMoleculeEnergy, value);\n                }\n            } else if (nodeName == \"array\") {\n                moleculeTagNames.delete(\"array\");\n                properties.set(dictRef, new (0, $7d93ba3ef281f49d$export$41b04b3a73e7216d)(attribs, new (0, $736d23970649c300$export$a66b3a80833b522b)(nodeAttributes, (0, $be2031a98996b20c$export$8cfbaad830aa9e0a)(textContent.split(/\\s+/)), \" \")));\n            } else if (nodeName == \"matrix\") ;\n            else throw new Error(\"Unexpected nodeName: \" + nodeName);\n        }\n        let els;\n        // Read energyTransferModel\n        moleculeTagNames.delete(\"me:energyTransferModel\");\n        let energyTransferModel = undefined;\n        els = xml_molecules[i].getElementsByTagName(\"me:energyTransferModel\");\n        if (els != null) {\n            if (els.length > 0) {\n                if (els.length != 1) throw new Error(\"energyTransferModel length=\" + els.length);\n                let xml_deltaEDown = els[0].getElementsByTagName(\"me:deltaEDown\");\n                if (xml_deltaEDown != null) {\n                    if (xml_deltaEDown.length != 1) throw new Error(\"deltaEDown length=\" + xml_deltaEDown.length);\n                    let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_deltaEDown[0])));\n                    let deltaEDown = new (0, $7d93ba3ef281f49d$export$16fc56ab40b12b45)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_deltaEDown[0]), value);\n                    energyTransferModel = new (0, $7d93ba3ef281f49d$export$499950da20810ac9)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(els[0]), deltaEDown);\n                }\n            }\n        }\n        // Read DOSCMethod\n        moleculeTagNames.delete(\"me:DOSCMethod\");\n        let dOSCMethod = undefined;\n        els = xml_molecules[i].getElementsByTagName(\"me:DOSCMethod\");\n        if (els != null) {\n            let el = els[0];\n            if (el != null) {\n                if (el != null) {\n                    let type = el.getAttribute(\"xsi:type\");\n                    if (type != null) dOSCMethod = new (0, $7d93ba3ef281f49d$export$bbdce6c921702068)(type);\n                }\n            }\n        }\n        // Check for unexpected tags.\n        moleculeTagNames.delete(\"#text\");\n        if (moleculeTagNames.size > 0) {\n            console.error(\"Remaining moleculeTagNames:\");\n            moleculeTagNames.forEach((x)=>console.error(x));\n            throw new Error(\"Unexpected tags in molecule.\");\n        }\n        let molecule = new (0, $7d93ba3ef281f49d$export$3da9759ad07746a3)(attributes, atoms, bonds, properties, energyTransferModel, dOSCMethod);\n        //console.log(molecule.toString());\n        $850cc5ea4a4ae46d$var$molecules.set(molecule.id, molecule);\n    }\n    // Add event listeners to molecules table.\n    $850cc5ea4a4ae46d$var$molecules.forEach(function(molecule, id) {\n        let energyKey = id + \"_energy\";\n        let inputElement = document.getElementById(energyKey);\n        if (inputElement) inputElement.addEventListener(\"change\", (event)=>{\n            // The input is set up to call the function setEnergy(HTMLInputElement),\n            // so the following commented code is not used. As the input was setup \n            // as a number type. The any non numbers were It seems that there are two \n            // ways to get and store the value of the input element.\n            // Both ways have been kept for now as I don't know which way is better!\n            let eventTarget = event.target;\n            let inputValue = eventTarget.value;\n            if ((0, $be2031a98996b20c$export$e90fb89750dba83f)(inputValue)) {\n                molecule.setEnergy(parseFloat(inputValue));\n                console.log(\"Set energy of \" + id + \" to \" + inputValue + \" kJ/mol\");\n            } else {\n                alert(\"Energy input for \" + id + \" is not a number\");\n                let inputElement = document.getElementById(energyKey);\n                inputElement.value = molecule.getEnergy().toString();\n                console.log(\"inputValue=\" + inputValue);\n                console.log(\"Type of inputValue: \" + typeof inputValue);\n            }\n        });\n    });\n}\nlet $850cc5ea4a4ae46d$var$inputElement;\nfunction $850cc5ea4a4ae46d$var$reload() {\n    $850cc5ea4a4ae46d$var$inputElement = document.createElement(\"input\");\n    $850cc5ea4a4ae46d$var$inputElement.type = \"file\";\n    $850cc5ea4a4ae46d$var$inputElement.onchange = function() {\n        if ($850cc5ea4a4ae46d$var$inputElement.files) {\n            for(let i = 0; i < $850cc5ea4a4ae46d$var$inputElement.files.length; i++)console.log(\"inputElement.files[\" + i + \"]=\" + $850cc5ea4a4ae46d$var$inputElement.files[i]);\n            let file = $850cc5ea4a4ae46d$var$inputElement.files[0];\n            //console.log(\"file=\" + file);\n            console.log(file.name);\n            $850cc5ea4a4ae46d$var$input_xml_filename = file.name;\n            if ($850cc5ea4a4ae46d$var$xml_text != null) {\n                let reader = new FileReader();\n                let chunkSize = 1048576; // 1MB\n                let start = 0;\n                let contents = \"\";\n                reader.onload = function(e) {\n                    if (!e.target) throw new Error(\"Event target is null\");\n                    contents += e.target.result;\n                    if (file != null) {\n                        if (start < file.size) {\n                            // Read the next chunk\n                            let blob = file.slice(start, start + chunkSize);\n                            reader.readAsText(blob);\n                            start += chunkSize;\n                        } else {\n                            // All chunks have been read\n                            contents = contents.trim();\n                            $850cc5ea4a4ae46d$var$displayXML(contents);\n                            let parser = new DOMParser();\n                            let xml = parser.parseFromString(contents, \"text/xml\");\n                            $850cc5ea4a4ae46d$var$parse(xml);\n                            // Send XML to the server\n                            fetch(\"http://localhost:1234/\", {\n                                method: \"POST\",\n                                headers: {\n                                    \"Content-Type\": \"text/xml\"\n                                },\n                                body: contents\n                            }).then((response)=>{\n                                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n                                return response.text();\n                            }).then((data)=>{\n                                console.log(\"Server response:\", data);\n                            }).catch((error)=>{\n                                console.error(\"There was a problem with the fetch operation:\", error);\n                            });\n                        }\n                    }\n                };\n                // Read the first chunk\n                let blob = file.slice(start, start + chunkSize);\n                reader.readAsText(blob);\n                start += chunkSize;\n            }\n        }\n    };\n    $850cc5ea4a4ae46d$var$inputElement.click();\n    // Add event listener to load button.\n    $850cc5ea4a4ae46d$var$loadButton = document.getElementById(\"load_button\");\n    if ($850cc5ea4a4ae46d$var$loadButton != null) $850cc5ea4a4ae46d$var$loadButton.addEventListener(\"click\", $850cc5ea4a4ae46d$var$reload);\n    // Ensure save button is displayed.\n    $850cc5ea4a4ae46d$var$saveButton = document.getElementById(\"saveButton\");\n    if ($850cc5ea4a4ae46d$var$saveButton != null) $850cc5ea4a4ae46d$var$saveButton.style.display = \"inline\";\n}\n/**\n * Once the DOM is loaded, set up the elements.\n */ document.addEventListener(\"DOMContentLoaded\", (event)=>{\n    // Initialise elements\n    $850cc5ea4a4ae46d$var$xml_title = document.getElementById(\"xml_title\");\n    $850cc5ea4a4ae46d$var$xml_text = document.getElementById(\"xml_text\");\n    window.loadXML = function() {\n        $850cc5ea4a4ae46d$var$reload();\n    };\n});\n/**\n * Set the title.\n * @param {XMLDocument} xml The XML document.\n */ function $850cc5ea4a4ae46d$var$setTitle(xml) {\n    $850cc5ea4a4ae46d$var$me_title = xml.getElementsByTagName($850cc5ea4a4ae46d$var$me_title_s);\n    if ($850cc5ea4a4ae46d$var$me_title == null) throw new Error($850cc5ea4a4ae46d$var$me_title_s + \" not found\");\n    else {\n        if ($850cc5ea4a4ae46d$var$me_title.length != 1) throw new Error(\"Multiple \" + $850cc5ea4a4ae46d$var$me_title_s + \" elements found\");\n        else {\n            $850cc5ea4a4ae46d$var$title = $850cc5ea4a4ae46d$var$me_title[0].childNodes[0].nodeValue;\n            $850cc5ea4a4ae46d$var$title = $850cc5ea4a4ae46d$var$title.trim();\n            console.log(\"Title=\" + $850cc5ea4a4ae46d$var$title);\n            let e = document.getElementById(\"title\");\n            if (e != null) e.innerHTML = $850cc5ea4a4ae46d$var$title;\n        }\n    }\n}\n/**\n * Parse the XML.\n * @param {XMLDocument} xml\n */ function $850cc5ea4a4ae46d$var$parse(xml) {\n    /**\n     * Set mesmer_xml start tag.\n     */ $850cc5ea4a4ae46d$var$mesmerStartTag = \"\\n\";\n    let documentElement = xml.documentElement;\n    if (documentElement == null) throw new Error(\"Document element not found\");\n    else {\n        let tagName = documentElement.tagName;\n        $850cc5ea4a4ae46d$var$mesmerStartTag += \"<\" + tagName;\n        console.log(tagName);\n        $850cc5ea4a4ae46d$var$mesmerEndTag = (0, $2772ddfff48d4e5b$export$34b7e1ae786b72b0)(tagName, \"\", true);\n        let first = true;\n        let pad = \" \".repeat(tagName.length + 2);\n        let names = documentElement.getAttributeNames();\n        names.forEach(function(name) {\n            let attribute = documentElement.getAttribute(name);\n            let na = `${name}=\"${attribute}\"`;\n            if (first) {\n                first = false;\n                $850cc5ea4a4ae46d$var$mesmerStartTag += \" \" + na;\n            } else $850cc5ea4a4ae46d$var$mesmerStartTag += \"\\n\" + pad + na;\n        });\n        $850cc5ea4a4ae46d$var$mesmerStartTag += \">\";\n    //console.log(mesmerStartTag);\n    }\n    /**\n     *  Set title.\n     */ $850cc5ea4a4ae46d$var$setTitle(xml);\n    /**\n     * Generate molecules table.\n     */ $850cc5ea4a4ae46d$var$initMolecules(xml);\n    $850cc5ea4a4ae46d$var$displayMoleculesTable();\n    /**\n     * Generate reactions table.\n     */ $850cc5ea4a4ae46d$var$initReactions(xml);\n    $850cc5ea4a4ae46d$var$displayReactionsTable();\n    $850cc5ea4a4ae46d$var$displayReactionsDiagram();\n    /**\n     * Generate conditions table.\n     */ $850cc5ea4a4ae46d$var$initConditions(xml);\n    $850cc5ea4a4ae46d$var$displayConditions();\n    /**\n     * Generate parameters table.\n     */ $850cc5ea4a4ae46d$var$initModelParameters(xml);\n    $850cc5ea4a4ae46d$var$displayModelParameters();\n    /**\n     * Generate control table.\n     */ $850cc5ea4a4ae46d$var$initControl(xml);\n    $850cc5ea4a4ae46d$var$displayControl();\n}\nlet $850cc5ea4a4ae46d$var$conditions;\n/**\n * Parse xml to initialise conditions.\n * @param {XMLDocument} xml The XML document.\n */ function $850cc5ea4a4ae46d$var$initConditions(xml) {\n    let me_conditions_s = \"me:conditions\";\n    console.log(me_conditions_s);\n    let xml_conditions = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml, me_conditions_s);\n    // Set conditions_title.\n    $850cc5ea4a4ae46d$var$conditions_title = document.getElementById(\"conditions_title\");\n    if ($850cc5ea4a4ae46d$var$conditions_title != null) $850cc5ea4a4ae46d$var$conditions_title.innerHTML = \"Conditions\";\n    // BathGas\n    let xml_bathGas = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml_conditions, \"me:bathGas\");\n    let attributes = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_bathGas);\n    let bathGas = new (0, $e684439c17ac535a$export$b33a132661f4be58)(attributes, (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)($850cc5ea4a4ae46d$var$molecules, xml_bathGas.childNodes[0].nodeValue));\n    // PTs\n    let xml_PTs = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml_conditions, \"me:PTs\");\n    let xml_PTPairs = xml_PTs.getElementsByTagName(\"me:PTpair\");\n    // Process each PTpair.\n    let PTs = [];\n    for(let i = 0; i < xml_PTPairs.length; i++)PTs.push(new (0, $e684439c17ac535a$export$3fe97ecb6b172244)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_PTPairs[i])));\n    $850cc5ea4a4ae46d$var$conditions = new (0, $e684439c17ac535a$export$363c7374d425f4ad)(bathGas, PTs);\n}\nlet $850cc5ea4a4ae46d$var$modelParameters;\n/**\n * Parses xml to initialise modelParameters.\n * @param {XMLDocument} xml The XML document.\n */ function $850cc5ea4a4ae46d$var$initModelParameters(xml) {\n    let me_modelParameters_s = \"me:modelParameters\";\n    console.log(me_modelParameters_s);\n    let xml_modelParameters = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml, me_modelParameters_s);\n    // Set modelParameters_title.\n    $850cc5ea4a4ae46d$var$modelParameters_title = document.getElementById(\"modelParameters_title\");\n    if ($850cc5ea4a4ae46d$var$modelParameters_title != null) $850cc5ea4a4ae46d$var$modelParameters_title.innerHTML = \"Model Parameters\";\n    // GrainSize\n    let xml_grainSize = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml_modelParameters, \"me:grainSize\");\n    let attributes = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_grainSize);\n    let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_grainSize)));\n    let grainSize = new (0, $bdb7ec0f19c747d8$export$26e33f0df9ce919d)(attributes, value);\n    // EnergyAboveTheTopHill\n    let xml_energyAboveTheTopHill = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml_modelParameters, \"me:energyAboveTheTopHill\");\n    let energyAboveTheTopHill = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_energyAboveTheTopHill)));\n    $850cc5ea4a4ae46d$var$modelParameters = new (0, $bdb7ec0f19c747d8$export$77f098867dc64198)(grainSize, energyAboveTheTopHill);\n}\nlet $850cc5ea4a4ae46d$var$control;\n/**\n * Parses xml to initialise control.\n * @param {XMLDocument} xml The XML document.\n */ function $850cc5ea4a4ae46d$var$initControl(xml) {\n    let me_control_s = \"me:control\";\n    console.log(me_control_s);\n    let xml_control = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml, me_control_s);\n    // Set control_title.\n    let control_title = document.getElementById(\"control_title\");\n    if (control_title != null) control_title.innerHTML = \"Control\";\n    // me:testDOS\n    let xml_testDOS = xml_control.getElementsByTagName(\"me:testDOS\");\n    let testDOS;\n    if (xml_testDOS.length > 0) testDOS = true;\n    // me:printSpeciesProfile\n    let xml_printSpeciesProfile = xml_control.getElementsByTagName(\"me:printSpeciesProfile\");\n    let printSpeciesProfile;\n    if (xml_printSpeciesProfile.length > 0) printSpeciesProfile = true;\n    // me:testMicroRates\n    let xml_testMicroRates = xml_control.getElementsByTagName(\"me:testMicroRates\");\n    let testMicroRates;\n    if (xml_testMicroRates.length > 0) testMicroRates = true;\n    // me:testRateConstant\n    let xml_testRateConstant = xml_control.getElementsByTagName(\"me:testRateConstant\");\n    let testRateConstant;\n    if (xml_testRateConstant.length > 0) testRateConstant = true;\n    // me:printGrainDOS\n    let xml_printGrainDOS = xml_control.getElementsByTagName(\"me:printGrainDOS\");\n    let printGrainDOS;\n    if (xml_printGrainDOS.length > 0) printGrainDOS = true;\n    // me:printCellDOS\n    let xml_printCellDOS = xml_control.getElementsByTagName(\"me:printCellDOS\");\n    let printCellDOS;\n    if (xml_printCellDOS.length > 0) printCellDOS = true;\n    // me:printReactionOperatorColumnSums\n    let xml_printReactionOperatorColumnSums = xml_control.getElementsByTagName(\"me:printReactionOperatorColumnSums\");\n    let printReactionOperatorColumnSums;\n    if (xml_printReactionOperatorColumnSums.length > 0) printReactionOperatorColumnSums = true;\n    // me:printTunnellingCoefficients\n    let xml_printTunnellingCoefficients = xml_control.getElementsByTagName(\"me:printTunnellingCoefficients\");\n    let printTunnellingCoefficients;\n    if (xml_printTunnellingCoefficients.length > 0) printTunnellingCoefficients = true;\n    // me:printGrainkfE\n    let xml_printGrainkfE = xml_control.getElementsByTagName(\"me:printGrainkfE\");\n    let printGrainkfE;\n    if (xml_printGrainkfE.length > 0) printGrainkfE = true;\n    // me:printGrainBoltzmann\n    let xml_printGrainBoltzmann = xml_control.getElementsByTagName(\"me:printGrainBoltzmann\");\n    let printGrainBoltzmann;\n    if (xml_printGrainBoltzmann.length > 0) printGrainBoltzmann = true;\n    // me:printGrainkbE\n    let xml_printGrainkbE = xml_control.getElementsByTagName(\"me:printGrainkbE\");\n    let printGrainkbE;\n    if (xml_printGrainkbE.length > 0) printGrainkbE = true;\n    // me:eigenvalues\n    let xml_eigenvalues = xml_control.getElementsByTagName(\"me:eigenvalues\");\n    let eigenvalues;\n    if (xml_eigenvalues.length > 0) eigenvalues = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_eigenvalues[0])));\n    // me:hideInactive\n    let xml_hideInactive = xml_control.getElementsByTagName(\"me:hideInactive\");\n    let hideInactive;\n    if (xml_hideInactive.length > 0) hideInactive = true;\n    // me:diagramEnergyOffset\n    let xml_diagramEnergyOffset = xml_control.getElementsByTagName(\"me:diagramEnergyOffset\");\n    let diagramEnergyOffset;\n    if (xml_diagramEnergyOffset.length > 0) {\n        let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_diagramEnergyOffset[0])));\n        diagramEnergyOffset = new (0, $fa7565c9b69426dc$export$159b5d3263f1049a)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_diagramEnergyOffset[0]), value);\n    }\n    $850cc5ea4a4ae46d$var$control = new (0, $fa7565c9b69426dc$export$7a7fa4424cb20976)(testDOS, printSpeciesProfile, testMicroRates, testRateConstant, printGrainDOS, printCellDOS, printReactionOperatorColumnSums, printTunnellingCoefficients, printGrainkfE, printGrainBoltzmann, printGrainkbE, eigenvalues, hideInactive, diagramEnergyOffset);\n}\n/**\n * Parses xml to initialise reactions.\n * @param {XMLDocument} xml The XML document.\n */ function $850cc5ea4a4ae46d$var$initReactions(xml) {\n    let reactionList_s = \"reactionList\";\n    console.log(reactionList_s);\n    let xml_reactionList = (0, $2772ddfff48d4e5b$export$b7531b8ff18dc588)(xml, reactionList_s);\n    let xml_reactions = xml_reactionList.getElementsByTagName(\"reaction\");\n    let xml_reactions_length = xml_reactions.length;\n    console.log(\"Number of reactions=\" + xml_reactions_length);\n    // Process each reaction.\n    if (xml_reactions_length == 0) //return;\n    throw new Error(\"No reactions: There should be at least 1!\");\n    // Set reactions_title.\n    $850cc5ea4a4ae46d$var$reactions_title = document.getElementById(\"reactions_title\");\n    if ($850cc5ea4a4ae46d$var$reactions_title != null) $850cc5ea4a4ae46d$var$reactions_title.innerHTML = \"Reactions\";\n    for(let i = 0; i < xml_reactions_length; i++){\n        let attributes = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_reactions[i]);\n        let reactionID = attributes.get(\"id\");\n        if (reactionID == null) throw new Error(\"reactionID is null\");\n        if (reactionID != null) {\n            console.log(\"id=\" + reactionID);\n            // Load reactants.\n            let reactants = new Map([]);\n            let xml_reactants = xml_reactions[i].getElementsByTagName(\"reactant\");\n            //console.log(\"xml_reactants.length=\" + xml_reactants.length);\n            for(let j = 0; j < xml_reactants.length; j++){\n                let xml_molecule = (0, $2772ddfff48d4e5b$export$91e73a91db22e6a2)(xml_reactants[j], \"molecule\");\n                let moleculeID = (0, $2772ddfff48d4e5b$export$735ee1799fd02602)(xml_molecule, \"ref\");\n                reactants.set(moleculeID, new (0, $8f7fe2903675adfb$export$dcfd4302d04b7fb6)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_molecule), (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)($850cc5ea4a4ae46d$var$molecules, moleculeID)));\n            }\n            // Load products.\n            let products = new Map([]);\n            let xml_products = xml_reactions[i].getElementsByTagName(\"product\");\n            //console.log(\"xml_products.length=\" + xml_products.length);\n            for(let j = 0; j < xml_products.length; j++){\n                let xml_molecule = (0, $2772ddfff48d4e5b$export$91e73a91db22e6a2)(xml_products[j], \"molecule\");\n                let moleculeID = (0, $2772ddfff48d4e5b$export$735ee1799fd02602)(xml_molecule, \"ref\");\n                products.set(moleculeID, new (0, $8f7fe2903675adfb$export$264ad599d7cef668)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_molecule), (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)($850cc5ea4a4ae46d$var$molecules, moleculeID)));\n            }\n            // Load MCRCMethod.\n            //console.log(\"Load MCRCMethod...\");\n            let mCRCMethod;\n            let xml_MCRCMethod = xml_reactions[i].getElementsByTagName(\"me:MCRCMethod\");\n            //console.log(\"xml_MCRCMethod=\" + xml_MCRCMethod);\n            //console.log(\"xml_MCRCMethod.length=\" + xml_MCRCMethod.length);\n            if (xml_MCRCMethod.length > 0) {\n                let attributes = (0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_MCRCMethod[0]);\n                let name = attributes.get(\"name\");\n                if (name == null) {\n                    let type = attributes.get(\"xsi:type\");\n                    if (type != null) {\n                        if (type === \"me:MesmerILT\") {\n                            let preExponential;\n                            let xml_preExponential = xml_MCRCMethod[0].getElementsByTagName(\"me:preExponential\");\n                            if (xml_preExponential != null) {\n                                if (xml_preExponential[0] != null) {\n                                    let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_preExponential[0])));\n                                    preExponential = new (0, $8f7fe2903675adfb$export$38ce90ac8b004d85)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_preExponential[0]), value);\n                                }\n                            }\n                            let activationEnergy;\n                            let xml_activationEnergy = xml_MCRCMethod[0].getElementsByTagName(\"me:activationEnergy\");\n                            if (xml_activationEnergy != null) {\n                                if (xml_activationEnergy[0] != null) {\n                                    let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_activationEnergy[0])));\n                                    activationEnergy = new (0, $8f7fe2903675adfb$export$1bdc69d2439d749d)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_activationEnergy[0]), value);\n                                }\n                            }\n                            let tInfinity;\n                            let xml_tInfinity = xml_MCRCMethod[0].getElementsByTagName(\"me:TInfinity\");\n                            if (xml_tInfinity != null) {\n                                if (xml_tInfinity[0] != null) {\n                                    let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_tInfinity[0])));\n                                    tInfinity = new (0, $8f7fe2903675adfb$export$d08982dd841d496f)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_tInfinity[0]), value);\n                                }\n                            }\n                            let nInfinity;\n                            let xml_nInfinity = xml_MCRCMethod[0].getElementsByTagName(\"me:nInfinity\");\n                            if (xml_nInfinity != null) {\n                                if (xml_nInfinity[0] != null) {\n                                    let value = parseFloat((0, $2772ddfff48d4e5b$export$13cb40e9b656ab9e)((0, $2772ddfff48d4e5b$export$4e07613bf412feb7)(xml_nInfinity[0])));\n                                    nInfinity = new (0, $8f7fe2903675adfb$export$d08982dd841d496f)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_nInfinity[0]), value);\n                                }\n                            }\n                            mCRCMethod = new (0, $8f7fe2903675adfb$export$191e95ebb11cc88)(attributes, preExponential, activationEnergy, tInfinity, nInfinity);\n                        }\n                    }\n                } else mCRCMethod = new (0, $8f7fe2903675adfb$export$6fa70ee10f356b6)(attributes, name);\n            }\n            // Load transition state.\n            //console.log(\"Load  transition state...\");\n            let xml_transitionState = xml_reactions[i].getElementsByTagName(\"me:transitionState\");\n            let transitionState;\n            if (xml_transitionState.length > 0) {\n                let xml_molecule = xml_transitionState[0].getElementsByTagName(\"molecule\")[0];\n                let moleculeID = xml_molecule.getAttribute(\"ref\");\n                transitionState = new (0, $8f7fe2903675adfb$export$145c1ed87b1a2216)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_molecule), (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)($850cc5ea4a4ae46d$var$molecules, moleculeID));\n            //console.log(\"transitionState moleculeID=\" + transitionState.molecule.getID());\n            //console.log(\"transitionState role=\" + transitionState.attributes.get(\"role\"));\n            }\n            // Load tunneling.\n            let xml_tunneling = xml_reactions[i].getElementsByTagName(\"me:tunneling\");\n            let tunneling;\n            if (xml_tunneling.length > 0) tunneling = new (0, $8f7fe2903675adfb$export$c3cf6f96dac11421)((0, $2772ddfff48d4e5b$export$fe94072fee8a6976)(xml_tunneling[0]));\n            let reaction = new (0, $8f7fe2903675adfb$export$d2ae4167a30cf6bb)(attributes, reactionID, reactants, products, mCRCMethod, transitionState, tunneling);\n            $850cc5ea4a4ae46d$var$reactions.set(reactionID, reaction);\n        //console.log(\"reaction=\" + reaction);\n        }\n    }\n}\n/**\n * Create a diagram.\n * @param {Map<string, Molecule>} molecules The molecules.\n * @param {Map<string, Reaction>} reactions The reactions.\n * @param {boolean} dark True for dark mode.\n * @returns {HTMLCanvasElement} The diagram.\n * @param {string} font The font to use.\n * @param {number} lw The line width of reactants, transition states and products.\n * @param {string} lwc The line width color to use.\n */ function $850cc5ea4a4ae46d$var$drawReactionDiagram(canvas, molecules, reactions, dark, font, lw, lwc) {\n    console.log(\"drawReactionDiagram\");\n    // TODO: Set styles depending on dark/light mode settings of users browser and not hard code.\n    //let white = \"white\";\n    let black = \"black\";\n    let green = \"green\";\n    let red = \"red\";\n    let blue = \"blue\";\n    //let yellow = \"yellow\";\n    let orange = \"orange\";\n    let background = \"black\";\n    let foreground = \"white\";\n    const ctx = canvas.getContext(\"2d\");\n    //ctx.fillStyle = background;\n    // Get text height for font size.\n    let th = (0, $3342a40c3ce9ada4$export$c398604a09be5382)(ctx, \"Aj\", font);\n    //console.log(\"th=\" + th);\n    // Go through reactions:\n    // 1. Create sets of reactants, end products, intermediate products and transition states.\n    // 2. Create maps of orders and energies.\n    // 3. Calculate maximum energy.\n    let reactants = new Set();\n    let products = new Set();\n    let intProducts = new Set();\n    let transitionStates = new Set();\n    let orders = new Map();\n    let energies = new Map();\n    let i = 0;\n    let energyMin = Number.MAX_VALUE;\n    let energyMax = Number.MIN_VALUE;\n    reactions.forEach(function(reaction, id) {\n        // Get TransitionState if there is one.\n        let transitionState = reaction.transitionState;\n        //console.log(\"reactant=\" + reactant);\n        let reactantsLabel = reaction.getReactantsLabel();\n        reactants.add(reactantsLabel);\n        if (products.has(reactantsLabel)) intProducts.add(reactantsLabel);\n        let energy = reaction.getReactantsEnergy();\n        energyMin = Math.min(energyMin, energy);\n        energyMax = Math.max(energyMax, energy);\n        energies.set(reactantsLabel, energy);\n        let productsLabel = reaction.getProductsLabel();\n        products.add(productsLabel);\n        energy = reaction.getProductsEnergy();\n        energyMin = Math.min(energyMin, energy);\n        energyMax = Math.max(energyMax, energy);\n        energies.set(productsLabel, energy);\n        if (!orders.has(reactantsLabel)) {\n            orders.set(reactantsLabel, i);\n            i++;\n        }\n        if (orders.has(productsLabel)) {\n            i--;\n            let j = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(orders, productsLabel);\n            // Move product to end and shift everything back.\n            orders.forEach(function(value, key) {\n                if (value > j) orders.set(key, value - 1);\n            });\n            // Insert transition state.\n            if (transitionState != undefined) {\n                let tsn = transitionState.getRef();\n                transitionStates.add(tsn);\n                orders.set(tsn, i);\n                energy = transitionState.molecule.getEnergy();\n                energyMin = Math.min(energyMin, energy);\n                energyMax = Math.max(energyMax, energy);\n                energies.set(tsn, energy);\n                i++;\n            }\n            orders.set(productsLabel, i);\n            i++;\n        } else {\n            if (transitionState != undefined) {\n                let tsn = transitionState.getRef();\n                transitionStates.add(tsn);\n                orders.set(tsn, i);\n                energy = transitionState.molecule.getEnergy();\n                energyMin = Math.min(energyMin, energy);\n                energyMax = Math.max(energyMax, energy);\n                energies.set(tsn, energy);\n                i++;\n            }\n            orders.set(productsLabel, i);\n            i++;\n        }\n    });\n    //console.log(\"orders=\" + mapToString(orders));\n    //console.log(\"energies=\" + mapToString(energies));\n    //console.log(\"energyMax=\" + energyMax);\n    //console.log(\"energyMin=\" + energyMin);\n    let energyRange = energyMax - energyMin;\n    //console.log(\"energyRange=\" + energyRange);\n    //console.log(\"reactants=\" + reactants);\n    //console.log(\"products=\" + products);\n    //console.log(\"transitionStates=\" + transitionStates);\n    // Create a lookup from order to label.\n    let reorders = [];\n    orders.forEach(function(value, key) {\n        reorders[value] = key;\n    });\n    //console.log(\"reorders=\" + arrayToString(reorders));\n    // Iterate through the reorders:\n    // 1. Capture coordinates for connecting lines.\n    // 2. Store maximum x.\n    let x0 = 0;\n    let y0;\n    let x1;\n    let y1;\n    let xmax = 0;\n    let tw;\n    let textSpacing = 5; // Spacing between end of line and start of text.\n    let stepSpacing = 10; // Spacing between steps.\n    let reactantsInXY = new Map();\n    let reactantsOutXY = new Map();\n    let productsInXY = new Map();\n    let productsOutXY = new Map();\n    let transitionStatesInXY = new Map();\n    let transitionStatesOutXY = new Map();\n    reorders.forEach(function(value) {\n        //console.log(\"value=\" + value + \".\");\n        //console.log(\"energies=\" + mapToString(energies));\n        let energy = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(energies, value);\n        let energyRescaled = (0, $5a4e4b2707638a1c$export$bd2782c820638828)(energyMin, energyRange, 0, canvas.height, energy);\n        // Get text width.\n        tw = Math.max((0, $3342a40c3ce9ada4$export$37827d046293d309)(ctx, energy.toString(), font), (0, $3342a40c3ce9ada4$export$37827d046293d309)(ctx, value, font));\n        x1 = x0 + tw + textSpacing;\n        y0 = energyRescaled + lw;\n        y1 = y0;\n        // Draw horizontal line and add label.\n        // (The drawing is now not done here but done later so labels are on top of lines.)\n        // The code is left here commented out for reference.\n        //drawLevel(ctx, green, 4, x0, y0, x1, y1, th, value);\n        reactantsInXY.set(value, [\n            x0,\n            y0\n        ]);\n        reactantsOutXY.set(value, [\n            x1,\n            y1\n        ]);\n        if (products.has(value)) {\n            productsInXY.set(value, [\n                x0,\n                y0\n            ]);\n            productsOutXY.set(value, [\n                x1,\n                y1\n            ]);\n        }\n        if (transitionStates.has(value)) {\n            transitionStatesInXY.set(value, [\n                x0,\n                y0\n            ]);\n            transitionStatesOutXY.set(value, [\n                x1,\n                y1\n            ]);\n        }\n        x0 = x1 + stepSpacing;\n        xmax = x1;\n    });\n    // Set canvas width to maximum x.\n    canvas.width = xmax;\n    //console.log(\"canvas.width=\" + canvas.width);\n    // Set canvas height to maximum energy plus the label.\n    let canvasHeightWithBorder = canvas.height + 4 * th + 2 * lw;\n    //console.log(\"canvasHeightWithBorder=\" + canvasHeightWithBorder);\n    let originalCanvasHeight = canvas.height;\n    // Update the canvas height.\n    canvas.height = canvasHeightWithBorder;\n    // Set the transformation matrix.\n    //ctx.transform(1, 0, 0, 1, 0, canvasHeightWithBorder);\n    ctx.transform(1, 0, 0, -1, 0, canvasHeightWithBorder);\n    // Go through reactions and draw connecting lines.\n    reactions.forEach(function(reaction, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"reaction=\" + reaction);\n        // Get TransitionState if there is one.\n        let transitionState = reaction.transitionState;\n        //console.log(\"reactant=\" + reactant);\n        let reactantsLabel = reaction.getReactantsLabel();\n        let productsLabel = reaction.getProductsLabel();\n        let reactantOutXY = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(reactantsOutXY, reactantsLabel);\n        let productInXY = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(productsInXY, productsLabel);\n        if (transitionState != undefined) {\n            let transitionStateLabel = transitionState.getRef();\n            let transitionStateInXY = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(transitionStatesInXY, transitionStateLabel);\n            (0, $3342a40c3ce9ada4$export$819db45aec5fcbe5)(ctx, black, lwc, reactantOutXY[0], reactantOutXY[1], transitionStateInXY[0], transitionStateInXY[1]);\n            let transitionStateOutXY = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(transitionStatesOutXY, transitionStateLabel);\n            (0, $3342a40c3ce9ada4$export$819db45aec5fcbe5)(ctx, black, lwc, transitionStateOutXY[0], transitionStateOutXY[1], productInXY[0], productInXY[1]);\n        } else (0, $3342a40c3ce9ada4$export$819db45aec5fcbe5)(ctx, black, lwc, reactantOutXY[0], reactantOutXY[1], productInXY[0], productInXY[1]);\n    });\n    // Draw horizontal lines and labels.\n    // (This is done last so that the labels are on top of the vertical lines.)\n    reactants.forEach(function(value) {\n        let energy = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(energies, value);\n        let energyRescaled = (0, $5a4e4b2707638a1c$export$bd2782c820638828)(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0 = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(reactantsInXY, value)[0];\n        let y = energyRescaled + lw;\n        let x1 = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(reactantsOutXY, value)[0];\n        let energyString = energy.toString();\n        (0, $3342a40c3ce9ada4$export$479ac392a7fb4419)(ctx, blue, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n    products.forEach(function(value) {\n        let energy = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(energies, value);\n        let energyRescaled = (0, $5a4e4b2707638a1c$export$bd2782c820638828)(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0 = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(productsInXY, value)[0];\n        let y = energyRescaled + lw;\n        let x1 = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(productsOutXY, value)[0];\n        let energyString = energy.toString();\n        if (intProducts.has(value)) (0, $3342a40c3ce9ada4$export$479ac392a7fb4419)(ctx, orange, lw, x0, y, x1, y, font, th, value, energyString);\n        else (0, $3342a40c3ce9ada4$export$479ac392a7fb4419)(ctx, green, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n    transitionStates.forEach(function(value) {\n        let v;\n        let energy = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(energies, value);\n        let energyRescaled = (0, $5a4e4b2707638a1c$export$bd2782c820638828)(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0 = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(transitionStatesInXY, value)[0];\n        let y = energyRescaled + lw;\n        let x1 = (0, $5a4e4b2707638a1c$export$3988ae62b71be9a3)(transitionStatesOutXY, value)[0];\n        let energyString = energy.toString();\n        (0, $3342a40c3ce9ada4$export$479ac392a7fb4419)(ctx, red, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n}\n/**\n * Display molecules table.\n */ function $850cc5ea4a4ae46d$var$displayMoleculesTable() {\n    if ($850cc5ea4a4ae46d$var$molecules.size == 0) return;\n    // Prepare table headings.\n    let moleculesTable = (0, $b78502e6136d7337$export$3359980f21752184)([\n        \"Name\",\n        \"Energy<br>kJ/mol\",\n        \"Rotation constants<br>cm<sup>-1</sup>\",\n        \"Vibration frequencies<br>cm<sup>-1</sup>\"\n    ]);\n    $850cc5ea4a4ae46d$var$molecules.forEach(function(molecule, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"molecule=\" + molecule);\n        let energyNumber = molecule.getEnergy();\n        let energy;\n        if (energyNumber == null) energy = \"\";\n        else energy = energyNumber.toString();\n        //console.log(\"energy=\" + energy);\n        let rotationConstants = \"\";\n        let rotConsts = molecule.getRotationConstants();\n        if (rotConsts != undefined) rotationConstants = (0, $be2031a98996b20c$export$4323cc4280d5be7)(rotConsts, \" \");\n        let vibrationFrequencies = \"\";\n        let vibFreqs = molecule.getVibrationFrequencies();\n        if (vibFreqs != undefined) vibrationFrequencies = (0, $be2031a98996b20c$export$4323cc4280d5be7)(vibFreqs, \" \");\n        moleculesTable += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(id) + (0, $b78502e6136d7337$export$983f4376b55e6517)((0, $b78502e6136d7337$export$7c112ceec8941e67)(\"number\", id + \"_energy\", \"setEnergy(this)\", energy)) + (0, $b78502e6136d7337$export$983f4376b55e6517)(rotationConstants, true) + (0, $b78502e6136d7337$export$983f4376b55e6517)(vibrationFrequencies, true));\n    });\n    $850cc5ea4a4ae46d$var$molecules_table = document.getElementById(\"molecules_table\");\n    if ($850cc5ea4a4ae46d$var$molecules_table !== null) $850cc5ea4a4ae46d$var$molecules_table.innerHTML = moleculesTable;\n}\n/**\n * Display reactions table.\n */ function $850cc5ea4a4ae46d$var$displayReactionsTable() {\n    if ($850cc5ea4a4ae46d$var$reactions.size == 0) return;\n    // Prepare table headings.\n    let reactionsTable = (0, $b78502e6136d7337$export$3359980f21752184)([\n        \"ID\",\n        \"Reactants\",\n        \"Products\",\n        \"Transition State\",\n        \"PreExponential\",\n        \"Activation Energy\",\n        \"TInfinity\",\n        \"NInfinity\"\n    ]);\n    $850cc5ea4a4ae46d$var$reactions.forEach(function(reaction, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"reaction=\" + reaction);\n        let reactants = (0, $be2031a98996b20c$export$4323cc4280d5be7)(Array.from(reaction.reactants.keys()), \" \");\n        let products = (0, $be2031a98996b20c$export$4323cc4280d5be7)(Array.from(reaction.products.keys()), \" \");\n        let transitionState = \"\";\n        let preExponential = \"\";\n        let activationEnergy = \"\";\n        let tInfinity = \"\";\n        let nInfinity = \"\";\n        if (reaction.transitionState != undefined) {\n            let name = reaction.transitionState.attributes.get(\"name\");\n            if (name != null) transitionState = name;\n        }\n        if (reaction.mCRCMethod != undefined) {\n            if (reaction.mCRCMethod instanceof (0, $8f7fe2903675adfb$export$191e95ebb11cc88)) {\n                if (reaction.mCRCMethod.preExponential != null) preExponential = reaction.mCRCMethod.preExponential.value.toString() + \" \" + reaction.mCRCMethod.preExponential.attributes.get(\"units\");\n                if (reaction.mCRCMethod.activationEnergy != null) activationEnergy = reaction.mCRCMethod.activationEnergy.value.toString() + \" \" + reaction.mCRCMethod.activationEnergy.attributes.get(\"units\");\n                if (reaction.mCRCMethod.tInfinity != null) tInfinity = reaction.mCRCMethod.tInfinity.toString();\n                if (reaction.mCRCMethod.nInfinity != null) nInfinity = reaction.mCRCMethod.nInfinity.value.toString();\n            } else {\n                if (reaction.mCRCMethod.attributes.get(\"name\") == \"RRKM\") ;\n                else throw new Error(\"Unexpected mCRCMethod: \" + reaction.mCRCMethod);\n            }\n        }\n        reactionsTable += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(id) + (0, $b78502e6136d7337$export$983f4376b55e6517)(reactants) + (0, $b78502e6136d7337$export$983f4376b55e6517)(products) + (0, $b78502e6136d7337$export$983f4376b55e6517)(transitionState) + (0, $b78502e6136d7337$export$983f4376b55e6517)(preExponential, true) + (0, $b78502e6136d7337$export$983f4376b55e6517)(activationEnergy, true) + (0, $b78502e6136d7337$export$983f4376b55e6517)(tInfinity, true) + (0, $b78502e6136d7337$export$983f4376b55e6517)(nInfinity, true));\n        $850cc5ea4a4ae46d$var$reactions_table = document.getElementById(\"reactions_table\");\n        if ($850cc5ea4a4ae46d$var$reactions_table !== null) $850cc5ea4a4ae46d$var$reactions_table.innerHTML = reactionsTable;\n    });\n}\n/**\n * Display reactions diagram.\n */ function $850cc5ea4a4ae46d$var$displayReactionsDiagram() {\n    if ($850cc5ea4a4ae46d$var$reactions.size > 1) {\n        // Set reactions_diagram_title.\n        $850cc5ea4a4ae46d$var$reactions_diagram_title = document.getElementById(\"reactions_diagram_title\");\n        if ($850cc5ea4a4ae46d$var$reactions_diagram_title != null) $850cc5ea4a4ae46d$var$reactions_diagram_title.innerHTML = \"Diagram\";\n        // Display the diagram.\n        let canvas = document.getElementById(\"reactions_diagram\");\n        let font = \"14px Arial\";\n        let dark = true;\n        let lw = 4;\n        let lwc = 2;\n        if (canvas != null) {\n            canvas.style.display = \"block\";\n            $850cc5ea4a4ae46d$var$drawReactionDiagram(canvas, $850cc5ea4a4ae46d$var$molecules, $850cc5ea4a4ae46d$var$reactions, dark, font, lw, lwc);\n        }\n    }\n}\n/**\n * Display conditions.\n */ function $850cc5ea4a4ae46d$var$displayConditions() {\n    let bathGas_element = document.getElementById(\"bathGas\");\n    if (bathGas_element != null) bathGas_element.innerHTML = \"Bath Gas \" + $850cc5ea4a4ae46d$var$conditions.bathGas.molecule.getID();\n    let PTs_element = document.getElementById(\"PT_table\");\n    let table = (0, $b78502e6136d7337$export$3359980f21752184)([\n        \"P\",\n        \"T\"\n    ]);\n    if (PTs_element != null) {\n        $850cc5ea4a4ae46d$var$conditions.pTs.forEach(function(pTpair) {\n            table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(pTpair.P.toString()) + (0, $b78502e6136d7337$export$983f4376b55e6517)(pTpair.T.toString()));\n        });\n        PTs_element.innerHTML = table;\n    }\n}\n/**\n * Display modelParameters.\n */ function $850cc5ea4a4ae46d$var$displayModelParameters() {\n    let modelParameters_element = document.getElementById(\"modelParameters_table\");\n    let table = (0, $b78502e6136d7337$export$3359980f21752184)([\n        \"Parameter\",\n        \"Value\"\n    ]);\n    table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"Grain Size\") + (0, $b78502e6136d7337$export$983f4376b55e6517)($850cc5ea4a4ae46d$var$modelParameters.grainSize.value.toString()));\n    table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"Energy Above The Top Hill\") + (0, $b78502e6136d7337$export$983f4376b55e6517)($850cc5ea4a4ae46d$var$modelParameters.energyAboveTheTopHill.toString()));\n    if (modelParameters_element != null) modelParameters_element.innerHTML = table;\n}\n/**\n * Display control.\n */ function $850cc5ea4a4ae46d$var$displayControl() {\n    let control_table_element = document.getElementById(\"control_table\");\n    let table = (0, $b78502e6136d7337$export$3359980f21752184)([\n        \"Control\",\n        \"Value\"\n    ]);\n    if ($850cc5ea4a4ae46d$var$control.testDOS != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.testDOS\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printSpeciesProfile != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printSpeciesProfile\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.testMicroRates != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.testMicroRates\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.testRateConstant != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.testRateConstant\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printGrainDOS != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printGrainDOS\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printCellDOS != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printCellDOS\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printReactionOperatorColumnSums != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printReactionOperatorColumnSums\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printTunnellingCoefficients != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printTunnellingCoefficients\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printGrainkfE != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printGrainkfE\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printGrainBoltzmann != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printGrainBoltzmann\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.printGrainkbE != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.printGrainkbE\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.eigenvalues != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.eigenvalues\") + (0, $b78502e6136d7337$export$983f4376b55e6517)($850cc5ea4a4ae46d$var$control.eigenvalues.toString()));\n    if ($850cc5ea4a4ae46d$var$control.hideInactive != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.hideInactive\") + (0, $b78502e6136d7337$export$983f4376b55e6517)(\"\"));\n    if ($850cc5ea4a4ae46d$var$control.diagramEnergyOffset != undefined) table += (0, $b78502e6136d7337$export$b5ad96d32b19f99)((0, $b78502e6136d7337$export$983f4376b55e6517)(\"me.diagramEnergyOffset\") + (0, $b78502e6136d7337$export$983f4376b55e6517)($850cc5ea4a4ae46d$var$control.diagramEnergyOffset.value.toString()));\n    if (control_table_element != null) control_table_element.innerHTML = table;\n}\nfunction $850cc5ea4a4ae46d$export$afc96e5ea6df45fd(input) {\n    let id_energy = input.id;\n    let moleculeID = id_energy.split(\"_\")[0];\n    let molecule = $850cc5ea4a4ae46d$var$molecules.get(moleculeID);\n    if (molecule != undefined) {\n        let inputValue = parseFloat(input.value);\n        if (!isNaN(inputValue)) {\n            molecule.setEnergy(inputValue);\n            console.log(\"Energy of \" + moleculeID + \" set to \" + inputValue);\n        } else {\n            alert(\"Energy input for \" + moleculeID + \" is not a number\");\n            let inputElement = document.getElementById(id_energy);\n            inputElement.value = molecule.getEnergy().toString();\n        }\n    //console.log(\"molecule=\" + molecule);\n    }\n}\nwindow.setEnergy = $850cc5ea4a4ae46d$export$afc96e5ea6df45fd;\n/**\n * Save to XML file.\n */ window.saveXML = function() {\n    console.log(\"saveXML\");\n    const pad = \"  \";\n    let level;\n    const padding2 = pad.repeat(2);\n    // Create me.title.\n    let title_xml = \"\\n\" + pad + (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)($850cc5ea4a4ae46d$var$title, \"me:title\");\n    // Create moleculeList.\n    level = 2;\n    let moleculeList = \"\";\n    $850cc5ea4a4ae46d$var$molecules.forEach(function(molecule, id) {\n        moleculeList += molecule.toXML(\"molecule\", pad, level);\n    });\n    moleculeList = (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(moleculeList, \"moleculeList\", undefined, undefined, undefined, pad, true);\n    // Create reactionList.\n    level = 2;\n    let reactionList = \"\";\n    $850cc5ea4a4ae46d$var$reactions.forEach(function(reaction, id) {\n        reactionList += reaction.toXML(\"reaction\", pad, level);\n    });\n    reactionList = (0, $2772ddfff48d4e5b$export$dad497fe1f6e27c0)(reactionList, \"reactionList\", undefined, undefined, undefined, pad, true);\n    // Create me.Conditions\n    let xml_conditions = $850cc5ea4a4ae46d$var$conditions.toXML(pad, pad);\n    // Create modelParameters\n    let xml_modelParameters = $850cc5ea4a4ae46d$var$modelParameters.toXML(pad, pad);\n    // create me.control\n    let xml_control = $850cc5ea4a4ae46d$var$control.toXML(pad, pad);\n    // Create a new Blob object from the data\n    let blob = new Blob([\n        $850cc5ea4a4ae46d$var$header,\n        $850cc5ea4a4ae46d$var$mesmerStartTag,\n        title_xml,\n        moleculeList,\n        reactionList,\n        xml_conditions,\n        xml_modelParameters,\n        xml_control,\n        $850cc5ea4a4ae46d$var$mesmerEndTag\n    ], {\n        type: \"text/plain\"\n    });\n    // Create a new object URL for the blob\n    let url = URL.createObjectURL(blob);\n    // Create a new 'a' element\n    let a = document.createElement(\"a\");\n    // Set the href and download attributes for the 'a' element\n    a.href = url;\n    a.download = $850cc5ea4a4ae46d$var$input_xml_filename; // Replace with your desired filename\n    // Append the 'a' element to the body and click it to start the download\n    document.body.appendChild(a);\n    a.click();\n    // Remove the 'a' element after the download starts\n    document.body.removeChild(a);\n};\n\n\n//# sourceMappingURL=GUI.24c233e8.js.map\n","import { get, rescale } from './util.js';\nimport { getAttribute, getFirstElement, getFirstChildNode, getNodeValue, getTag, getEndTag, getAttributes, toHTML, getSingularElement } from './xml.js';\nimport { Molecule, Atom, Bond, EnergyTransferModel, DeltaEDown, DOSCMethod, Property } from './molecule.js';\nimport { Reaction, TransitionState, Reactant, Product, MCRCMethod, MesmerILT, PreExponential, ActivationEnergy, NInfinity, Tunneling } from './reaction.js';\nimport { arrayToString, toNumberArray, isNumeric } from './functions.js';\nimport { getTD, getTH, getTR, getInput } from './html.js';\nimport { drawLevel, drawLine, getTextHeight, getTextWidth } from './canvas.js';\nimport { NumberArrayWithAttributes, NumberWithAttributes } from './classes.js';\nimport { BathGas, Conditions, PTpair } from './conditions.js';\nimport { GrainSize, ModelParameters } from './modelParameters.js';\nimport { Control, DiagramEnergyOffset } from './control.js';\n// Code for service worker for Progressive Web App (PWA).\nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', function () {\n        const swUrl = new URL('../../../sw.js', import.meta.url);\n        //const swUrl = new URL('../../../sw.js', document.baseURI);\n        navigator.serviceWorker.register(swUrl);\n    });\n}\n// Expected XML tags strings.\nlet me_title_s = 'me:title';\n/**\n * For storing me.title.\n */\nlet title;\n/**\n * For storing the XML root start tag.\n */\nlet mesmerStartTag;\n/**\n * For storing the XML root end tag.\n */\nlet mesmerEndTag;\n/**\n * A map of molecules with Molecule.id as key and Molecules as values.\n */\nlet molecules = new Map([]);\n/**\n * For storing the maximum molecule energy in a reaction.\n */\nlet maxMoleculeEnergy = -Infinity;\n/**\n * For storing the minimum molecule energy in a reaction.\n */\nlet minMoleculeEnergy = Infinity;\n/**\n * A map of reactions with Reaction.id as keys and Reactions as values.\n */\nlet reactions = new Map([]);\n/**\n * The header of the XML file.\n */\nconst header = `<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<?xml-stylesheet type='text/xsl' href='../../mesmer2.xsl' media='other'?>\n<?xml-stylesheet type='text/xsl' href='../../mesmer1.xsl' media='screen'?>`;\n/**\n * The filename of the mesmer input file loaded.\n */\nlet input_xml_filename;\n/**\n * The load button.\n */\nlet loadButton;\n/**\n * The save button.\n */\nlet saveButton;\n/**\n * The XML text element.\n */\nlet me_title;\nlet molecules_title;\nlet molecules_table;\nlet reactions_title;\nlet reactions_table;\nlet reactions_diagram_title;\nlet conditions_title;\nlet conditions_table;\nlet modelParameters_title;\nlet modelParameters_table;\nlet xml_title;\nlet xml_text;\n/**\n * Display the XML.\n * @param {string} xml The XML to display.\n */\nfunction displayXML(xml) {\n    //console.log(\"xml=\" + xml);\n    if (xml_title != null) {\n        xml_title.innerHTML = input_xml_filename;\n    }\n    if (xml_text != null) {\n        xml_text.innerHTML = toHTML(xml);\n    }\n}\n/**\n * Parses xml to initilise molecules.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initMolecules(xml) {\n    let moleculeList_s = 'moleculeList';\n    console.log(moleculeList_s);\n    let xml_moleculeList = getSingularElement(xml, moleculeList_s);\n    // Set molecules_title.\n    molecules_title = document.getElementById(\"molecules_title\");\n    if (molecules_title != null) {\n        molecules_title.innerHTML = \"Molecules\";\n    }\n    // xml_moleculeList should have one or more molecule elements and no other elements.\n    let moleculeListTagNames = new Set();\n    xml_moleculeList.childNodes.forEach(function (node) {\n        moleculeListTagNames.add(node.nodeName);\n    });\n    if (moleculeListTagNames.size != 1) {\n        if (!(moleculeListTagNames.size == 2 && moleculeListTagNames.has(\"#text\"))) {\n            console.error(\"moleculeListTagNames:\");\n            moleculeListTagNames.forEach(x => console.error(x));\n            throw new Error(\"Additional tag names in moleculeList:\");\n        }\n    }\n    if (!moleculeListTagNames.has(\"molecule\")) {\n        throw new Error(\"Expecting molecule tagName but it is not present!\");\n    }\n    let xml_molecules = xml_moleculeList.getElementsByTagName('molecule');\n    let xml_molecules_length = xml_molecules.length;\n    console.log(\"Number of molecules=\" + xml_molecules_length);\n    // Process each molecule.\n    //xml_molecules.forEach(function (xml_molecule) { // Cannot iterate over HTMLCollectionOf like this.\n    for (let i = 0; i < xml_molecules.length; i++) {\n        // Set attributes.\n        let attributes = getAttributes(xml_molecules[i]);\n        let moleculeTagNames = new Set();\n        let cns = xml_molecules[i].childNodes;\n        cns.forEach(function (node) {\n            moleculeTagNames.add(node.nodeName);\n        });\n        //console.log(\"moleculeTagNames:\");\n        //moleculeTagNames.forEach(x => console.log(x));\n        // Set atoms.\n        const atoms = new Map();\n        // Sometimes there is an individual atom not in an atomArray.\n        //let xml_atomArray = xml_molecules[i].getElementsByTagName(\"atomArray\")[0];\n        //if (xml_atomArray != null) {\n        moleculeTagNames.delete(\"atom\");\n        moleculeTagNames.delete(\"atomArray\");\n        let xml_atoms = xml_molecules[i].getElementsByTagName(\"atom\");\n        for (let j = 0; j < xml_atoms.length; j++) {\n            let attribs = getAttributes(xml_atoms[j]);\n            let id = attribs.get(\"id\");\n            if (id != undefined) {\n                let atom = new Atom(attribs);\n                //console.log(atom.toString());\n                atoms.set(id, atom);\n            }\n        }\n        //}\n        // Read bondArray.\n        moleculeTagNames.delete(\"bond\");\n        moleculeTagNames.delete(\"bondArray\");\n        const bonds = new Map();\n        let xml_bonds = xml_molecules[i].getElementsByTagName(\"bond\");\n        for (let j = 0; j < xml_bonds.length; j++) {\n            let attribs = getAttributes(xml_bonds[j]);\n            let id = attribs.get(\"atomRefs2\");\n            if (id != undefined) {\n                let bond = new Bond(attribs);\n                //console.log(bond.toString());\n                bonds.set(id, bond);\n            }\n        }\n        // Read propertyList.\n        const properties = new Map();\n        // Sometimes there is a single property not in propertyList!\n        //let xml_propertyList = xml_molecules[i].getElementsByTagName(\"propertyList\")[0];\n        //if (xml_propertyList != null) {\n        //    let xml_properties = xml_propertyList.getElementsByTagName(\"property\");\n        moleculeTagNames.delete(\"property\");\n        moleculeTagNames.delete(\"propertyList\");\n        let xml_properties = xml_molecules[i].getElementsByTagName(\"property\");\n        for (let j = 0; j < xml_properties.length; j++) {\n            let attribs = getAttributes(xml_properties[j]);\n            let children = xml_properties[j].children;\n            if (children.length != 1) {\n                throw new Error(\"Expecting 1 child but finding \" + children.length);\n            }\n            let nodeAttributes = getAttributes(children[0]);\n            let nodeName = children[0].nodeName; // Expecting scalar or array\n            let textContent = children[0].textContent;\n            if (textContent == null) {\n                console.error(\"nodeName\");\n                throw new Error('textContent is null');\n            }\n            textContent = textContent.trim();\n            let dictRef = attribs.get(\"dictRef\");\n            //console.log(\"dictRef=\" + dictRef);\n            if (dictRef == null) {\n                throw new Error('dictRef is null');\n            }\n            //console.log(\"fcnn=\" + fcnn);\n            if (nodeName == \"scalar\") {\n                moleculeTagNames.delete(\"scalar\");\n                let value = parseFloat(textContent);\n                properties.set(dictRef, new Property(attribs, new NumberWithAttributes(nodeAttributes, value)));\n                if (dictRef === \"me:ZPE\") {\n                    minMoleculeEnergy = Math.min(minMoleculeEnergy, value);\n                    maxMoleculeEnergy = Math.max(maxMoleculeEnergy, value);\n                }\n            }\n            else if (nodeName == \"array\") {\n                moleculeTagNames.delete(\"array\");\n                properties.set(dictRef, new Property(attribs, new NumberArrayWithAttributes(nodeAttributes, toNumberArray(textContent.split(/\\s+/)), \" \")));\n            }\n            else if (nodeName == \"matrix\") {\n            }\n            else {\n                throw new Error(\"Unexpected nodeName: \" + nodeName);\n            }\n        }\n        let els;\n        // Read energyTransferModel\n        moleculeTagNames.delete(\"me:energyTransferModel\");\n        let energyTransferModel = undefined;\n        els = xml_molecules[i].getElementsByTagName(\"me:energyTransferModel\");\n        if (els != null) {\n            if (els.length > 0) {\n                if (els.length != 1) {\n                    throw new Error(\"energyTransferModel length=\" + els.length);\n                }\n                let xml_deltaEDown = els[0].getElementsByTagName(\"me:deltaEDown\");\n                if (xml_deltaEDown != null) {\n                    if (xml_deltaEDown.length != 1) {\n                        throw new Error(\"deltaEDown length=\" + xml_deltaEDown.length);\n                    }\n                    let value = parseFloat(getNodeValue(getFirstChildNode(xml_deltaEDown[0])));\n                    let deltaEDown = new DeltaEDown(getAttributes(xml_deltaEDown[0]), value);\n                    energyTransferModel = new EnergyTransferModel(getAttributes(els[0]), deltaEDown);\n                }\n            }\n        }\n        // Read DOSCMethod\n        moleculeTagNames.delete(\"me:DOSCMethod\");\n        let dOSCMethod = undefined;\n        els = xml_molecules[i].getElementsByTagName(\"me:DOSCMethod\");\n        if (els != null) {\n            let el = els[0];\n            if (el != null) {\n                if (el != null) {\n                    let type = el.getAttribute(\"xsi:type\");\n                    if (type != null) {\n                        dOSCMethod = new DOSCMethod(type);\n                    }\n                }\n            }\n        }\n        // Check for unexpected tags.\n        moleculeTagNames.delete(\"#text\");\n        if (moleculeTagNames.size > 0) {\n            console.error(\"Remaining moleculeTagNames:\");\n            moleculeTagNames.forEach(x => console.error(x));\n            throw new Error(\"Unexpected tags in molecule.\");\n        }\n        let molecule = new Molecule(attributes, atoms, bonds, properties, energyTransferModel, dOSCMethod);\n        //console.log(molecule.toString());\n        molecules.set(molecule.id, molecule);\n    }\n    // Add event listeners to molecules table.\n    molecules.forEach(function (molecule, id) {\n        let energyKey = id + \"_energy\";\n        let inputElement = document.getElementById(energyKey);\n        if (inputElement) {\n            inputElement.addEventListener('change', (event) => {\n                // The input is set up to call the function setEnergy(HTMLInputElement),\n                // so the following commented code is not used. As the input was setup \n                // as a number type. The any non numbers were It seems that there are two \n                // ways to get and store the value of the input element.\n                // Both ways have been kept for now as I don't know which way is better!\n                let eventTarget = event.target;\n                let inputValue = eventTarget.value;\n                if (isNumeric(inputValue)) {\n                    molecule.setEnergy(parseFloat(inputValue));\n                    console.log(\"Set energy of \" + id + \" to \" + inputValue + \" kJ/mol\");\n                }\n                else {\n                    alert(\"Energy input for \" + id + \" is not a number\");\n                    let inputElement = document.getElementById(energyKey);\n                    inputElement.value = molecule.getEnergy().toString();\n                    console.log(\"inputValue=\" + inputValue);\n                    console.log(\"Type of inputValue: \" + typeof inputValue);\n                }\n            });\n        }\n    });\n}\nlet inputElement;\nfunction reload() {\n    inputElement = document.createElement('input');\n    inputElement.type = 'file';\n    inputElement.onchange = function () {\n        if (inputElement.files) {\n            for (let i = 0; i < inputElement.files.length; i++) {\n                console.log(\"inputElement.files[\" + i + \"]=\" + inputElement.files[i]);\n            }\n            let file = inputElement.files[0];\n            //console.log(\"file=\" + file);\n            console.log(file.name);\n            input_xml_filename = file.name;\n            if (xml_text != null) {\n                let reader = new FileReader();\n                let chunkSize = 1024 * 1024; // 1MB\n                let start = 0;\n                let contents = '';\n                reader.onload = function (e) {\n                    if (!e.target) {\n                        throw new Error('Event target is null');\n                    }\n                    contents += e.target.result;\n                    if (file != null) {\n                        if (start < file.size) {\n                            // Read the next chunk\n                            let blob = file.slice(start, start + chunkSize);\n                            reader.readAsText(blob);\n                            start += chunkSize;\n                        }\n                        else {\n                            // All chunks have been read\n                            contents = contents.trim();\n                            displayXML(contents);\n                            let parser = new DOMParser();\n                            let xml = parser.parseFromString(contents, \"text/xml\");\n                            parse(xml);\n                            // Send XML to the server\n                            fetch('http://localhost:1234/', {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'text/xml',\n                                },\n                                body: contents,\n                            })\n                                .then(response => {\n                                if (!response.ok) {\n                                    throw new Error(`HTTP error! status: ${response.status}`);\n                                }\n                                return response.text();\n                            })\n                                .then(data => {\n                                console.log('Server response:', data);\n                            })\n                                .catch(error => {\n                                console.error('There was a problem with the fetch operation:', error);\n                            });\n                        }\n                    }\n                };\n                // Read the first chunk\n                let blob = file.slice(start, start + chunkSize);\n                reader.readAsText(blob);\n                start += chunkSize;\n            }\n        }\n    };\n    inputElement.click();\n    // Add event listener to load button.\n    loadButton = document.getElementById('load_button');\n    if (loadButton != null) {\n        loadButton.addEventListener('click', reload);\n    }\n    // Ensure save button is displayed.\n    saveButton = document.getElementById('saveButton');\n    if (saveButton != null) {\n        saveButton.style.display = 'inline';\n    }\n}\n/**\n * Once the DOM is loaded, set up the elements.\n */\ndocument.addEventListener('DOMContentLoaded', (event) => {\n    // Initialise elements\n    xml_title = document.getElementById(\"xml_title\");\n    xml_text = document.getElementById(\"xml_text\");\n    window.loadXML = function () {\n        reload();\n    };\n});\n/**\n * Set the title.\n * @param {XMLDocument} xml The XML document.\n */\nfunction setTitle(xml) {\n    me_title = xml.getElementsByTagName(me_title_s);\n    if (me_title == null) {\n        throw new Error(me_title_s + ' not found');\n    }\n    else {\n        if (me_title.length != 1) {\n            throw new Error('Multiple ' + me_title_s + ' elements found');\n        }\n        else {\n            title = me_title[0].childNodes[0].nodeValue;\n            title = title.trim();\n            console.log(\"Title=\" + title);\n            let e = document.getElementById(\"title\");\n            if (e != null) {\n                e.innerHTML = title;\n            }\n        }\n    }\n}\n/**\n * Parse the XML.\n * @param {XMLDocument} xml\n */\nfunction parse(xml) {\n    /**\n     * Set mesmer_xml start tag.\n     */\n    mesmerStartTag = \"\\n\";\n    let documentElement = xml.documentElement;\n    if (documentElement == null) {\n        throw new Error(\"Document element not found\");\n    }\n    else {\n        let tagName = documentElement.tagName;\n        mesmerStartTag += \"<\" + tagName;\n        console.log(tagName);\n        mesmerEndTag = getEndTag(tagName, \"\", true);\n        let first = true;\n        let pad = \" \".repeat(tagName.length + 2);\n        let names = documentElement.getAttributeNames();\n        names.forEach(function (name) {\n            let attribute = documentElement.getAttribute(name);\n            let na = `${name}=\"${attribute}\"`;\n            if (first) {\n                first = false;\n                mesmerStartTag += \" \" + na;\n            }\n            else {\n                mesmerStartTag += \"\\n\" + pad + na;\n            }\n        });\n        mesmerStartTag += \">\";\n        //console.log(mesmerStartTag);\n    }\n    /**\n     *  Set title.\n     */\n    setTitle(xml);\n    /**\n     * Generate molecules table.\n     */\n    initMolecules(xml);\n    displayMoleculesTable();\n    /**\n     * Generate reactions table.\n     */\n    initReactions(xml);\n    displayReactionsTable();\n    displayReactionsDiagram();\n    /**\n     * Generate conditions table.\n     */\n    initConditions(xml);\n    displayConditions();\n    /**\n     * Generate parameters table.\n     */\n    initModelParameters(xml);\n    displayModelParameters();\n    /**\n     * Generate control table.\n     */\n    initControl(xml);\n    displayControl();\n}\nlet conditions;\n/**\n * Parse xml to initialise conditions.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initConditions(xml) {\n    let me_conditions_s = 'me:conditions';\n    console.log(me_conditions_s);\n    let xml_conditions = getSingularElement(xml, me_conditions_s);\n    // Set conditions_title.\n    conditions_title = document.getElementById(\"conditions_title\");\n    if (conditions_title != null) {\n        conditions_title.innerHTML = \"Conditions\";\n    }\n    // BathGas\n    let xml_bathGas = getSingularElement(xml_conditions, 'me:bathGas');\n    let attributes = getAttributes(xml_bathGas);\n    let bathGas = new BathGas(attributes, get(molecules, xml_bathGas.childNodes[0].nodeValue));\n    // PTs\n    let xml_PTs = getSingularElement(xml_conditions, 'me:PTs');\n    let xml_PTPairs = xml_PTs.getElementsByTagName('me:PTpair');\n    // Process each PTpair.\n    let PTs = [];\n    for (let i = 0; i < xml_PTPairs.length; i++) {\n        PTs.push(new PTpair(getAttributes(xml_PTPairs[i])));\n    }\n    conditions = new Conditions(bathGas, PTs);\n}\nlet modelParameters;\n/**\n * Parses xml to initialise modelParameters.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initModelParameters(xml) {\n    let me_modelParameters_s = 'me:modelParameters';\n    console.log(me_modelParameters_s);\n    let xml_modelParameters = getSingularElement(xml, me_modelParameters_s);\n    // Set modelParameters_title.\n    modelParameters_title = document.getElementById(\"modelParameters_title\");\n    if (modelParameters_title != null) {\n        modelParameters_title.innerHTML = \"Model Parameters\";\n    }\n    // GrainSize\n    let xml_grainSize = getSingularElement(xml_modelParameters, 'me:grainSize');\n    let attributes = getAttributes(xml_grainSize);\n    let value = parseFloat(getNodeValue(getFirstChildNode(xml_grainSize)));\n    let grainSize = new GrainSize(attributes, value);\n    // EnergyAboveTheTopHill\n    let xml_energyAboveTheTopHill = getSingularElement(xml_modelParameters, 'me:energyAboveTheTopHill');\n    let energyAboveTheTopHill = parseFloat(getNodeValue(getFirstChildNode(xml_energyAboveTheTopHill)));\n    modelParameters = new ModelParameters(grainSize, energyAboveTheTopHill);\n}\nlet control;\n/**\n * Parses xml to initialise control.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initControl(xml) {\n    let me_control_s = 'me:control';\n    console.log(me_control_s);\n    let xml_control = getSingularElement(xml, me_control_s);\n    // Set control_title.\n    let control_title = document.getElementById(\"control_title\");\n    if (control_title != null) {\n        control_title.innerHTML = \"Control\";\n    }\n    // me:testDOS\n    let xml_testDOS = xml_control.getElementsByTagName('me:testDOS');\n    let testDOS;\n    if (xml_testDOS.length > 0) {\n        testDOS = true;\n    }\n    // me:printSpeciesProfile\n    let xml_printSpeciesProfile = xml_control.getElementsByTagName('me:printSpeciesProfile');\n    let printSpeciesProfile;\n    if (xml_printSpeciesProfile.length > 0) {\n        printSpeciesProfile = true;\n    }\n    // me:testMicroRates\n    let xml_testMicroRates = xml_control.getElementsByTagName('me:testMicroRates');\n    let testMicroRates;\n    if (xml_testMicroRates.length > 0) {\n        testMicroRates = true;\n    }\n    // me:testRateConstant\n    let xml_testRateConstant = xml_control.getElementsByTagName('me:testRateConstant');\n    let testRateConstant;\n    if (xml_testRateConstant.length > 0) {\n        testRateConstant = true;\n    }\n    // me:printGrainDOS\n    let xml_printGrainDOS = xml_control.getElementsByTagName('me:printGrainDOS');\n    let printGrainDOS;\n    if (xml_printGrainDOS.length > 0) {\n        printGrainDOS = true;\n    }\n    // me:printCellDOS\n    let xml_printCellDOS = xml_control.getElementsByTagName('me:printCellDOS');\n    let printCellDOS;\n    if (xml_printCellDOS.length > 0) {\n        printCellDOS = true;\n    }\n    // me:printReactionOperatorColumnSums\n    let xml_printReactionOperatorColumnSums = xml_control.getElementsByTagName('me:printReactionOperatorColumnSums');\n    let printReactionOperatorColumnSums;\n    if (xml_printReactionOperatorColumnSums.length > 0) {\n        printReactionOperatorColumnSums = true;\n    }\n    // me:printTunnellingCoefficients\n    let xml_printTunnellingCoefficients = xml_control.getElementsByTagName('me:printTunnellingCoefficients');\n    let printTunnellingCoefficients;\n    if (xml_printTunnellingCoefficients.length > 0) {\n        printTunnellingCoefficients = true;\n    }\n    // me:printGrainkfE\n    let xml_printGrainkfE = xml_control.getElementsByTagName('me:printGrainkfE');\n    let printGrainkfE;\n    if (xml_printGrainkfE.length > 0) {\n        printGrainkfE = true;\n    }\n    // me:printGrainBoltzmann\n    let xml_printGrainBoltzmann = xml_control.getElementsByTagName('me:printGrainBoltzmann');\n    let printGrainBoltzmann;\n    if (xml_printGrainBoltzmann.length > 0) {\n        printGrainBoltzmann = true;\n    }\n    // me:printGrainkbE\n    let xml_printGrainkbE = xml_control.getElementsByTagName('me:printGrainkbE');\n    let printGrainkbE;\n    if (xml_printGrainkbE.length > 0) {\n        printGrainkbE = true;\n    }\n    // me:eigenvalues\n    let xml_eigenvalues = xml_control.getElementsByTagName('me:eigenvalues');\n    let eigenvalues;\n    if (xml_eigenvalues.length > 0) {\n        eigenvalues = parseFloat(getNodeValue(getFirstChildNode(xml_eigenvalues[0])));\n    }\n    // me:hideInactive\n    let xml_hideInactive = xml_control.getElementsByTagName('me:hideInactive');\n    let hideInactive;\n    if (xml_hideInactive.length > 0) {\n        hideInactive = true;\n    }\n    // me:diagramEnergyOffset\n    let xml_diagramEnergyOffset = xml_control.getElementsByTagName('me:diagramEnergyOffset');\n    let diagramEnergyOffset;\n    if (xml_diagramEnergyOffset.length > 0) {\n        let value = parseFloat(getNodeValue(getFirstChildNode(xml_diagramEnergyOffset[0])));\n        diagramEnergyOffset = new DiagramEnergyOffset(getAttributes(xml_diagramEnergyOffset[0]), value);\n    }\n    control = new Control(testDOS, printSpeciesProfile, testMicroRates, testRateConstant, printGrainDOS, printCellDOS, printReactionOperatorColumnSums, printTunnellingCoefficients, printGrainkfE, printGrainBoltzmann, printGrainkbE, eigenvalues, hideInactive, diagramEnergyOffset);\n}\n/**\n * Parses xml to initialise reactions.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initReactions(xml) {\n    let reactionList_s = 'reactionList';\n    console.log(reactionList_s);\n    let xml_reactionList = getSingularElement(xml, reactionList_s);\n    let xml_reactions = xml_reactionList.getElementsByTagName('reaction');\n    let xml_reactions_length = xml_reactions.length;\n    console.log(\"Number of reactions=\" + xml_reactions_length);\n    // Process each reaction.\n    if (xml_reactions_length == 0) {\n        //return;\n        throw new Error(\"No reactions: There should be at least 1!\");\n    }\n    // Set reactions_title.\n    reactions_title = document.getElementById(\"reactions_title\");\n    if (reactions_title != null) {\n        reactions_title.innerHTML = \"Reactions\";\n    }\n    for (let i = 0; i < xml_reactions_length; i++) {\n        let attributes = getAttributes(xml_reactions[i]);\n        let reactionID = attributes.get(\"id\");\n        if (reactionID == null) {\n            throw new Error(\"reactionID is null\");\n        }\n        if (reactionID != null) {\n            console.log(\"id=\" + reactionID);\n            // Load reactants.\n            let reactants = new Map([]);\n            let xml_reactants = xml_reactions[i].getElementsByTagName('reactant');\n            //console.log(\"xml_reactants.length=\" + xml_reactants.length);\n            for (let j = 0; j < xml_reactants.length; j++) {\n                let xml_molecule = getFirstElement(xml_reactants[j], 'molecule');\n                let moleculeID = getAttribute(xml_molecule, \"ref\");\n                reactants.set(moleculeID, new Reactant(getAttributes(xml_molecule), get(molecules, moleculeID)));\n            }\n            // Load products.\n            let products = new Map([]);\n            let xml_products = xml_reactions[i].getElementsByTagName('product');\n            //console.log(\"xml_products.length=\" + xml_products.length);\n            for (let j = 0; j < xml_products.length; j++) {\n                let xml_molecule = getFirstElement(xml_products[j], 'molecule');\n                let moleculeID = getAttribute(xml_molecule, \"ref\");\n                products.set(moleculeID, new Product(getAttributes(xml_molecule), get(molecules, moleculeID)));\n            }\n            // Load MCRCMethod.\n            //console.log(\"Load MCRCMethod...\");\n            let mCRCMethod;\n            let xml_MCRCMethod = xml_reactions[i].getElementsByTagName('me:MCRCMethod');\n            //console.log(\"xml_MCRCMethod=\" + xml_MCRCMethod);\n            //console.log(\"xml_MCRCMethod.length=\" + xml_MCRCMethod.length);\n            if (xml_MCRCMethod.length > 0) {\n                let attributes = getAttributes(xml_MCRCMethod[0]);\n                let name = attributes.get(\"name\");\n                if (name == null) {\n                    let type = attributes.get(\"xsi:type\");\n                    if (type != null) {\n                        if (type === \"me:MesmerILT\") {\n                            let preExponential;\n                            let xml_preExponential = xml_MCRCMethod[0].getElementsByTagName(\"me:preExponential\");\n                            if (xml_preExponential != null) {\n                                if (xml_preExponential[0] != null) {\n                                    let value = parseFloat(getNodeValue(getFirstChildNode(xml_preExponential[0])));\n                                    preExponential = new PreExponential(getAttributes(xml_preExponential[0]), value);\n                                }\n                            }\n                            let activationEnergy;\n                            let xml_activationEnergy = xml_MCRCMethod[0].getElementsByTagName(\"me:activationEnergy\");\n                            if (xml_activationEnergy != null) {\n                                if (xml_activationEnergy[0] != null) {\n                                    let value = parseFloat(getNodeValue(getFirstChildNode(xml_activationEnergy[0])));\n                                    activationEnergy = new ActivationEnergy(getAttributes(xml_activationEnergy[0]), value);\n                                }\n                            }\n                            let tInfinity;\n                            let xml_tInfinity = xml_MCRCMethod[0].getElementsByTagName(\"me:TInfinity\");\n                            if (xml_tInfinity != null) {\n                                if (xml_tInfinity[0] != null) {\n                                    let value = parseFloat(getNodeValue(getFirstChildNode(xml_tInfinity[0])));\n                                    tInfinity = new NInfinity(getAttributes(xml_tInfinity[0]), value);\n                                }\n                            }\n                            let nInfinity;\n                            let xml_nInfinity = xml_MCRCMethod[0].getElementsByTagName(\"me:nInfinity\");\n                            if (xml_nInfinity != null) {\n                                if (xml_nInfinity[0] != null) {\n                                    let value = parseFloat(getNodeValue(getFirstChildNode(xml_nInfinity[0])));\n                                    nInfinity = new NInfinity(getAttributes(xml_nInfinity[0]), value);\n                                }\n                            }\n                            mCRCMethod = new MesmerILT(attributes, preExponential, activationEnergy, tInfinity, nInfinity);\n                        }\n                    }\n                }\n                else {\n                    mCRCMethod = new MCRCMethod(attributes, name);\n                }\n            }\n            // Load transition state.\n            //console.log(\"Load  transition state...\");\n            let xml_transitionState = xml_reactions[i].getElementsByTagName('me:transitionState');\n            let transitionState;\n            if (xml_transitionState.length > 0) {\n                let xml_molecule = xml_transitionState[0].getElementsByTagName('molecule')[0];\n                let moleculeID = xml_molecule.getAttribute(\"ref\");\n                transitionState = new TransitionState(getAttributes(xml_molecule), get(molecules, moleculeID));\n                //console.log(\"transitionState moleculeID=\" + transitionState.molecule.getID());\n                //console.log(\"transitionState role=\" + transitionState.attributes.get(\"role\"));\n            }\n            // Load tunneling.\n            let xml_tunneling = xml_reactions[i].getElementsByTagName('me:tunneling');\n            let tunneling;\n            if (xml_tunneling.length > 0) {\n                tunneling = new Tunneling(getAttributes(xml_tunneling[0]));\n            }\n            let reaction = new Reaction(attributes, reactionID, reactants, products, mCRCMethod, transitionState, tunneling);\n            reactions.set(reactionID, reaction);\n            //console.log(\"reaction=\" + reaction);\n        }\n    }\n}\n/**\n * Create a diagram.\n * @param {Map<string, Molecule>} molecules The molecules.\n * @param {Map<string, Reaction>} reactions The reactions.\n * @param {boolean} dark True for dark mode.\n * @returns {HTMLCanvasElement} The diagram.\n * @param {string} font The font to use.\n * @param {number} lw The line width of reactants, transition states and products.\n * @param {string} lwc The line width color to use.\n */\nfunction drawReactionDiagram(canvas, molecules, reactions, dark, font, lw, lwc) {\n    console.log(\"drawReactionDiagram\");\n    // TODO: Set styles depending on dark/light mode settings of users browser and not hard code.\n    //let white = \"white\";\n    let black = \"black\";\n    let green = \"green\";\n    let red = \"red\";\n    let blue = \"blue\";\n    //let yellow = \"yellow\";\n    let orange = \"orange\";\n    let background = \"black\";\n    let foreground = \"white\";\n    const ctx = canvas.getContext(\"2d\");\n    //ctx.fillStyle = background;\n    // Get text height for font size.\n    let th = getTextHeight(ctx, \"Aj\", font);\n    //console.log(\"th=\" + th);\n    // Go through reactions:\n    // 1. Create sets of reactants, end products, intermediate products and transition states.\n    // 2. Create maps of orders and energies.\n    // 3. Calculate maximum energy.\n    let reactants = new Set();\n    let products = new Set();\n    let intProducts = new Set();\n    let transitionStates = new Set();\n    let orders = new Map();\n    let energies = new Map();\n    let i = 0;\n    let energyMin = Number.MAX_VALUE;\n    let energyMax = Number.MIN_VALUE;\n    reactions.forEach(function (reaction, id) {\n        // Get TransitionState if there is one.\n        let transitionState = reaction.transitionState;\n        //console.log(\"reactant=\" + reactant);\n        let reactantsLabel = reaction.getReactantsLabel();\n        reactants.add(reactantsLabel);\n        if (products.has(reactantsLabel)) {\n            intProducts.add(reactantsLabel);\n        }\n        let energy = reaction.getReactantsEnergy();\n        energyMin = Math.min(energyMin, energy);\n        energyMax = Math.max(energyMax, energy);\n        energies.set(reactantsLabel, energy);\n        let productsLabel = reaction.getProductsLabel();\n        products.add(productsLabel);\n        energy = reaction.getProductsEnergy();\n        energyMin = Math.min(energyMin, energy);\n        energyMax = Math.max(energyMax, energy);\n        energies.set(productsLabel, energy);\n        if (!orders.has(reactantsLabel)) {\n            orders.set(reactantsLabel, i);\n            i++;\n        }\n        if (orders.has(productsLabel)) {\n            i--;\n            let j = get(orders, productsLabel);\n            // Move product to end and shift everything back.\n            orders.forEach(function (value, key) {\n                if (value > j) {\n                    orders.set(key, value - 1);\n                }\n            });\n            // Insert transition state.\n            if (transitionState != undefined) {\n                let tsn = transitionState.getRef();\n                transitionStates.add(tsn);\n                orders.set(tsn, i);\n                energy = transitionState.molecule.getEnergy();\n                energyMin = Math.min(energyMin, energy);\n                energyMax = Math.max(energyMax, energy);\n                energies.set(tsn, energy);\n                i++;\n            }\n            orders.set(productsLabel, i);\n            i++;\n        }\n        else {\n            if (transitionState != undefined) {\n                let tsn = transitionState.getRef();\n                transitionStates.add(tsn);\n                orders.set(tsn, i);\n                energy = transitionState.molecule.getEnergy();\n                energyMin = Math.min(energyMin, energy);\n                energyMax = Math.max(energyMax, energy);\n                energies.set(tsn, energy);\n                i++;\n            }\n            orders.set(productsLabel, i);\n            i++;\n        }\n    });\n    //console.log(\"orders=\" + mapToString(orders));\n    //console.log(\"energies=\" + mapToString(energies));\n    //console.log(\"energyMax=\" + energyMax);\n    //console.log(\"energyMin=\" + energyMin);\n    let energyRange = energyMax - energyMin;\n    //console.log(\"energyRange=\" + energyRange);\n    //console.log(\"reactants=\" + reactants);\n    //console.log(\"products=\" + products);\n    //console.log(\"transitionStates=\" + transitionStates);\n    // Create a lookup from order to label.\n    let reorders = [];\n    orders.forEach(function (value, key) {\n        reorders[value] = key;\n    });\n    //console.log(\"reorders=\" + arrayToString(reorders));\n    // Iterate through the reorders:\n    // 1. Capture coordinates for connecting lines.\n    // 2. Store maximum x.\n    let x0 = 0;\n    let y0;\n    let x1;\n    let y1;\n    let xmax = 0;\n    let tw;\n    let textSpacing = 5; // Spacing between end of line and start of text.\n    let stepSpacing = 10; // Spacing between steps.\n    let reactantsInXY = new Map();\n    let reactantsOutXY = new Map();\n    let productsInXY = new Map();\n    let productsOutXY = new Map();\n    let transitionStatesInXY = new Map();\n    let transitionStatesOutXY = new Map();\n    reorders.forEach(function (value) {\n        //console.log(\"value=\" + value + \".\");\n        //console.log(\"energies=\" + mapToString(energies));\n        let energy = get(energies, value);\n        let energyRescaled = rescale(energyMin, energyRange, 0, canvas.height, energy);\n        // Get text width.\n        tw = Math.max(getTextWidth(ctx, energy.toString(), font), getTextWidth(ctx, value, font));\n        x1 = x0 + tw + textSpacing;\n        y0 = energyRescaled + lw;\n        y1 = y0;\n        // Draw horizontal line and add label.\n        // (The drawing is now not done here but done later so labels are on top of lines.)\n        // The code is left here commented out for reference.\n        //drawLevel(ctx, green, 4, x0, y0, x1, y1, th, value);\n        reactantsInXY.set(value, [x0, y0]);\n        reactantsOutXY.set(value, [x1, y1]);\n        if (products.has(value)) {\n            productsInXY.set(value, [x0, y0]);\n            productsOutXY.set(value, [x1, y1]);\n        }\n        if (transitionStates.has(value)) {\n            transitionStatesInXY.set(value, [x0, y0]);\n            transitionStatesOutXY.set(value, [x1, y1]);\n        }\n        x0 = x1 + stepSpacing;\n        xmax = x1;\n    });\n    // Set canvas width to maximum x.\n    canvas.width = xmax;\n    //console.log(\"canvas.width=\" + canvas.width);\n    // Set canvas height to maximum energy plus the label.\n    let canvasHeightWithBorder = canvas.height + (4 * th) + (2 * lw);\n    //console.log(\"canvasHeightWithBorder=\" + canvasHeightWithBorder);\n    let originalCanvasHeight = canvas.height;\n    // Update the canvas height.\n    canvas.height = canvasHeightWithBorder;\n    // Set the transformation matrix.\n    //ctx.transform(1, 0, 0, 1, 0, canvasHeightWithBorder);\n    ctx.transform(1, 0, 0, -1, 0, canvasHeightWithBorder);\n    // Go through reactions and draw connecting lines.\n    reactions.forEach(function (reaction, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"reaction=\" + reaction);\n        // Get TransitionState if there is one.\n        let transitionState = reaction.transitionState;\n        //console.log(\"reactant=\" + reactant);\n        let reactantsLabel = reaction.getReactantsLabel();\n        let productsLabel = reaction.getProductsLabel();\n        let reactantOutXY = get(reactantsOutXY, reactantsLabel);\n        let productInXY = get(productsInXY, productsLabel);\n        if (transitionState != undefined) {\n            let transitionStateLabel = transitionState.getRef();\n            let transitionStateInXY = get(transitionStatesInXY, transitionStateLabel);\n            drawLine(ctx, black, lwc, reactantOutXY[0], reactantOutXY[1], transitionStateInXY[0], transitionStateInXY[1]);\n            let transitionStateOutXY = get(transitionStatesOutXY, transitionStateLabel);\n            drawLine(ctx, black, lwc, transitionStateOutXY[0], transitionStateOutXY[1], productInXY[0], productInXY[1]);\n        }\n        else {\n            drawLine(ctx, black, lwc, reactantOutXY[0], reactantOutXY[1], productInXY[0], productInXY[1]);\n        }\n    });\n    // Draw horizontal lines and labels.\n    // (This is done last so that the labels are on top of the vertical lines.)\n    reactants.forEach(function (value) {\n        let energy = get(energies, value);\n        let energyRescaled = rescale(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0 = get(reactantsInXY, value)[0];\n        let y = energyRescaled + lw;\n        let x1 = get(reactantsOutXY, value)[0];\n        let energyString = energy.toString();\n        drawLevel(ctx, blue, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n    products.forEach(function (value) {\n        let energy = get(energies, value);\n        let energyRescaled = rescale(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0 = get(productsInXY, value)[0];\n        let y = energyRescaled + lw;\n        let x1 = get(productsOutXY, value)[0];\n        let energyString = energy.toString();\n        if (intProducts.has(value)) {\n            drawLevel(ctx, orange, lw, x0, y, x1, y, font, th, value, energyString);\n        }\n        else {\n            drawLevel(ctx, green, lw, x0, y, x1, y, font, th, value, energyString);\n        }\n    });\n    transitionStates.forEach(function (value) {\n        let v;\n        let energy = get(energies, value);\n        let energyRescaled = rescale(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0 = get(transitionStatesInXY, value)[0];\n        let y = energyRescaled + lw;\n        let x1 = get(transitionStatesOutXY, value)[0];\n        let energyString = energy.toString();\n        drawLevel(ctx, red, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n}\n/**\n * Display molecules table.\n */\nfunction displayMoleculesTable() {\n    if (molecules.size == 0) {\n        return;\n    }\n    // Prepare table headings.\n    let moleculesTable = getTH([\n        \"Name\",\n        \"Energy<br>kJ/mol\",\n        \"Rotation constants<br>cm<sup>-1</sup>\",\n        \"Vibration frequencies<br>cm<sup>-1</sup>\"\n    ]);\n    molecules.forEach(function (molecule, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"molecule=\" + molecule);\n        let energyNumber = molecule.getEnergy();\n        let energy;\n        if (energyNumber == null) {\n            energy = \"\";\n        }\n        else {\n            energy = energyNumber.toString();\n        }\n        //console.log(\"energy=\" + energy);\n        let rotationConstants = \"\";\n        let rotConsts = molecule.getRotationConstants();\n        if (rotConsts != undefined) {\n            rotationConstants = arrayToString(rotConsts, \" \");\n        }\n        let vibrationFrequencies = \"\";\n        let vibFreqs = molecule.getVibrationFrequencies();\n        if (vibFreqs != undefined) {\n            vibrationFrequencies = arrayToString(vibFreqs, \" \");\n        }\n        moleculesTable += getTR(getTD(id)\n            + getTD(getInput(\"number\", id + \"_energy\", \"setEnergy(this)\", energy))\n            + getTD(rotationConstants, true)\n            + getTD(vibrationFrequencies, true));\n    });\n    molecules_table = document.getElementById(\"molecules_table\");\n    if (molecules_table !== null) {\n        molecules_table.innerHTML = moleculesTable;\n    }\n}\n/**\n * Display reactions table.\n */\nfunction displayReactionsTable() {\n    if (reactions.size == 0) {\n        return;\n    }\n    // Prepare table headings.\n    let reactionsTable = getTH([\"ID\", \"Reactants\", \"Products\", \"Transition State\",\n        \"PreExponential\", \"Activation Energy\", \"TInfinity\", \"NInfinity\"]);\n    reactions.forEach(function (reaction, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"reaction=\" + reaction);\n        let reactants = arrayToString(Array.from(reaction.reactants.keys()), \" \");\n        let products = arrayToString(Array.from(reaction.products.keys()), \" \");\n        let transitionState = \"\";\n        let preExponential = \"\";\n        let activationEnergy = \"\";\n        let tInfinity = \"\";\n        let nInfinity = \"\";\n        if (reaction.transitionState != undefined) {\n            let name = reaction.transitionState.attributes.get(\"name\");\n            if (name != null) {\n                transitionState = name;\n            }\n        }\n        if (reaction.mCRCMethod != undefined) {\n            if (reaction.mCRCMethod instanceof MesmerILT) {\n                if (reaction.mCRCMethod.preExponential != null) {\n                    preExponential = reaction.mCRCMethod.preExponential.value.toString() + \" \"\n                        + reaction.mCRCMethod.preExponential.attributes.get(\"units\");\n                }\n                if (reaction.mCRCMethod.activationEnergy != null) {\n                    activationEnergy = reaction.mCRCMethod.activationEnergy.value.toString() + \" \"\n                        + reaction.mCRCMethod.activationEnergy.attributes.get(\"units\");\n                }\n                if (reaction.mCRCMethod.tInfinity != null) {\n                    tInfinity = reaction.mCRCMethod.tInfinity.toString();\n                }\n                if (reaction.mCRCMethod.nInfinity != null) {\n                    nInfinity = reaction.mCRCMethod.nInfinity.value.toString();\n                }\n            }\n            else {\n                if (reaction.mCRCMethod.attributes.get(\"name\") == \"RRKM\") {\n                }\n                else {\n                    throw new Error(\"Unexpected mCRCMethod: \" + reaction.mCRCMethod);\n                }\n            }\n        }\n        reactionsTable += getTR(getTD(id) + getTD(reactants) + getTD(products) + getTD(transitionState)\n            + getTD(preExponential, true) + getTD(activationEnergy, true) + getTD(tInfinity, true)\n            + getTD(nInfinity, true));\n        reactions_table = document.getElementById(\"reactions_table\");\n        if (reactions_table !== null) {\n            reactions_table.innerHTML = reactionsTable;\n        }\n    });\n}\n/**\n * Display reactions diagram.\n */\nfunction displayReactionsDiagram() {\n    if (reactions.size > 1) {\n        // Set reactions_diagram_title.\n        reactions_diagram_title = document.getElementById(\"reactions_diagram_title\");\n        if (reactions_diagram_title != null) {\n            reactions_diagram_title.innerHTML = \"Diagram\";\n        }\n        // Display the diagram.\n        let canvas = document.getElementById(\"reactions_diagram\");\n        let font = \"14px Arial\";\n        let dark = true;\n        let lw = 4;\n        let lwc = 2;\n        if (canvas != null) {\n            canvas.style.display = \"block\";\n            drawReactionDiagram(canvas, molecules, reactions, dark, font, lw, lwc);\n        }\n    }\n}\n/**\n * Display conditions.\n */\nfunction displayConditions() {\n    let bathGas_element = document.getElementById(\"bathGas\");\n    if (bathGas_element != null) {\n        bathGas_element.innerHTML = \"Bath Gas \" + conditions.bathGas.molecule.getID();\n    }\n    let PTs_element = document.getElementById(\"PT_table\");\n    let table = getTH([\"P\", \"T\"]);\n    if (PTs_element != null) {\n        conditions.pTs.forEach(function (pTpair) {\n            table += getTR(getTD(pTpair.P.toString()) + getTD(pTpair.T.toString()));\n        });\n        PTs_element.innerHTML = table;\n    }\n}\n/**\n * Display modelParameters.\n */\nfunction displayModelParameters() {\n    let modelParameters_element = document.getElementById(\"modelParameters_table\");\n    let table = getTH([\"Parameter\", \"Value\"]);\n    table += getTR(getTD(\"Grain Size\") + getTD(modelParameters.grainSize.value.toString()));\n    table += getTR(getTD(\"Energy Above The Top Hill\") + getTD(modelParameters.energyAboveTheTopHill.toString()));\n    if (modelParameters_element != null) {\n        modelParameters_element.innerHTML = table;\n    }\n}\n/**\n * Display control.\n */\nfunction displayControl() {\n    let control_table_element = document.getElementById(\"control_table\");\n    let table = getTH([\"Control\", \"Value\"]);\n    if (control.testDOS != undefined) {\n        table += getTR(getTD(\"me.testDOS\") + getTD(\"\"));\n    }\n    if (control.printSpeciesProfile != undefined) {\n        table += getTR(getTD(\"me.printSpeciesProfile\") + getTD(\"\"));\n    }\n    if (control.testMicroRates != undefined) {\n        table += getTR(getTD(\"me.testMicroRates\") + getTD(\"\"));\n    }\n    if (control.testRateConstant != undefined) {\n        table += getTR(getTD(\"me.testRateConstant\") + getTD(\"\"));\n    }\n    if (control.printGrainDOS != undefined) {\n        table += getTR(getTD(\"me.printGrainDOS\") + getTD(\"\"));\n    }\n    if (control.printCellDOS != undefined) {\n        table += getTR(getTD(\"me.printCellDOS\") + getTD(\"\"));\n    }\n    if (control.printReactionOperatorColumnSums != undefined) {\n        table += getTR(getTD(\"me.printReactionOperatorColumnSums\") + getTD(\"\"));\n    }\n    if (control.printTunnellingCoefficients != undefined) {\n        table += getTR(getTD(\"me.printTunnellingCoefficients\") + getTD(\"\"));\n    }\n    if (control.printGrainkfE != undefined) {\n        table += getTR(getTD(\"me.printGrainkfE\") + getTD(\"\"));\n    }\n    if (control.printGrainBoltzmann != undefined) {\n        table += getTR(getTD(\"me.printGrainBoltzmann\") + getTD(\"\"));\n    }\n    if (control.printGrainkbE != undefined) {\n        table += getTR(getTD(\"me.printGrainkbE\") + getTD(\"\"));\n    }\n    if (control.eigenvalues != undefined) {\n        table += getTR(getTD(\"me.eigenvalues\") + getTD(control.eigenvalues.toString()));\n    }\n    if (control.hideInactive != undefined) {\n        table += getTR(getTD(\"me.hideInactive\") + getTD(\"\"));\n    }\n    if (control.diagramEnergyOffset != undefined) {\n        table += getTR(getTD(\"me.diagramEnergyOffset\") + getTD(control.diagramEnergyOffset.value.toString()));\n    }\n    if (control_table_element != null) {\n        control_table_element.innerHTML = table;\n    }\n}\n/**\n * Set the energy of a molecule when the energy input value is changed.\n * @param input The input element.\n */\nexport function setEnergy(input) {\n    let id_energy = input.id;\n    let moleculeID = id_energy.split(\"_\")[0];\n    let molecule = molecules.get(moleculeID);\n    if (molecule != undefined) {\n        let inputValue = parseFloat(input.value);\n        if (!isNaN(inputValue)) {\n            molecule.setEnergy(inputValue);\n            console.log(\"Energy of \" + moleculeID + \" set to \" + inputValue);\n        }\n        else {\n            alert(\"Energy input for \" + moleculeID + \" is not a number\");\n            let inputElement = document.getElementById(id_energy);\n            inputElement.value = molecule.getEnergy().toString();\n        }\n        //console.log(\"molecule=\" + molecule);\n    }\n}\nwindow.setEnergy = setEnergy;\n/**\n * Save to XML file.\n */\nwindow.saveXML = function () {\n    console.log(\"saveXML\");\n    const pad = \"  \";\n    let level;\n    const padding2 = pad.repeat(2);\n    // Create me.title.\n    let title_xml = \"\\n\" + pad + getTag(title, \"me:title\");\n    // Create moleculeList.\n    level = 2;\n    let moleculeList = \"\";\n    molecules.forEach(function (molecule, id) {\n        moleculeList += molecule.toXML(\"molecule\", pad, level);\n    });\n    moleculeList = getTag(moleculeList, \"moleculeList\", undefined, undefined, undefined, pad, true);\n    // Create reactionList.\n    level = 2;\n    let reactionList = \"\";\n    reactions.forEach(function (reaction, id) {\n        reactionList += reaction.toXML(\"reaction\", pad, level);\n    });\n    reactionList = getTag(reactionList, \"reactionList\", undefined, undefined, undefined, pad, true);\n    // Create me.Conditions\n    let xml_conditions = conditions.toXML(pad, pad);\n    // Create modelParameters\n    let xml_modelParameters = modelParameters.toXML(pad, pad);\n    // create me.control\n    let xml_control = control.toXML(pad, pad);\n    // Create a new Blob object from the data\n    let blob = new Blob([header, mesmerStartTag, title_xml, moleculeList, reactionList,\n        xml_conditions, xml_modelParameters, xml_control, mesmerEndTag], { type: \"text/plain\" });\n    // Create a new object URL for the blob\n    let url = URL.createObjectURL(blob);\n    // Create a new 'a' element\n    let a = document.createElement(\"a\");\n    // Set the href and download attributes for the 'a' element\n    a.href = url;\n    a.download = input_xml_filename; // Replace with your desired filename\n    // Append the 'a' element to the body and click it to start the download\n    document.body.appendChild(a);\n    a.click();\n    // Remove the 'a' element after the download starts\n    document.body.removeChild(a);\n};\n//# sourceMappingURL=client.js.map","import {\n    get, rescale\n} from './util.js';\n\nimport {\n    getAttribute, getFirstElement, getFirstChildNode, getNodeValue, getTag, getEndTag,\n    getAttributes, toHTML, getSingularElement\n} from './xml.js';\n\nimport {\n    Molecule, Atom, Bond, EnergyTransferModel, DeltaEDown, DOSCMethod, Property\n} from './molecule.js';\n\nimport {\n    Reaction, TransitionState, Reactant, Product, MCRCMethod, MesmerILT,\n    PreExponential, ActivationEnergy, NInfinity, ZhuNakamuraCrossing, Tunneling, TInfinity\n} from './reaction.js';\n\nimport {\n    arrayToString, toNumberArray, isNumeric\n} from './functions.js';\n\nimport {\n    getTD, getTH, getTR, getInput\n} from './html.js';\n\nimport {\n    drawLevel,\n    drawLine,\n    getTextHeight, getTextWidth\n} from './canvas.js';\n\nimport {\n    NumberArrayWithAttributes, NumberWithAttributes\n} from './classes.js';\n\nimport {\n    BathGas, Conditions, PTpair\n} from './conditions.js';\n\nimport {\n    GrainSize, ModelParameters\n} from './modelParameters.js';\n\nimport {\n    Control, DiagramEnergyOffset\n} from './control.js';\n\n// Code for service worker for Progressive Web App (PWA).\nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', function () {\n        const swUrl = new URL('../../../sw.js', import.meta.url);\n        //const swUrl = new URL('../../../sw.js', document.baseURI);\n        navigator.serviceWorker.register(swUrl);\n    });\n}\n/*  \nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', function () {\n        navigator.serviceWorker.register('../../../sw.js').then(function (registration) {\n            console.log('ServiceWorker registration successful with scope: ', registration.scope);\n        }, function (err) {\n            console.log('ServiceWorker registration failed: ', err);\n        });\n    });\n}\n*/\n\n//declare var global: any;\n//const globalScope = (typeof global !== 'undefined') ? global : window;\n\n//if (typeof global === 'undefined') {\n//    (window as any).global = window;\n//}\n\ndeclare global {\n    interface Window {\n        loadXML(): void;\n        saveXML(): void;\n    }\n}\n\n// Expected XML tags strings.\nlet me_title_s: string = 'me:title';\n\n/**\n * For storing me.title.\n */\nlet title: string;\n\n/**\n * For storing the XML root start tag.\n */\nlet mesmerStartTag: string;\n\n/**\n * For storing the XML root end tag.\n */\nlet mesmerEndTag: string;\n\n/**\n * A map of molecules with Molecule.id as key and Molecules as values.\n */\nlet molecules: Map<string, Molecule> = new Map([]);\n\n/**\n * For storing the maximum molecule energy in a reaction.\n */\nlet maxMoleculeEnergy: number = -Infinity;\n\n/**\n * For storing the minimum molecule energy in a reaction.\n */\nlet minMoleculeEnergy: number = Infinity;\n\n/**\n * A map of reactions with Reaction.id as keys and Reactions as values.\n */\nlet reactions: Map<string, Reaction> = new Map([]);\n\n/**\n * The header of the XML file.\n */\nconst header: string = `<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<?xml-stylesheet type='text/xsl' href='../../mesmer2.xsl' media='other'?>\n<?xml-stylesheet type='text/xsl' href='../../mesmer1.xsl' media='screen'?>`;\n\n/**\n * The filename of the mesmer input file loaded.\n */\nlet input_xml_filename: string;\n\n/**\n * The load button.\n */\nlet loadButton: HTMLElement | null;\n\n/**\n * The save button.\n */\nlet saveButton: HTMLElement | null;\n\n/**\n * The XML text element.\n */\nlet me_title: HTMLCollectionOf<Element> | null;\nlet molecules_title: HTMLElement | null;\nlet molecules_table: HTMLElement | null;\nlet reactions_title: HTMLElement | null;\nlet reactions_table: HTMLElement | null;\nlet reactions_diagram_title: HTMLElement | null;\nlet conditions_title: HTMLElement | null;\nlet conditions_table: HTMLElement | null;\nlet modelParameters_title: HTMLElement | null;\nlet modelParameters_table: HTMLElement | null;\nlet xml_title: HTMLElement | null;\nlet xml_text: HTMLElement | null;\n\n/**\n * Display the XML.\n * @param {string} xml The XML to display.\n */\nfunction displayXML(xml: string) {\n    //console.log(\"xml=\" + xml);\n    if (xml_title != null) {\n        xml_title.innerHTML = input_xml_filename;\n    }\n    if (xml_text != null) {\n        xml_text.innerHTML = toHTML(xml);\n    }\n}\n\n/**\n * Parses xml to initilise molecules.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initMolecules(xml: XMLDocument): void {\n    let moleculeList_s: string = 'moleculeList';\n    console.log(moleculeList_s);\n    let xml_moleculeList: Element = getSingularElement(xml, moleculeList_s);\n    // Set molecules_title.\n    molecules_title = document.getElementById(\"molecules_title\");\n    if (molecules_title != null) {\n        molecules_title.innerHTML = \"Molecules\";\n    }\n    // xml_moleculeList should have one or more molecule elements and no other elements.\n    let moleculeListTagNames: Set<string> = new Set();\n    xml_moleculeList.childNodes.forEach(function (node) {\n        moleculeListTagNames.add(node.nodeName);\n    });\n    if (moleculeListTagNames.size != 1) {\n        if (!(moleculeListTagNames.size == 2 && moleculeListTagNames.has(\"#text\"))) {\n            console.error(\"moleculeListTagNames:\");\n            moleculeListTagNames.forEach(x => console.error(x));\n            throw new Error(\"Additional tag names in moleculeList:\");\n        }\n    }\n    if (!moleculeListTagNames.has(\"molecule\")) {\n        throw new Error(\"Expecting molecule tagName but it is not present!\");\n    }\n    let xml_molecules: HTMLCollectionOf<Element> = xml_moleculeList.getElementsByTagName('molecule');\n    let xml_molecules_length = xml_molecules.length;\n    console.log(\"Number of molecules=\" + xml_molecules_length);\n    // Process each molecule.\n    //xml_molecules.forEach(function (xml_molecule) { // Cannot iterate over HTMLCollectionOf like this.\n    for (let i = 0; i < xml_molecules.length; i++) {\n        // Set attributes.\n        let attributes: Map<string, string> = getAttributes(xml_molecules[i]);\n\n        let moleculeTagNames: Set<string> = new Set();\n        let cns: NodeListOf<ChildNode> = xml_molecules[i].childNodes;\n        cns.forEach(function (node) {\n            moleculeTagNames.add(node.nodeName);\n        });\n        //console.log(\"moleculeTagNames:\");\n        //moleculeTagNames.forEach(x => console.log(x));\n\n        // Set atoms.\n        const atoms: Map<string, Atom> = new Map();\n        // Sometimes there is an individual atom not in an atomArray.\n        //let xml_atomArray = xml_molecules[i].getElementsByTagName(\"atomArray\")[0];\n        //if (xml_atomArray != null) {\n        moleculeTagNames.delete(\"atom\");\n        moleculeTagNames.delete(\"atomArray\");\n\n        let xml_atoms: HTMLCollectionOf<Element> = xml_molecules[i].getElementsByTagName(\"atom\");\n        for (let j = 0; j < xml_atoms.length; j++) {\n            let attribs: Map<string, string> = getAttributes(xml_atoms[j]);\n            let id: string | undefined = attribs.get(\"id\");\n            if (id != undefined) {\n                let atom = new Atom(attribs);\n                //console.log(atom.toString());\n                atoms.set(id, atom);\n            }\n        }\n        //}\n        // Read bondArray.\n        moleculeTagNames.delete(\"bond\");\n        moleculeTagNames.delete(\"bondArray\");\n        const bonds: Map<string, Bond> = new Map();\n        let xml_bonds: HTMLCollectionOf<Element> = xml_molecules[i].getElementsByTagName(\"bond\");\n        for (let j = 0; j < xml_bonds.length; j++) {\n            let attribs: Map<string, string> = getAttributes(xml_bonds[j]);\n            let id: string | undefined = attribs.get(\"atomRefs2\");\n            if (id != undefined) {\n                let bond = new Bond(attribs);\n                //console.log(bond.toString());\n                bonds.set(id, bond);\n            }\n        }\n        // Read propertyList.\n        const properties: Map<string, Property> = new Map();\n        // Sometimes there is a single property not in propertyList!\n        //let xml_propertyList = xml_molecules[i].getElementsByTagName(\"propertyList\")[0];\n        //if (xml_propertyList != null) {\n        //    let xml_properties = xml_propertyList.getElementsByTagName(\"property\");\n\n        moleculeTagNames.delete(\"property\");\n        moleculeTagNames.delete(\"propertyList\");\n        let xml_properties: HTMLCollectionOf<Element> = xml_molecules[i].getElementsByTagName(\"property\");\n        for (let j = 0; j < xml_properties.length; j++) {\n            let attribs: Map<string, string> = getAttributes(xml_properties[j]);\n            let children: HTMLCollectionOf<Element> = xml_properties[j].children;\n            if (children.length != 1) {\n                throw new Error(\"Expecting 1 child but finding \" + children.length);\n            }\n            let nodeAttributes: Map<string, string> = getAttributes(children[0]);\n            let nodeName: string = children[0].nodeName; // Expecting scalar or array\n            let textContent: string | null = children[0].textContent;\n            if (textContent == null) {\n                console.error(\"nodeName\");\n                throw new Error('textContent is null');\n            }\n            textContent = textContent.trim();\n            let dictRef: string | undefined = attribs.get(\"dictRef\");\n            //console.log(\"dictRef=\" + dictRef);\n            if (dictRef == null) {\n                throw new Error('dictRef is null');\n            }\n            //console.log(\"fcnn=\" + fcnn);\n            if (nodeName == \"scalar\") {\n                moleculeTagNames.delete(\"scalar\");\n                let value: number = parseFloat(textContent);\n                properties.set(dictRef, new Property(attribs,\n                    new NumberWithAttributes(nodeAttributes, value)));\n                if (dictRef === \"me:ZPE\") {\n                    minMoleculeEnergy = Math.min(minMoleculeEnergy, value);\n                    maxMoleculeEnergy = Math.max(maxMoleculeEnergy, value);\n                }\n            } else if (nodeName == \"array\") {\n                moleculeTagNames.delete(\"array\");\n                properties.set(dictRef, new Property(attribs,\n                    new NumberArrayWithAttributes(nodeAttributes,\n                        toNumberArray(textContent.split(/\\s+/)), \" \")));\n            } else if (nodeName == \"matrix\") {\n            } else {\n                throw new Error(\"Unexpected nodeName: \" + nodeName);\n            }\n        }\n\n        let els: HTMLCollectionOf<Element> | null;\n\n        // Read energyTransferModel\n        moleculeTagNames.delete(\"me:energyTransferModel\");\n        let energyTransferModel: EnergyTransferModel | undefined = undefined;\n        els = xml_molecules[i].getElementsByTagName(\"me:energyTransferModel\");\n        if (els != null) {\n            if (els.length > 0) {\n                if (els.length != 1) {\n                    throw new Error(\"energyTransferModel length=\" + els.length);\n                }\n                let xml_deltaEDown = els[0].getElementsByTagName(\"me:deltaEDown\");\n                if (xml_deltaEDown != null) {\n                    if (xml_deltaEDown.length != 1) {\n                        throw new Error(\"deltaEDown length=\" + xml_deltaEDown.length);\n                    }\n                    let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_deltaEDown[0])));\n                    let deltaEDown: DeltaEDown = new DeltaEDown(getAttributes(xml_deltaEDown[0]), value);\n                    energyTransferModel = new EnergyTransferModel(getAttributes(els[0]), deltaEDown);\n                }\n            }\n        }\n\n        // Read DOSCMethod\n        moleculeTagNames.delete(\"me:DOSCMethod\");\n        let dOSCMethod: DOSCMethod | undefined = undefined;\n        els = xml_molecules[i].getElementsByTagName(\"me:DOSCMethod\");\n        if (els != null) {\n            let el: Element | null = els[0];\n            if (el != null) {\n                if (el != null) {\n                    let type = el.getAttribute(\"xsi:type\");\n                    if (type != null) {\n                        dOSCMethod = new DOSCMethod(type);\n                    }\n                }\n            }\n        }\n\n        // Check for unexpected tags.\n        moleculeTagNames.delete(\"#text\");\n        if (moleculeTagNames.size > 0) {\n            console.error(\"Remaining moleculeTagNames:\");\n            moleculeTagNames.forEach(x => console.error(x));\n            throw new Error(\"Unexpected tags in molecule.\");\n        }\n\n        let molecule = new Molecule(attributes, atoms, bonds, properties, energyTransferModel, dOSCMethod);\n        //console.log(molecule.toString());\n        molecules.set(molecule.id, molecule);\n    }\n    // Add event listeners to molecules table.\n    molecules.forEach(function (molecule, id) {\n        let energyKey = id + \"_energy\";\n        let inputElement = document.getElementById(energyKey) as HTMLInputElement;\n        if (inputElement) {\n            inputElement.addEventListener('change', (event) => {\n                // The input is set up to call the function setEnergy(HTMLInputElement),\n                // so the following commented code is not used. As the input was setup \n                // as a number type. The any non numbers were It seems that there are two \n                // ways to get and store the value of the input element.\n                // Both ways have been kept for now as I don't know which way is better!\n                let eventTarget = event.target as HTMLInputElement;\n                let inputValue = eventTarget.value;\n                if (isNumeric(inputValue)) {\n                    molecule.setEnergy(parseFloat(inputValue));\n                    console.log(\"Set energy of \" + id + \" to \" + inputValue + \" kJ/mol\");\n                } else {\n                    alert(\"Energy input for \" + id + \" is not a number\");\n                    let inputElement = document.getElementById(energyKey) as HTMLInputElement;\n                    inputElement.value = molecule.getEnergy().toString();\n                    console.log(\"inputValue=\" + inputValue);\n                    console.log(\"Type of inputValue: \" + typeof inputValue);\n                }\n            });\n        }\n    });\n}\n\nlet inputElement: HTMLInputElement;\n\nfunction reload() {\n    inputElement = document.createElement('input');\n    inputElement.type = 'file';\n    inputElement.onchange = function () {\n        if (inputElement.files) {\n            for (let i = 0; i < inputElement.files.length; i++) {\n                console.log(\"inputElement.files[\" + i + \"]=\" + inputElement.files[i]);\n            }\n            let file: File | null = inputElement.files[0];\n            //console.log(\"file=\" + file);\n            console.log(file.name);\n            input_xml_filename = file.name;\n            if (xml_text != null) {\n                let reader = new FileReader();\n                let chunkSize = 1024 * 1024; // 1MB\n                let start = 0;\n                let contents = '';\n                reader.onload = function (e) {\n                    if (!e.target) {\n                        throw new Error('Event target is null');\n                    }\n                    contents += (e.target as FileReader).result as string;\n                    if (file != null) {\n                        if (start < file.size) {\n                            // Read the next chunk\n                            let blob = file.slice(start, start + chunkSize);\n                            reader.readAsText(blob);\n                            start += chunkSize;\n                        } else {\n                            // All chunks have been read\n                            contents = contents.trim();\n                            displayXML(contents);\n                            let parser = new DOMParser();\n                            let xml = parser.parseFromString(contents, \"text/xml\");\n                            parse(xml);\n\n                            // Send XML to the server\n                            fetch('http://localhost:1234/', {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'text/xml',\n                                },\n                                body: contents,\n                            })\n                                .then(response => {\n                                    if (!response.ok) {\n                                        throw new Error(`HTTP error! status: ${response.status}`);\n                                    }\n                                    return response.text();\n                                })\n                                .then(data => {\n                                    console.log('Server response:', data);\n                                })\n                                .catch(error => {\n                                    console.error('There was a problem with the fetch operation:', error);\n                                });\n                        }\n                    }\n                };\n                // Read the first chunk\n                let blob = file.slice(start, start + chunkSize);\n                reader.readAsText(blob);\n                start += chunkSize;\n            }\n        }\n    };\n    inputElement.click();\n    // Add event listener to load button.\n    loadButton = document.getElementById('load_button');\n    if (loadButton != null) {\n        loadButton.addEventListener('click', reload);\n    }\n\n    // Ensure save button is displayed.\n    saveButton = document.getElementById('saveButton');\n    if (saveButton != null) {\n        saveButton.style.display = 'inline';\n    }\n}\n\n/**\n * Once the DOM is loaded, set up the elements.\n */\ndocument.addEventListener('DOMContentLoaded', (event) => {\n\n    // Initialise elements\n    xml_title = document.getElementById(\"xml_title\");\n    xml_text = document.getElementById(\"xml_text\");\n\n\n    window.loadXML = function () {\n        reload();\n    }\n});\n\n/**\n * Set the title.\n * @param {XMLDocument} xml The XML document.\n */\nfunction setTitle(xml: XMLDocument) {\n    me_title = xml.getElementsByTagName(me_title_s);\n    if (me_title == null) {\n        throw new Error(me_title_s + ' not found');\n    } else {\n        if (me_title.length != 1) {\n            throw new Error('Multiple ' + me_title_s + ' elements found');\n        } else {\n            title = me_title[0].childNodes[0].nodeValue as string;\n            title = title.trim();\n            console.log(\"Title=\" + title);\n            let e: HTMLElement | null = document.getElementById(\"title\");\n            if (e != null) {\n                e.innerHTML = title;\n            }\n        }\n    }\n}\n\n/**\n * Parse the XML.\n * @param {XMLDocument} xml \n */\nfunction parse(xml: XMLDocument) {\n\n    /**\n     * Set mesmer_xml start tag.\n     */\n    mesmerStartTag = \"\\n\";\n    let documentElement: HTMLElement = xml.documentElement;\n    if (documentElement == null) {\n        throw new Error(\"Document element not found\");\n    } else {\n        let tagName: string = documentElement.tagName;\n        mesmerStartTag += \"<\" + tagName;\n        console.log(tagName);\n        mesmerEndTag = getEndTag(tagName, \"\", true);\n        let first: boolean = true;\n        let pad = \" \".repeat(tagName.length + 2);\n        let names: string[] = documentElement.getAttributeNames();\n        names.forEach(function (name) {\n            let attribute = documentElement.getAttribute(name);\n            let na = `${name}=\"${attribute}\"`;\n            if (first) {\n                first = false;\n                mesmerStartTag += \" \" + na;\n            } else {\n                mesmerStartTag += \"\\n\" + pad + na;\n            }\n        });\n        mesmerStartTag += \">\";\n        //console.log(mesmerStartTag);\n    }\n\n    /**\n     *  Set title.\n     */\n    setTitle(xml);\n\n    /**\n     * Generate molecules table.\n     */\n    initMolecules(xml);\n    displayMoleculesTable();\n\n    /**\n     * Generate reactions table.\n     */\n    initReactions(xml);\n    displayReactionsTable();\n    displayReactionsDiagram();\n\n    /**\n     * Generate conditions table.\n     */\n    initConditions(xml);\n    displayConditions();\n\n    /**\n     * Generate parameters table.\n     */\n    initModelParameters(xml);\n    displayModelParameters();\n\n    /**\n     * Generate control table.\n     */\n    initControl(xml);\n    displayControl();\n}\n\nlet conditions: Conditions;\n\n/**\n * Parse xml to initialise conditions.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initConditions(xml: XMLDocument): void {\n    let me_conditions_s: string = 'me:conditions';\n    console.log(me_conditions_s);\n    let xml_conditions: Element = getSingularElement(xml, me_conditions_s);\n    // Set conditions_title.\n    conditions_title = document.getElementById(\"conditions_title\");\n    if (conditions_title != null) {\n        conditions_title.innerHTML = \"Conditions\";\n    }\n    // BathGas\n    let xml_bathGas: Element = getSingularElement(xml_conditions, 'me:bathGas');\n    let attributes: Map<string, string> = getAttributes(xml_bathGas);\n    let bathGas: BathGas = new BathGas(attributes, get(molecules, xml_bathGas.childNodes[0].nodeValue));\n    // PTs\n    let xml_PTs: Element = getSingularElement(xml_conditions, 'me:PTs');\n    let xml_PTPairs: HTMLCollectionOf<Element> = xml_PTs.getElementsByTagName('me:PTpair');\n    // Process each PTpair.\n    let PTs: PTpair[] = [];\n    for (let i = 0; i < xml_PTPairs.length; i++) {\n        PTs.push(new PTpair(getAttributes(xml_PTPairs[i])));\n    }\n    conditions = new Conditions(bathGas, PTs);\n}\n\nlet modelParameters: ModelParameters;\n\n/**\n * Parses xml to initialise modelParameters.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initModelParameters(xml: XMLDocument): void {\n    let me_modelParameters_s: string = 'me:modelParameters';\n    console.log(me_modelParameters_s);\n    let xml_modelParameters: Element = getSingularElement(xml, me_modelParameters_s);\n    // Set modelParameters_title.\n    modelParameters_title = document.getElementById(\"modelParameters_title\");\n    if (modelParameters_title != null) {\n        modelParameters_title.innerHTML = \"Model Parameters\";\n    }\n    // GrainSize\n    let xml_grainSize: Element = getSingularElement(xml_modelParameters, 'me:grainSize');\n    let attributes: Map<string, string> = getAttributes(xml_grainSize);\n    let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_grainSize)));\n    let grainSize: GrainSize = new GrainSize(attributes, value);\n    // EnergyAboveTheTopHill\n    let xml_energyAboveTheTopHill: Element = getSingularElement(xml_modelParameters, 'me:energyAboveTheTopHill');\n    let energyAboveTheTopHill: number = parseFloat(getNodeValue(getFirstChildNode(xml_energyAboveTheTopHill)));\n    modelParameters = new ModelParameters(grainSize, energyAboveTheTopHill);\n}\n\nlet control: Control;\n\n/**\n * Parses xml to initialise control.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initControl(xml: XMLDocument): void {\n    let me_control_s: string = 'me:control';\n    console.log(me_control_s);\n    let xml_control: Element = getSingularElement(xml, me_control_s);\n    // Set control_title.\n    let control_title = document.getElementById(\"control_title\");\n    if (control_title != null) {\n        control_title.innerHTML = \"Control\";\n    }\n    // me:testDOS\n    let xml_testDOS: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:testDOS');\n    let testDOS: boolean | undefined;\n    if (xml_testDOS.length > 0) {\n        testDOS = true;\n    }\n    // me:printSpeciesProfile\n    let xml_printSpeciesProfile: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printSpeciesProfile');\n    let printSpeciesProfile: boolean | undefined;\n    if (xml_printSpeciesProfile.length > 0) {\n        printSpeciesProfile = true;\n    }\n    // me:testMicroRates\n    let xml_testMicroRates: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:testMicroRates');\n    let testMicroRates: boolean | undefined;\n    if (xml_testMicroRates.length > 0) {\n        testMicroRates = true;\n    }\n    // me:testRateConstant\n    let xml_testRateConstant: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:testRateConstant');\n    let testRateConstant: boolean | undefined;\n    if (xml_testRateConstant.length > 0) {\n        testRateConstant = true;\n    }\n    // me:printGrainDOS\n    let xml_printGrainDOS: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printGrainDOS');\n    let printGrainDOS: boolean | undefined;\n    if (xml_printGrainDOS.length > 0) {\n        printGrainDOS = true;\n    }\n    // me:printCellDOS\n    let xml_printCellDOS: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printCellDOS');\n    let printCellDOS: boolean | undefined;\n    if (xml_printCellDOS.length > 0) {\n        printCellDOS = true;\n    }\n    // me:printReactionOperatorColumnSums\n    let xml_printReactionOperatorColumnSums: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printReactionOperatorColumnSums');\n    let printReactionOperatorColumnSums: boolean | undefined;\n    if (xml_printReactionOperatorColumnSums.length > 0) {\n        printReactionOperatorColumnSums = true;\n    }\n    // me:printTunnellingCoefficients\n    let xml_printTunnellingCoefficients: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printTunnellingCoefficients');\n    let printTunnellingCoefficients: boolean | undefined;\n    if (xml_printTunnellingCoefficients.length > 0) {\n        printTunnellingCoefficients = true;\n    }\n    // me:printGrainkfE\n    let xml_printGrainkfE: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printGrainkfE');\n    let printGrainkfE: boolean | undefined;\n    if (xml_printGrainkfE.length > 0) {\n        printGrainkfE = true;\n    }\n    // me:printGrainBoltzmann\n    let xml_printGrainBoltzmann: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printGrainBoltzmann');\n    let printGrainBoltzmann: boolean | undefined;\n    if (xml_printGrainBoltzmann.length > 0) {\n        printGrainBoltzmann = true;\n    }\n    // me:printGrainkbE\n    let xml_printGrainkbE: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:printGrainkbE');\n    let printGrainkbE: boolean | undefined;\n    if (xml_printGrainkbE.length > 0) {\n        printGrainkbE = true;\n    }\n    // me:eigenvalues\n    let xml_eigenvalues: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:eigenvalues');\n    let eigenvalues: number | undefined;\n    if (xml_eigenvalues.length > 0) {\n        eigenvalues = parseFloat(getNodeValue(getFirstChildNode(xml_eigenvalues[0])));\n    }\n    // me:hideInactive\n    let xml_hideInactive: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:hideInactive');\n    let hideInactive: boolean | undefined;\n    if (xml_hideInactive.length > 0) {\n        hideInactive = true;\n    }\n    // me:diagramEnergyOffset\n    let xml_diagramEnergyOffset: HTMLCollectionOf<Element> = xml_control.getElementsByTagName('me:diagramEnergyOffset');\n    let diagramEnergyOffset: DiagramEnergyOffset | undefined;\n    if (xml_diagramEnergyOffset.length > 0) {\n        let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_diagramEnergyOffset[0])));\n        diagramEnergyOffset = new DiagramEnergyOffset(getAttributes(xml_diagramEnergyOffset[0]), value);\n    }\n\n    control = new Control(testDOS, printSpeciesProfile, testMicroRates, testRateConstant,\n        printGrainDOS, printCellDOS, printReactionOperatorColumnSums, printTunnellingCoefficients, printGrainkfE,\n        printGrainBoltzmann, printGrainkbE, eigenvalues, hideInactive, diagramEnergyOffset);\n}\n\n/**\n * Parses xml to initialise reactions.\n * @param {XMLDocument} xml The XML document.\n */\nfunction initReactions(xml: XMLDocument): void {\n    let reactionList_s: string = 'reactionList';\n    console.log(reactionList_s);\n    let xml_reactionList: Element = getSingularElement(xml, reactionList_s);\n    let xml_reactions: HTMLCollectionOf<Element> = xml_reactionList.getElementsByTagName('reaction');\n    let xml_reactions_length = xml_reactions.length;\n    console.log(\"Number of reactions=\" + xml_reactions_length);\n    // Process each reaction.\n    if (xml_reactions_length == 0) {\n        //return;\n        throw new Error(\"No reactions: There should be at least 1!\");\n    }\n    // Set reactions_title.\n    reactions_title = document.getElementById(\"reactions_title\");\n    if (reactions_title != null) {\n        reactions_title.innerHTML = \"Reactions\";\n    }\n    for (let i = 0; i < xml_reactions_length; i++) {\n        let attributes: Map<string, string> = getAttributes(xml_reactions[i]);\n        let reactionID = attributes.get(\"id\");\n        if (reactionID == null) {\n            throw new Error(\"reactionID is null\");\n        }\n        if (reactionID != null) {\n            console.log(\"id=\" + reactionID);\n            // Load reactants.\n            let reactants: Map<string, Reactant> = new Map([]);\n            let xml_reactants: HTMLCollectionOf<Element> = xml_reactions[i].getElementsByTagName('reactant');\n            //console.log(\"xml_reactants.length=\" + xml_reactants.length);\n            for (let j = 0; j < xml_reactants.length; j++) {\n                let xml_molecule: Element = getFirstElement(xml_reactants[j], 'molecule');\n                let moleculeID: string = getAttribute(xml_molecule, \"ref\");\n                reactants.set(moleculeID, new Reactant(getAttributes(xml_molecule),\n                    get(molecules, moleculeID)));\n            }\n            // Load products.\n            let products: Map<string, Product> = new Map([]);\n            let xml_products: HTMLCollectionOf<Element> = xml_reactions[i].getElementsByTagName('product');\n            //console.log(\"xml_products.length=\" + xml_products.length);\n            for (let j = 0; j < xml_products.length; j++) {\n                let xml_molecule = getFirstElement(xml_products[j], 'molecule');\n                let moleculeID: string = getAttribute(xml_molecule, \"ref\");\n                products.set(moleculeID,\n                    new Product(getAttributes(xml_molecule),\n                        get(molecules, moleculeID)));\n            }\n            // Load MCRCMethod.\n            //console.log(\"Load MCRCMethod...\");\n            let mCRCMethod: MCRCMethod | undefined;\n            let xml_MCRCMethod: HTMLCollectionOf<Element> = xml_reactions[i].getElementsByTagName('me:MCRCMethod');\n            //console.log(\"xml_MCRCMethod=\" + xml_MCRCMethod);\n            //console.log(\"xml_MCRCMethod.length=\" + xml_MCRCMethod.length);\n            if (xml_MCRCMethod.length > 0) {\n                let attributes: Map<string, string> = getAttributes(xml_MCRCMethod[0]);\n                let name: string | undefined = attributes.get(\"name\");\n                if (name == null) {\n                    let type = attributes.get(\"xsi:type\");\n                    if (type != null) {\n                        if (type === \"me:MesmerILT\") {\n                            let preExponential: PreExponential | undefined;\n                            let xml_preExponential: HTMLCollectionOf<Element> = xml_MCRCMethod[0].getElementsByTagName(\"me:preExponential\");\n                            if (xml_preExponential != null) {\n                                if (xml_preExponential[0] != null) {\n                                    let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_preExponential[0])));\n                                    preExponential = new PreExponential(getAttributes(xml_preExponential[0]), value);\n                                }\n                            }\n                            let activationEnergy: ActivationEnergy | undefined;\n                            let xml_activationEnergy: HTMLCollectionOf<Element> = xml_MCRCMethod[0].getElementsByTagName(\"me:activationEnergy\");\n                            if (xml_activationEnergy != null) {\n                                if (xml_activationEnergy[0] != null) {\n                                    let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_activationEnergy[0])));\n                                    activationEnergy = new ActivationEnergy(getAttributes(xml_activationEnergy[0]), value);\n                                }\n                            }\n                            let tInfinity: TInfinity | undefined;\n                            let xml_tInfinity: HTMLCollectionOf<Element> = xml_MCRCMethod[0].getElementsByTagName(\"me:TInfinity\");\n                            if (xml_tInfinity != null) {\n                                if (xml_tInfinity[0] != null) {\n                                    let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_tInfinity[0])));\n                                    tInfinity = new NInfinity(getAttributes(xml_tInfinity[0]), value);\n                                }\n                            }\n                            let nInfinity: NInfinity | undefined;\n                            let xml_nInfinity: HTMLCollectionOf<Element> = xml_MCRCMethod[0].getElementsByTagName(\"me:nInfinity\");\n                            if (xml_nInfinity != null) {\n                                if (xml_nInfinity[0] != null) {\n                                    let value: number = parseFloat(getNodeValue(getFirstChildNode(xml_nInfinity[0])));\n                                    nInfinity = new NInfinity(getAttributes(xml_nInfinity[0]), value);\n                                }\n                            }\n                            mCRCMethod = new MesmerILT(attributes, preExponential, activationEnergy, tInfinity, nInfinity);\n                        }\n                    }\n                } else {\n                    mCRCMethod = new MCRCMethod(attributes, name);\n                }\n            }\n            // Load transition state.\n            //console.log(\"Load  transition state...\");\n            let xml_transitionState: HTMLCollectionOf<Element> = xml_reactions[i].getElementsByTagName(\n                'me:transitionState');\n            let transitionState: TransitionState | undefined;\n            if (xml_transitionState.length > 0) {\n                let xml_molecule: Element = xml_transitionState[0].getElementsByTagName('molecule')[0];\n                let moleculeID: string | null = xml_molecule.getAttribute(\"ref\");\n                transitionState = new TransitionState(getAttributes(xml_molecule), get(molecules, moleculeID));\n                //console.log(\"transitionState moleculeID=\" + transitionState.molecule.getID());\n                //console.log(\"transitionState role=\" + transitionState.attributes.get(\"role\"));\n            }\n            // Load tunneling.\n            let xml_tunneling = xml_reactions[i].getElementsByTagName('me:tunneling');\n            let tunneling: Tunneling | undefined;\n            if (xml_tunneling.length > 0) {\n                tunneling = new Tunneling(getAttributes(xml_tunneling[0]));\n            }\n            let reaction = new Reaction(attributes, reactionID, reactants, products,\n                mCRCMethod, transitionState, tunneling);\n            reactions.set(reactionID, reaction);\n            //console.log(\"reaction=\" + reaction);\n        }\n    }\n}\n\n/**\n * Create a diagram.\n * @param {Map<string, Molecule>} molecules The molecules.\n * @param {Map<string, Reaction>} reactions The reactions.\n * @param {boolean} dark True for dark mode.\n * @returns {HTMLCanvasElement} The diagram.\n * @param {string} font The font to use.\n * @param {number} lw The line width of reactants, transition states and products.\n * @param {string} lwc The line width color to use.\n */\nfunction drawReactionDiagram(canvas: HTMLCanvasElement, molecules: Map<string, Molecule>,\n    reactions: Map<string, Reaction>, dark: boolean, font: string, lw: number, lwc: number): void {\n    console.log(\"drawReactionDiagram\");\n    // TODO: Set styles depending on dark/light mode settings of users browser and not hard code.\n    //let white = \"white\";\n    let black = \"black\";\n    let green = \"green\";\n    let red = \"red\";\n    let blue = \"blue\";\n    //let yellow = \"yellow\";\n    let orange = \"orange\";\n    let background = \"black\";\n    let foreground = \"white\";\n    const ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    //ctx.fillStyle = background;\n\n    // Get text height for font size.\n    let th = getTextHeight(ctx, \"Aj\", font);\n    //console.log(\"th=\" + th);\n\n    // Go through reactions:\n    // 1. Create sets of reactants, end products, intermediate products and transition states.\n    // 2. Create maps of orders and energies.\n    // 3. Calculate maximum energy.\n    let reactants: Set<string> = new Set();\n    let products: Set<string> = new Set();\n    let intProducts: Set<string> = new Set();\n    let transitionStates: Set<string> = new Set();\n    let orders: Map<string, number> = new Map();\n    let energies: Map<string, number> = new Map();\n    let i: number = 0;\n    let energyMin: number = Number.MAX_VALUE;\n    let energyMax: number = Number.MIN_VALUE;\n    reactions.forEach(function (reaction, id) {\n        // Get TransitionState if there is one.\n        let transitionState: TransitionState | undefined = reaction.transitionState;\n        //console.log(\"reactant=\" + reactant);\n        let reactantsLabel: string = reaction.getReactantsLabel();\n        reactants.add(reactantsLabel);\n        if (products.has(reactantsLabel)) {\n            intProducts.add(reactantsLabel);\n        }\n        let energy: number = reaction.getReactantsEnergy();\n        energyMin = Math.min(energyMin, energy);\n        energyMax = Math.max(energyMax, energy);\n        energies.set(reactantsLabel, energy);\n        let productsLabel: string = reaction.getProductsLabel();\n        products.add(productsLabel);\n        energy = reaction.getProductsEnergy();\n        energyMin = Math.min(energyMin, energy);\n        energyMax = Math.max(energyMax, energy);\n        energies.set(productsLabel, energy);\n        if (!orders.has(reactantsLabel)) {\n            orders.set(reactantsLabel, i);\n            i++;\n        }\n        if (orders.has(productsLabel)) {\n            i--;\n            let j: number = get(orders, productsLabel);\n            // Move product to end and shift everything back.\n            orders.forEach(function (value, key) {\n                if (value > j) {\n                    orders.set(key, value - 1);\n                }\n            });\n            // Insert transition state.\n            if (transitionState != undefined) {\n                let tsn: string = transitionState.getRef();\n                transitionStates.add(tsn);\n                orders.set(tsn, i);\n                energy = transitionState.molecule.getEnergy();\n                energyMin = Math.min(energyMin, energy);\n                energyMax = Math.max(energyMax, energy);\n                energies.set(tsn, energy);\n                i++;\n            }\n            orders.set(productsLabel, i);\n            i++\n        } else {\n            if (transitionState != undefined) {\n                let tsn: string = transitionState.getRef();\n                transitionStates.add(tsn);\n                orders.set(tsn, i);\n                energy = transitionState.molecule.getEnergy();\n                energyMin = Math.min(energyMin, energy);\n                energyMax = Math.max(energyMax, energy);\n                energies.set(tsn, energy);\n                i++;\n            }\n            orders.set(productsLabel, i);\n            i++;\n        }\n    });\n    //console.log(\"orders=\" + mapToString(orders));\n    //console.log(\"energies=\" + mapToString(energies));\n    //console.log(\"energyMax=\" + energyMax);\n    //console.log(\"energyMin=\" + energyMin);\n    let energyRange: number = energyMax - energyMin;\n    //console.log(\"energyRange=\" + energyRange);\n    //console.log(\"reactants=\" + reactants);\n    //console.log(\"products=\" + products);\n    //console.log(\"transitionStates=\" + transitionStates);\n\n    // Create a lookup from order to label.\n    let reorders: string[] = [];\n    orders.forEach(function (value, key) {\n        reorders[value] = key;\n    });\n    //console.log(\"reorders=\" + arrayToString(reorders));\n\n    // Iterate through the reorders:\n    // 1. Capture coordinates for connecting lines.\n    // 2. Store maximum x.\n    let x0: number = 0;\n    let y0: number;\n    let x1: number;\n    let y1: number;\n    let xmax: number = 0;\n    let tw: number;\n    let textSpacing: number = 5; // Spacing between end of line and start of text.\n    let stepSpacing: number = 10; // Spacing between steps.\n    let reactantsInXY: Map<string, number[]> = new Map();\n    let reactantsOutXY: Map<string, number[]> = new Map();\n    let productsInXY: Map<string, number[]> = new Map();\n    let productsOutXY: Map<string, number[]> = new Map();\n    let transitionStatesInXY: Map<string, number[]> = new Map();\n    let transitionStatesOutXY: Map<string, number[]> = new Map();\n    reorders.forEach(function (value) {\n        //console.log(\"value=\" + value + \".\");\n        //console.log(\"energies=\" + mapToString(energies));\n        let energy: number = get(energies, value);\n        let energyRescaled: number = rescale(energyMin, energyRange, 0, canvas.height, energy);\n        // Get text width.\n        tw = Math.max(getTextWidth(ctx, energy.toString(), font), getTextWidth(ctx, value, font));\n        x1 = x0 + tw + textSpacing;\n        y0 = energyRescaled + lw;\n        y1 = y0;\n        // Draw horizontal line and add label.\n        // (The drawing is now not done here but done later so labels are on top of lines.)\n        // The code is left here commented out for reference.\n        //drawLevel(ctx, green, 4, x0, y0, x1, y1, th, value);\n        reactantsInXY.set(value, [x0, y0]);\n        reactantsOutXY.set(value, [x1, y1]);\n        if (products.has(value)) {\n            productsInXY.set(value, [x0, y0]);\n            productsOutXY.set(value, [x1, y1]);\n        }\n        if (transitionStates.has(value)) {\n            transitionStatesInXY.set(value, [x0, y0]);\n            transitionStatesOutXY.set(value, [x1, y1]);\n        }\n        x0 = x1 + stepSpacing;\n        xmax = x1;\n    });\n\n    // Set canvas width to maximum x.\n    canvas.width = xmax;\n    //console.log(\"canvas.width=\" + canvas.width);\n\n    // Set canvas height to maximum energy plus the label.\n    let canvasHeightWithBorder = canvas.height + (4 * th) + (2 * lw);\n    //console.log(\"canvasHeightWithBorder=\" + canvasHeightWithBorder);\n\n    let originalCanvasHeight = canvas.height;\n\n    // Update the canvas height.\n    canvas.height = canvasHeightWithBorder;\n\n    // Set the transformation matrix.\n    //ctx.transform(1, 0, 0, 1, 0, canvasHeightWithBorder);\n    ctx.transform(1, 0, 0, -1, 0, canvasHeightWithBorder)\n\n\n    // Go through reactions and draw connecting lines.\n    reactions.forEach(function (reaction, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"reaction=\" + reaction);\n        // Get TransitionState if there is one.\n        let transitionState: TransitionState | undefined = reaction.transitionState;\n        //console.log(\"reactant=\" + reactant);\n        let reactantsLabel: string = reaction.getReactantsLabel();\n        let productsLabel: string = reaction.getProductsLabel();\n        let reactantOutXY: number[] = get(reactantsOutXY, reactantsLabel);\n        let productInXY: number[] = get(productsInXY, productsLabel);\n        if (transitionState != undefined) {\n            let transitionStateLabel: string = transitionState.getRef();\n            let transitionStateInXY: number[] = get(transitionStatesInXY, transitionStateLabel);\n            drawLine(ctx, black, lwc, reactantOutXY[0], reactantOutXY[1], transitionStateInXY[0],\n                transitionStateInXY[1]);\n            let transitionStateOutXY: number[] = get(transitionStatesOutXY, transitionStateLabel);\n            drawLine(ctx, black, lwc, transitionStateOutXY[0], transitionStateOutXY[1],\n                productInXY[0], productInXY[1]);\n        } else {\n            drawLine(ctx, black, lwc, reactantOutXY[0], reactantOutXY[1],\n                productInXY[0], productInXY[1]);\n        }\n    });\n\n    // Draw horizontal lines and labels.\n    // (This is done last so that the labels are on top of the vertical lines.)\n    reactants.forEach(function (value) {\n        let energy: number = get(energies, value);\n        let energyRescaled: number = rescale(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0: number = get(reactantsInXY, value)[0];\n        let y: number = energyRescaled + lw;\n        let x1: number = get(reactantsOutXY, value)[0];\n        let energyString: string = energy.toString();\n        drawLevel(ctx, blue, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n    products.forEach(function (value) {\n        let energy: number = get(energies, value);\n        let energyRescaled: number = rescale(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0: number = get(productsInXY, value)[0];\n        let y: number = energyRescaled + lw;\n        let x1: number = get(productsOutXY, value)[0];\n        let energyString: string = energy.toString();\n        if (intProducts.has(value)) {\n            drawLevel(ctx, orange, lw, x0, y, x1, y, font, th, value, energyString);\n        } else {\n            drawLevel(ctx, green, lw, x0, y, x1, y, font, th, value, energyString);\n        }\n    });\n    transitionStates.forEach(function (value) {\n        let v: any;\n        let energy: number = get(energies, value);\n        let energyRescaled: number = rescale(energyMin, energyRange, 0, originalCanvasHeight, energy);\n        let x0: number = get(transitionStatesInXY, value)[0];\n        let y: number = energyRescaled + lw;\n        let x1: number = get(transitionStatesOutXY, value)[0];\n        let energyString: string = energy.toString();\n        drawLevel(ctx, red, lw, x0, y, x1, y, font, th, value, energyString);\n    });\n}\n\n/**\n * Display molecules table.\n */\nfunction displayMoleculesTable(): void {\n    if (molecules.size == 0) {\n        return;\n    }\n    // Prepare table headings.\n    let moleculesTable = getTH([\n        \"Name\",\n        \"Energy<br>kJ/mol\",\n        \"Rotation constants<br>cm<sup>-1</sup>\",\n        \"Vibration frequencies<br>cm<sup>-1</sup>\"]);\n    molecules.forEach(function (molecule, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"molecule=\" + molecule);\n        let energyNumber: number = molecule.getEnergy();\n        let energy: string;\n        if (energyNumber == null) {\n            energy = \"\";\n        } else {\n            energy = energyNumber.toString();\n        }\n        //console.log(\"energy=\" + energy);\n        let rotationConstants: string = \"\";\n        let rotConsts: number[] | undefined = molecule.getRotationConstants();\n        if (rotConsts != undefined) {\n            rotationConstants = arrayToString(rotConsts, \" \");\n        }\n        let vibrationFrequencies: string = \"\";\n        let vibFreqs: number[] | undefined = molecule.getVibrationFrequencies();\n        if (vibFreqs != undefined) {\n            vibrationFrequencies = arrayToString(vibFreqs, \" \");\n        }\n        moleculesTable += getTR(getTD(id)\n            + getTD(getInput(\"number\", id + \"_energy\", \"setEnergy(this)\", energy))\n            + getTD(rotationConstants, true)\n            + getTD(vibrationFrequencies, true));\n    });\n    molecules_table = document.getElementById(\"molecules_table\");\n    if (molecules_table !== null) {\n        molecules_table.innerHTML = moleculesTable;\n    }\n}\n\n/**\n * Display reactions table.\n */\nfunction displayReactionsTable(): void {\n    if (reactions.size == 0) {\n        return;\n    }\n    // Prepare table headings.\n    let reactionsTable = getTH([\"ID\", \"Reactants\", \"Products\", \"Transition State\",\n        \"PreExponential\", \"Activation Energy\", \"TInfinity\", \"NInfinity\"]);\n    reactions.forEach(function (reaction, id) {\n        //console.log(\"id=\" + id);\n        //console.log(\"reaction=\" + reaction);\n        let reactants: string = arrayToString(Array.from(reaction.reactants.keys()), \" \");\n        let products: string = arrayToString(Array.from(reaction.products.keys()), \" \");\n        let transitionState: string = \"\";\n        let preExponential: string = \"\";\n        let activationEnergy: string = \"\";\n        let tInfinity: string = \"\";\n        let nInfinity: string = \"\";\n        if (reaction.transitionState != undefined) {\n            let name: string | undefined = reaction.transitionState.attributes.get(\"name\");\n            if (name != null) {\n                transitionState = name;\n            }\n        }\n        if (reaction.mCRCMethod != undefined) {\n            if (reaction.mCRCMethod instanceof MesmerILT) {\n                if (reaction.mCRCMethod.preExponential != null) {\n                    preExponential = reaction.mCRCMethod.preExponential.value.toString() + \" \"\n                        + reaction.mCRCMethod.preExponential.attributes.get(\"units\");\n                }\n                if (reaction.mCRCMethod.activationEnergy != null) {\n                    activationEnergy = reaction.mCRCMethod.activationEnergy.value.toString() + \" \"\n                        + reaction.mCRCMethod.activationEnergy.attributes.get(\"units\");\n                }\n                if (reaction.mCRCMethod.tInfinity != null) {\n                    tInfinity = reaction.mCRCMethod.tInfinity.toString();\n                }\n                if (reaction.mCRCMethod.nInfinity != null) {\n                    nInfinity = reaction.mCRCMethod.nInfinity.value.toString();\n                }\n            } else {\n                if (reaction.mCRCMethod.attributes.get(\"name\") == \"RRKM\") {\n                } else {\n                    throw new Error(\"Unexpected mCRCMethod: \" + reaction.mCRCMethod);\n                }\n            }\n        }\n        reactionsTable += getTR(getTD(id) + getTD(reactants) + getTD(products) + getTD(transitionState)\n            + getTD(preExponential, true) + getTD(activationEnergy, true) + getTD(tInfinity, true)\n            + getTD(nInfinity, true));\n        reactions_table = document.getElementById(\"reactions_table\");\n        if (reactions_table !== null) {\n            reactions_table.innerHTML = reactionsTable;\n        }\n    });\n}\n\n/**\n * Display reactions diagram.\n */\nfunction displayReactionsDiagram(): void {\n    if (reactions.size > 1) {\n        // Set reactions_diagram_title.\n        reactions_diagram_title = document.getElementById(\"reactions_diagram_title\");\n        if (reactions_diagram_title != null) {\n            reactions_diagram_title.innerHTML = \"Diagram\";\n        }\n        // Display the diagram.\n        let canvas: HTMLCanvasElement | null = document.getElementById(\"reactions_diagram\") as HTMLCanvasElement;\n        let font: string = \"14px Arial\";\n        let dark: boolean = true;\n        let lw: number = 4;\n        let lwc: number = 2;\n        if (canvas != null) {\n            canvas.style.display = \"block\";\n            drawReactionDiagram(canvas, molecules, reactions, dark, font, lw, lwc);\n        }\n    }\n}\n\n/**\n * Display conditions.\n */\nfunction displayConditions(): void {\n    let bathGas_element: HTMLElement | null = document.getElementById(\"bathGas\");\n    if (bathGas_element != null) {\n        bathGas_element.innerHTML = \"Bath Gas \" + conditions.bathGas.molecule.getID();\n    }\n    let PTs_element: HTMLElement | null = document.getElementById(\"PT_table\");\n    let table: string = getTH([\"P\", \"T\"]);\n    if (PTs_element != null) {\n        conditions.pTs.forEach(function (pTpair) {\n            table += getTR(getTD(pTpair.P.toString()) + getTD(pTpair.T.toString()));\n        });\n        PTs_element.innerHTML = table;\n    }\n}\n\n/**\n * Display modelParameters.\n */\nfunction displayModelParameters(): void {\n    let modelParameters_element: HTMLElement | null = document.getElementById(\"modelParameters_table\");\n    let table: string = getTH([\"Parameter\", \"Value\"]);\n    table += getTR(getTD(\"Grain Size\") + getTD(modelParameters.grainSize.value.toString()));\n    table += getTR(getTD(\"Energy Above The Top Hill\") + getTD(modelParameters.energyAboveTheTopHill.toString()));\n\n    if (modelParameters_element != null) {\n        modelParameters_element.innerHTML = table;\n    }\n}\n\n/**\n * Display control.\n */\nfunction displayControl(): void {\n    let control_table_element: HTMLElement | null = document.getElementById(\"control_table\");\n    let table: string = getTH([\"Control\", \"Value\"]);\n    if (control.testDOS != undefined) {\n        table += getTR(getTD(\"me.testDOS\") + getTD(\"\"));\n    }\n    if (control.printSpeciesProfile != undefined) {\n        table += getTR(getTD(\"me.printSpeciesProfile\") + getTD(\"\"));\n    }\n    if (control.testMicroRates != undefined) {\n        table += getTR(getTD(\"me.testMicroRates\") + getTD(\"\"));\n    }\n    if (control.testRateConstant != undefined) {\n        table += getTR(getTD(\"me.testRateConstant\") + getTD(\"\"));\n    }\n    if (control.printGrainDOS != undefined) {\n        table += getTR(getTD(\"me.printGrainDOS\") + getTD(\"\"));\n    }\n    if (control.printCellDOS != undefined) {\n        table += getTR(getTD(\"me.printCellDOS\") + getTD(\"\"));\n    }\n    if (control.printReactionOperatorColumnSums != undefined) {\n        table += getTR(getTD(\"me.printReactionOperatorColumnSums\") + getTD(\"\"));\n    }\n    if (control.printTunnellingCoefficients != undefined) {\n        table += getTR(getTD(\"me.printTunnellingCoefficients\") + getTD(\"\"));\n    }\n    if (control.printGrainkfE != undefined) {\n        table += getTR(getTD(\"me.printGrainkfE\") + getTD(\"\"));\n    }\n    if (control.printGrainBoltzmann != undefined) {\n        table += getTR(getTD(\"me.printGrainBoltzmann\") + getTD(\"\"));\n    }\n    if (control.printGrainkbE != undefined) {\n        table += getTR(getTD(\"me.printGrainkbE\") + getTD(\"\"));\n    }\n    if (control.eigenvalues != undefined) {\n        table += getTR(getTD(\"me.eigenvalues\") + getTD(control.eigenvalues.toString()));\n    }\n    if (control.hideInactive != undefined) {\n        table += getTR(getTD(\"me.hideInactive\") + getTD(\"\"));\n    }\n    if (control.diagramEnergyOffset != undefined) {\n        table += getTR(getTD(\"me.diagramEnergyOffset\") + getTD(control.diagramEnergyOffset.value.toString()));\n    }\n    if (control_table_element != null) {\n        control_table_element.innerHTML = table;\n    }\n}\n\n/**\n * Set the energy of a molecule when the energy input value is changed.\n * @param input The input element. \n */\nexport function setEnergy(input: HTMLInputElement): void {\n    let id_energy: string = input.id;\n    let moleculeID: string = id_energy.split(\"_\")[0];\n    let molecule: Molecule | undefined = molecules.get(moleculeID);\n    if (molecule != undefined) {\n        let inputValue: number = parseFloat(input.value);\n        if (!isNaN(inputValue)) {\n            molecule.setEnergy(inputValue);\n            console.log(\"Energy of \" + moleculeID + \" set to \" + inputValue);\n        } else {\n            alert(\"Energy input for \" + moleculeID + \" is not a number\");\n            let inputElement = document.getElementById(id_energy) as HTMLInputElement;\n            inputElement.value = molecule.getEnergy().toString();\n        }\n        //console.log(\"molecule=\" + molecule);\n    }\n}\n\n(window as any).setEnergy = setEnergy;\n\n/**\n * Save to XML file.\n */\nwindow.saveXML = function () {\n    console.log(\"saveXML\");\n\n    const pad: string = \"  \";\n    let level: number;\n    const padding2: string = pad.repeat(2);\n\n    // Create me.title.\n    let title_xml = \"\\n\" + pad + getTag(title, \"me:title\");\n\n    // Create moleculeList.\n    level = 2;\n    let moleculeList: string = \"\";\n    molecules.forEach(function (molecule, id) {\n        moleculeList += molecule.toXML(\"molecule\", pad, level);\n    });\n    moleculeList = getTag(moleculeList, \"moleculeList\", undefined, undefined, undefined, pad, true);\n\n    // Create reactionList.\n    level = 2;\n    let reactionList: string = \"\";\n    reactions.forEach(function (reaction, id) {\n        reactionList += reaction.toXML(\"reaction\", pad, level);\n    });\n    reactionList = getTag(reactionList, \"reactionList\", undefined, undefined, undefined, pad, true);\n\n    // Create me.Conditions\n    let xml_conditions: string = conditions.toXML(pad, pad);\n\n    // Create modelParameters\n    let xml_modelParameters: string = modelParameters.toXML(pad, pad);\n\n    // create me.control\n    let xml_control: string = control.toXML(pad, pad);\n\n    // Create a new Blob object from the data\n    let blob = new Blob([header, mesmerStartTag, title_xml, moleculeList, reactionList,\n        xml_conditions, xml_modelParameters, xml_control, mesmerEndTag],\n        { type: \"text/plain\" });\n\n    // Create a new object URL for the blob\n    let url = URL.createObjectURL(blob);\n\n    // Create a new 'a' element\n    let a = document.createElement(\"a\");\n\n    // Set the href and download attributes for the 'a' element\n    a.href = url;\n    a.download = input_xml_filename; // Replace with your desired filename\n\n    // Append the 'a' element to the body and click it to start the download\n    document.body.appendChild(a);\n    a.click();\n\n    // Remove the 'a' element after the download starts\n    document.body.removeChild(a);\n\n}","/**\n * Thow an error if the key is not in the map otherwise return the value mapped to the key.\n * @param map The map to search in.\n * @param key The key to search for.\n * @returns The value mapped to the key.\n * @throws An error if the key is not in the map.\n */\nexport function get(map, key) {\n    if (!map.has(key)) {\n        throw new Error(`Key ${key} not found in map`);\n    }\n    return map.get(key);\n}\n/**\n * Linearly rescale a value from one range to another.\n * @param min The minimum value of the original range.\n * @param range The original range.\n * @param newMin The minimum value of the new range.\n * @param newRange The new range.\n * @param value The value to rescale.\n * @returns The rescaled value.\n */\nexport function rescale(min, range, newMin, newRange, value) {\n    // The + 0.0 is to force the division to be a floating point division.\n    //return (((value - min) / (range + 0.0)) * (newRange)) + newMin;\n    return ((value - min) * (newRange) / (range + 0.0)) + newMin;\n}\n//# sourceMappingURL=util.js.map","/**\n * Thow an error if the key is not in the map otherwise return the value mapped to the key.\n * @param map The map to search in. \n * @param key The key to search for.\n * @returns The value mapped to the key.\n * @throws An error if the key is not in the map.\n */\nexport function get(map: Map<any, any>, key: any): any {\n    if (!map.has(key)) {\n        throw new Error(`Key ${key} not found in map`);\n    }\n    return map.get(key);\n}\n\n/**\n * Linearly rescale a value from one range to another.\n * @param min The minimum value of the original range.\n * @param range The original range.\n * @param newMin The minimum value of the new range.\n * @param newRange The new range.\n * @param value The value to rescale.\n * @returns The rescaled value.\n */\nexport function rescale(min: number, range: number, newMin: number, newRange: number, value: number): number {\n    // The + 0.0 is to force the division to be a floating point division.\n    //return (((value - min) / (range + 0.0)) * (newRange)) + newMin;\n    return ((value - min) * (newRange) / (range + 0.0) ) + newMin;\n}","/**\n * Get the attribute of an xml element.\n * @param xml The xml element to search in.\n * @param name The name of the attribute to search for.\n * @returns The value of the attribute.\n * @throws An error if the attribute is not found.\n */\nexport function getAttribute(xml, name) {\n    let v = xml.getAttribute(name);\n    if (!v) {\n        throw new Error(name + ' attribute not found');\n    }\n    return v;\n}\n/**\n * Get the first element in element with a tag name tagName.\n * @param element The xml element to search in.\n * @param tagName The tag name of the elements to search for.\n * @returns The first element in element with a tag name tagName.\n * @throws An error if the element is not found.\n */\nexport function getFirstElement(element, tagName) {\n    let el = element.getElementsByTagName(tagName)[0];\n    if (el == null) {\n        throw new Error(tagName + ' element not found');\n    }\n    return el;\n}\n/**\n * Get the first childNode.\n * @param {Element} element The xml element to search in.\n * @returns {ChildNode} The first ChildNode if there is one.\n * @throws An error if the element has no childNodes.\n */\nexport function getFirstChildNode(element) {\n    let cn = element.childNodes;\n    if (cn == null) {\n        throw new Error('Element has no childNodes');\n    }\n    return cn[0];\n}\n/**\n * Get the nodeValue of a ChildNode.\n * @param {ChildNode} node The node to get the nodeValue of.\n * @returns {string} The nodeValue of the node.\n * @throws An error if the nodeValue is null.\n */\nexport function getNodeValue(node) {\n    let nodeValue = node.nodeValue;\n    if (nodeValue == null) {\n        throw new Error('nodeValue is null');\n    }\n    return nodeValue;\n}\n/**\n * Create and return a XML start tag. For multiple attributes, pass them in a map.\n * If there is only one, then pass the name and value as separate parameters.\n * @param tagName The tag name.\n * @param {Map<string, any>} attributes The attributes (optional).\n * @param {string} attributeName The name of the attribute (optional).\n * @param {any} attributeValue The value of the attribute (optional).\n * @param {string} padding The padding (optional).\n * @returns The XML start tag.\n */\nexport function getStartTag(tagName, attributes, attributeName, attributeValue, padding) {\n    let s = \"\";\n    if (padding != undefined) {\n        s += \"\\n\" + padding;\n    }\n    s += '<' + tagName;\n    if (attributes) {\n        for (let [k, v] of attributes) {\n            s += ' ' + k + '=\"' + v.toString() + '\"';\n        }\n    }\n    if (attributeName && attributeValue) {\n        s += ' ' + attributeName + '=\"' + attributeValue.toString() + '\"';\n    }\n    return s + '>';\n}\n/**\n * Create and return an XML end tag.\n * @param tagName The tag name.\n * @param padding The padding (optional).\n * @param padValue Whether to pad the value (optional).\n * @returns The XML end tag.\n */\nexport function getEndTag(tagName, padding, padValue) {\n    let s = \"\";\n    if (padValue) {\n        if (padding != undefined) {\n            s += \"\\n\" + padding;\n        }\n    }\n    return s + '</' + tagName + '>';\n}\n/**\n * Create and return an XML tag with content. For multiple attributes, pass them in a map.\n * If there is only one, then pass the name and value as separate parameters.\n * @param content The content of the tag.\n * @param tagName The tag name.\n * @param delimeter Whether values are delimeted.\n * @param {Map<string, any>} attributes The attributes (optional).\n * @param {string} attributeName The name of the attribute (optional).\n * @param {any} attributeValue The value of the attribute (optional).\n * @param {string} padding The padding (optional).\n * @param {boolean} padValue Whether to pad the value (optional).\n * @returns The XML tag with content.\n */\nexport function getTag(content, tagName, attributes, attributeName, attributeValue, padding, padValue) {\n    let startTag = getStartTag(tagName, attributes, attributeName, attributeValue, padding);\n    let endTag = getEndTag(tagName, padding, padValue);\n    return startTag + content + endTag;\n}\n/**\n * Get the attributes of an element.\n * @param {Element} element The element to get the attributes of.\n * @returns {Map<string, string>} The attributes of the element.\n */\nexport function getAttributes(element) {\n    let attributeNames = element.getAttributeNames();\n    let attributes = new Map();\n    attributeNames.forEach(function (attributeName) {\n        let attributeValue = element.getAttribute(attributeName);\n        if (attributeValue != null) {\n            attributes.set(attributeName, attributeValue);\n            //console.log(\"attributeName=\" + attributeName + \" attributeValue=\" + attributeValue);\n        }\n    });\n    return attributes;\n}\n/**\n * Get an XML element checking that it is the only one with a given tagName.\n * @param {XMLDocument | Element} xml The XML document or element.\n * @param {string} tagName The tag name.\n * @returns {Element} The element.\n * @throws An error if there is not exactly one element with the given tag name.\n */\nexport function getSingularElement(xml, tagName) {\n    ;\n    let e = xml.getElementsByTagName(tagName);\n    if (e.length != 1) {\n        throw new Error(\"Expecting 1 \" + tagName + \" but finding \" + e.length);\n    }\n    return e[0];\n}\n/**\n * Convert XML to HTML.\n * @param {string} text The XML text.\n */\nexport function toHTML(text) {\n    return text.replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\\n/g, \"<br>\")\n        .replace(/\\t/g, \"&nbsp;&nbsp;&nbsp;&nbsp;\")\n        .replace(/  /g, \"&nbsp;&nbsp;\");\n}\n//# sourceMappingURL=xml.js.map","/**\n * Get the attribute of an xml element.\n * @param xml The xml element to search in.\n * @param name The name of the attribute to search for.\n * @returns The value of the attribute.\n * @throws An error if the attribute is not found.\n */\nexport function getAttribute(xml: Element, name: string): string {\n    let v: string | null = xml.getAttribute(name);\n    if (!v) {\n        throw new Error(name + ' attribute not found');\n    }\n    return v;\n}\n\n/**\n * Get the first element in element with a tag name tagName.\n * @param element The xml element to search in.\n * @param tagName The tag name of the elements to search for.\n * @returns The first element in element with a tag name tagName.\n * @throws An error if the element is not found.\n */\nexport function getFirstElement(element: Element, tagName: string): Element {\n    let el: Element | null = element.getElementsByTagName(tagName)[0];\n    if (el == null) {\n        throw new Error(tagName + ' element not found');\n    }\n    return el;\n}\n\n/**\n * Get the first childNode.\n * @param {Element} element The xml element to search in.\n * @returns {ChildNode} The first ChildNode if there is one.\n * @throws An error if the element has no childNodes.\n */\nexport function getFirstChildNode(element: Element): ChildNode {\n    let cn: NodeListOf<ChildNode> = element.childNodes;\n    if (cn == null) {\n        throw new Error('Element has no childNodes');\n    }\n    return cn[0];\n}\n\n/**\n * Get the nodeValue of a ChildNode.\n * @param {ChildNode} node The node to get the nodeValue of.\n * @returns {string} The nodeValue of the node.\n * @throws An error if the nodeValue is null.\n */\nexport function getNodeValue(node: ChildNode): string {\n    let nodeValue: string | null = node.nodeValue;\n    if (nodeValue == null) {\n        throw new Error('nodeValue is null');\n    }\n    return nodeValue;\n}\n\n/**\n * Create and return a XML start tag. For multiple attributes, pass them in a map.\n * If there is only one, then pass the name and value as separate parameters.\n * @param tagName The tag name.\n * @param {Map<string, any>} attributes The attributes (optional).\n * @param {string} attributeName The name of the attribute (optional).\n * @param {any} attributeValue The value of the attribute (optional).\n * @param {string} padding The padding (optional).\n * @returns The XML start tag.\n */\nexport function getStartTag(tagName: string, attributes?: Map<string, any>,\n    attributeName?: string, attributeValue?: any, padding?: string): string {\n    let s: string = \"\";\n    if (padding != undefined) {\n        s += \"\\n\" + padding;\n    }\n    s += '<' + tagName;\n    if (attributes) {\n        for (let [k, v] of attributes) {\n            s += ' ' + k + '=\"' + v.toString() + '\"';\n        }\n    }\n    if (attributeName && attributeValue) {\n        s += ' ' + attributeName + '=\"' + attributeValue.toString() + '\"';\n    }\n    return s + '>';\n}\n\n/**\n * Create and return an XML end tag.\n * @param tagName The tag name.\n * @param padding The padding (optional).\n * @param padValue Whether to pad the value (optional).\n * @returns The XML end tag.\n */\nexport function getEndTag(tagName: string, padding?: string, padValue?: boolean): string {\n    let s: string = \"\";\n    if (padValue) {\n        if (padding != undefined) {\n            s += \"\\n\" + padding;\n        }\n    }\n    return s + '</' + tagName + '>';\n}\n\n/**\n * Create and return an XML tag with content. For multiple attributes, pass them in a map.\n * If there is only one, then pass the name and value as separate parameters.\n * @param content The content of the tag.\n * @param tagName The tag name.\n * @param delimeter Whether values are delimeted.\n * @param {Map<string, any>} attributes The attributes (optional).\n * @param {string} attributeName The name of the attribute (optional).\n * @param {any} attributeValue The value of the attribute (optional).\n * @param {string} padding The padding (optional).\n * @param {boolean} padValue Whether to pad the value (optional).\n * @returns The XML tag with content.\n */\nexport function getTag(content: string, tagName: string, attributes?: Map<string, any>,\n    attributeName?: string, attributeValue?: any, padding?: string, padValue?: boolean): string {\n    let startTag: string = getStartTag(tagName, attributes, attributeName, attributeValue, padding);\n    let endTag: string = getEndTag(tagName, padding, padValue);\n    return startTag + content + endTag;\n}\n\n/**\n * Get the attributes of an element.\n * @param {Element} element The element to get the attributes of.\n * @returns {Map<string, string>} The attributes of the element.\n */\nexport function getAttributes(element: Element): Map<string, string> {\n    let attributeNames: string[] = element.getAttributeNames();\n    let attributes: Map<string, string> = new Map();\n    attributeNames.forEach(function (attributeName) {\n        let attributeValue: string | null = element.getAttribute(attributeName);\n        if (attributeValue != null) {\n            attributes.set(attributeName, attributeValue);\n            //console.log(\"attributeName=\" + attributeName + \" attributeValue=\" + attributeValue);\n        }\n    });\n    return attributes;\n}\n\n/**\n * Get an XML element checking that it is the only one with a given tagName.\n * @param {XMLDocument | Element} xml The XML document or element.\n * @param {string} tagName The tag name.\n * @returns {Element} The element.\n * @throws An error if there is not exactly one element with the given tag name.\n */\nexport function getSingularElement(xml: XMLDocument | Element, tagName: string): Element {;\n    let e: HTMLCollectionOf<Element> = xml.getElementsByTagName(tagName);\n    if (e.length != 1) {\n        throw new Error(\"Expecting 1 \" + tagName + \" but finding \" + e.length);\n    }\n    return e[0];\n}\n\n/**\n * Convert XML to HTML.\n * @param {string} text The XML text.\n */\nexport function toHTML(text: string): string {\n    return text.replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\\n/g, \"<br>\")\n        .replace(/\\t/g, \"&nbsp;&nbsp;&nbsp;&nbsp;\")\n        .replace(/  /g, \"&nbsp;&nbsp;\");\n}","import { Attributes, NumberArrayWithAttributes, NumberWithAttributes } from './classes.js';\nimport { mapToString } from './functions.js';\nimport { getTag } from './xml.js';\n/**\n * A class for representing an atom.\n * @param {Map<string, string>} attributes The attributes.\n * If there is no \"id\" or \"elementType\" key an error will be thrown.\n */\nexport class Atom extends Attributes {\n    /**\n     * @param attributes The attributes. If there is no \"id\" or \"elementType\" key an error will be thrown.\n     */\n    constructor(attributes) {\n        super(attributes);\n        let id = attributes.get(\"id\");\n        if (id == undefined) {\n            throw new Error('id is undefined');\n        }\n        let elementType = attributes.get(\"elementType\");\n        if (elementType == undefined) {\n            throw new Error('elementType is undefined');\n        }\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        let s = super.toString();\n        return s + `)`;\n    }\n    /**\n     * @returns The id of the atom.\n     */\n    get id() {\n        return this.attributes.get(\"id\");\n    }\n    /**\n     * @returns The element type of the atom.\n     */\n    get elementType() {\n        return this.attributes.get(\"elementType\");\n    }\n}\n/**\n * A class for representing an atomic bond - a bond beteen two atoms.\n * @param {Map<string, string>} attributes The attributes.\n * @param {Atom} atomA One atom.\n * @param {Atom} atomB Another atom.\n * @param {string} order The order of the bond.\n */\nexport class Bond extends Attributes {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */\n    constructor(attributes) {\n        super(attributes);\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        let s = super.toString();\n        return s + `)`;\n    }\n}\n/**\n * A class for representing a property.\n */\nexport class Property extends Attributes {\n    /**\n     * The property value.\n     */\n    property;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {NumberWithAttributes | NumberArrayWithAttributes} property The property.\n     */\n    constructor(attributes, property) {\n        super(attributes);\n        this.property = property;\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        return super.toString() + ` property(${this.property.toString()}))`;\n    }\n    /**\n     * @param padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(pad, padding) {\n        let padding1 = undefined;\n        if (pad != undefined) {\n            if (padding != undefined) {\n                padding1 = padding + pad;\n            }\n        }\n        if (this.property instanceof NumberWithAttributes) {\n            return getTag(this.property.toXML(\"scalar\", padding1), \"property\", this.attributes, undefined, undefined, padding, true);\n        }\n        else {\n            return getTag(this.property.toXML(\"array\", padding1), \"property\", this.attributes, undefined, undefined, padding, true);\n        }\n    }\n}\n/**\n * Represents the deltaEDown class.\n */\nexport class DeltaEDown extends NumberWithAttributes {\n    /**\n     * @param attributes The attributes.\n     * @param units The units.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n}\n/**\n * A class for representing an energy transfer model.\n */\nexport class EnergyTransferModel extends Attributes {\n    /**\n     * The DeltaEDown.\n     */\n    deltaEDown;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {DeltaEDown} deltaEDown The DeltaEDown.\n     */\n    constructor(attributes, deltaEDown) {\n        super(attributes);\n        this.deltaEDown = deltaEDown;\n    }\n    /**\n     * @param padding - Optional padding string for formatting the XML output.\n     * @returns An XML representation.\n     */\n    toXML(pad, padding) {\n        if (pad == undefined) {\n            return getTag(this.deltaEDown.toXML(\"me.deltaEDown\", padding), \"me:energyTransferModel\", this.attributes, undefined, undefined, padding, false);\n        }\n        else {\n            return getTag(this.deltaEDown.toXML(\"me.deltaEDown\", padding), \"energyTransferModel\", undefined, undefined, undefined, padding, true);\n        }\n    }\n}\n/**\n * A class for representing a method for calculating the density of states.\n */\nexport class DOSCMethod {\n    type;\n    constructor(type) {\n        this.type = type;\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        return `DOSCMethod(type(${this.type}))`;\n    }\n    /**\n     * @param padding The padding (Optional).\n     * @returns A tag representation.\n     */\n    toTag(padding) {\n        let s = `<me.DOSCMethod xsi:type=\"${this.type}\"/>`;\n        if (padding) {\n            return \"\\n\" + padding + s;\n        }\n        return \"\\n\" + s;\n    }\n}\n/**\n * A class for representing a molecule.\n * @param {string} id The id of the molecule.\n * @param {string} description The description of the molecule.\n * @param {boolean} active Indicates if the molecule is active.\n * @param {Map<string, Atom>} atoms A Map of atoms with keys as string atom ids and values as Atoms.\n * @param {Map<string, Bond>} bonds A Map of bonds with keys as string atom ids and values as Bonds.\n * @param {Map<string, Property>} properties A map of properties.\n * @param {EnergyTransferModel | null} energyTransferModel The energy transfer model.\n * @param {DOSCMethod | null} dOSCMethod The method for calculating density of states.\n */\nexport class Molecule extends Attributes {\n    id;\n    // Atoms\n    atoms;\n    // Bonds\n    bonds;\n    // Properties\n    properties;\n    // EnergyTransferModel\n    energyTransferModel;\n    // DOSCMethod\n    dOSCMethod;\n    /**\n     * Create a molecule.\n     * @param {Map<string, string>} attributes The attributes. If there is no \"id\" key an error will be thrown.\n     * Additional attributes known about are \"description\" and \"active\", but these do not exist for all molecules\n     * in Mesmer XML input/output files.\n     * @param {Map<string, Atom>} atoms A Map of atoms with keys as ids.\n     * @param {Map<string, Bond>} bonds A Map of bonds with. The keys combine the ids of the two bonded atoms.\n     * @param {Map<string, Property>} properties A map of properties.\n     * @param {EnergyTransferModel | null} energyTransferModel The energy transfer model.\n     * @param {DOSCMethod | null} dOSCMethod The method for calculating density of states.\n     */\n    constructor(attributes, atoms, bonds, properties, energyTransferModel, dOSCMethod) {\n        super(attributes);\n        let id = this.attributes.get(\"id\");\n        if (id == undefined) {\n            throw new Error('id is undefined');\n        }\n        this.id = id;\n        this.atoms = atoms;\n        this.bonds = bonds;\n        this.properties = properties;\n        this.energyTransferModel = energyTransferModel;\n        this.dOSCMethod = dOSCMethod;\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        let r = `Molecule(id(${this.getID()}), `;\n        let description = this.getDescription();\n        if (description != undefined) {\n            r += `description(${description}), `;\n        }\n        let active = this.getActive();\n        if (active != undefined) {\n            r += `active(${active}), `;\n        }\n        if (this.atoms.size > 0) {\n            r += `atoms(${mapToString(this.atoms)}), `;\n        }\n        if (this.bonds.size > 0) {\n            r += `bonds(${mapToString(this.bonds)}), `;\n        }\n        if (this.properties.size > 0) {\n            r += `properties(${mapToString(this.properties)}), `;\n        }\n        if (this.energyTransferModel) {\n            r += `energyTransferModel(${this.energyTransferModel.toString()}), `;\n        }\n        if (this.dOSCMethod) {\n            r += `dOSCMethod(${this.dOSCMethod.toString()}), `;\n        }\n        return r + `)`;\n    }\n    /**\n     * @return The id of the molecule.\n     */\n    getID() {\n        return this.attributes.get(\"id\");\n    }\n    /**\n     * Gets the description of the molecule.\n     * @returns The description of the molecule, or undefined if it is not set.\n     */\n    getDescription() {\n        return this.attributes.get(\"description\");\n    }\n    /**\n     * Gets the active status of the molecule.\n     * @returns The active status of the molecule, or undefined if it is not set.\n     */\n    getActive() {\n        let active = this.attributes.get(\"active\");\n        if (active != undefined) {\n            return true;\n        }\n        return active;\n    }\n    /**\n     * @returns {number} The energy of the molecule or zero if the energy is not set.\n     * @throws An error if \"me.ZPE\" is a property, but is not mapped to a PropertyScalar.\n     */\n    getEnergy() {\n        let zpe = this.properties.get('me:ZPE');\n        if (zpe == undefined) {\n            return 0;\n        }\n        if (zpe.property instanceof NumberWithAttributes) {\n            return zpe.property.value;\n        }\n        else {\n            throw new Error(\"Expected a PropertyScalar but got a PropertyArray and not sure how to handle that.\");\n        }\n    }\n    /**\n     * Set the Energy of the molecule.\n     * @param {number} energy The energy of the molecule in kcal/mol.\n     */\n    setEnergy(energy) {\n        let property = this.properties.get('me:ZPE');\n        if (property == undefined) {\n            throw new Error(\"No me.ZPE property found\");\n        }\n        if (property.property instanceof NumberArrayWithAttributes) {\n            throw new Error(\"Expected a NumberWithAttributes but got a NumberArrayWithAttributes and not sure how to handle that.\");\n        }\n        else {\n            property.property.value = energy;\n        }\n    }\n    /**\n     * Get the RotationConstants of the molecule.\n     * @returns The RotationConstants of the molecule.\n     */\n    getRotationConstants() {\n        let property = this.properties.get('me:rotConsts');\n        if (property != undefined) {\n            if (property.property != null) {\n                if (property.property instanceof NumberWithAttributes) {\n                    return [property.property.value];\n                }\n                else {\n                    return property.property.values;\n                }\n            }\n            else {\n                return undefined;\n            }\n        }\n        return property;\n    }\n    /**\n     * Get the VibrationFrequencies of the molecule.\n     * @returns The VibrationFrequencies of the molecule.\n     */\n    getVibrationFrequencies() {\n        let property = this.properties.get('me:vibFreqs');\n        if (property != undefined) {\n            if (property.property instanceof NumberWithAttributes) {\n                return [property.property.value];\n            }\n            else if (property.property instanceof NumberArrayWithAttributes) {\n                return property.property.values;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return property;\n    }\n    /**\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad (Optional).\n     * @param {number} level The level of padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, pad, level) {\n        // Padding\n        let padding0 = \"\";\n        let padding1 = \"\";\n        let padding2 = \"\";\n        let padding3 = \"\";\n        if (pad != undefined && level != undefined) {\n            padding0 = pad.repeat(level);\n            padding1 = padding0 + pad;\n            padding2 = padding1 + pad;\n            padding3 = padding2 + pad;\n        }\n        // Atoms\n        let atoms_xml = \"\";\n        for (let atom of this.atoms.values()) {\n            atoms_xml += atom.toTag(\"atom\", padding2);\n        }\n        if (this.atoms.size > 1) {\n            if (atoms_xml != \"\") {\n                atoms_xml = getTag(atoms_xml, \"atomArray\", undefined, undefined, undefined, padding1, true);\n            }\n        }\n        // Bonds\n        let bonds_xml = \"\";\n        for (let bond of this.bonds.values()) {\n            bonds_xml += bond.toTag(\"bond\", padding2);\n        }\n        if (bonds_xml != \"\") {\n            bonds_xml = getTag(bonds_xml, \"bondArray\", undefined, undefined, undefined, padding1, true);\n        }\n        // Properties\n        let properties_xml = \"\";\n        this.properties.forEach(property => {\n            let property_xml = \"\";\n            if (property.property instanceof NumberWithAttributes) {\n                property_xml += property.property.toXML(\"scalar\", padding3);\n            }\n            else {\n                property_xml += property.property.toXML(\"array\", padding3);\n            }\n            properties_xml += getTag(property_xml, \"property\", property.attributes, undefined, undefined, padding2, true);\n        });\n        if (this.properties.size > 1) {\n            if (properties_xml != \"\") {\n                properties_xml = getTag(properties_xml, \"propertyList\", undefined, undefined, undefined, padding1, true);\n            }\n        }\n        // EnergyTransferModel\n        let energyTransferModel_xml = \"\";\n        if (this.energyTransferModel) {\n            energyTransferModel_xml = this.energyTransferModel.toXML(pad, padding1);\n        }\n        // DOSCMethod\n        let dOSCMethod_xml = \"\";\n        if (this.dOSCMethod) {\n            dOSCMethod_xml = this.dOSCMethod.toTag(padding1);\n        }\n        return getTag(atoms_xml + bonds_xml + properties_xml + energyTransferModel_xml + dOSCMethod_xml, tagName, this.attributes, undefined, undefined, padding0, true);\n    }\n}\n//# sourceMappingURL=molecule.js.map","import {\n    Attributes, NumberArrayWithAttributes, NumberWithAttributes \n} from './classes.js';\n\nimport {\n    mapToString\n} from './functions.js';\n\nimport {\n    getTag\n} from './xml.js';\n\n/**\n * A class for representing an atom.\n * @param {Map<string, string>} attributes The attributes.\n * If there is no \"id\" or \"elementType\" key an error will be thrown.\n */\nexport class Atom extends Attributes {\n\n    /**\n     * @param attributes The attributes. If there is no \"id\" or \"elementType\" key an error will be thrown.\n     */\n    constructor(attributes: Map<string, string>) {\n        super(attributes);\n        let id: string | undefined = attributes.get(\"id\");\n        if (id == undefined) {\n            throw new Error('id is undefined');\n        }\n        let elementType: string | undefined = attributes.get(\"elementType\");\n        if (elementType == undefined) {\n            throw new Error('elementType is undefined');\n        }\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        let s = super.toString();\n        return s + `)`;\n    }\n\n    /**\n     * @returns The id of the atom.\n     */\n    get id(): string {\n        return this.attributes.get(\"id\") as string;\n    }\n\n    /**\n     * @returns The element type of the atom.\n     */\n    get elementType(): string {\n        return this.attributes.get(\"elementType\") as string;\n    }\n}\n\n/**\n * A class for representing an atomic bond - a bond beteen two atoms.\n * @param {Map<string, string>} attributes The attributes.\n * @param {Atom} atomA One atom.\n * @param {Atom} atomB Another atom.\n * @param {string} order The order of the bond.\n */\nexport class Bond extends Attributes {\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */\n    constructor(attributes: Map<string, string>) {\n        super(attributes);\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        let s = super.toString();\n        return s + `)`;\n    }\n}\n\n\n/**\n * A class for representing a property.\n */\nexport class Property extends Attributes {\n\n    /**\n     * The property value.\n     */\n    property: NumberWithAttributes | NumberArrayWithAttributes;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {NumberWithAttributes | NumberArrayWithAttributes} property The property.\n     */\n    constructor(attributes: Map<string, string>, property: NumberWithAttributes | NumberArrayWithAttributes) {\n        super(attributes);\n        this.property = property;\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        return super.toString() + ` property(${this.property.toString()}))`;\n    }\n\n    /**\n     * @param padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(pad?: string, padding?: string): string {\n        let padding1: string | undefined = undefined;\n        if (pad != undefined) {\n            if (padding != undefined) {\n                padding1 = padding + pad;\n            }\n        }\n        if (this.property instanceof NumberWithAttributes) {\n            return getTag(this.property.toXML(\"scalar\", padding1), \"property\", this.attributes, undefined, undefined, padding, true);\n        } else {\n            return getTag(this.property.toXML(\"array\", padding1), \"property\", this.attributes, undefined, undefined, padding, true);\n        }\n    }\n}\n\n/**\n * Represents the deltaEDown class.\n */\nexport class DeltaEDown extends NumberWithAttributes {\n\n    /**\n     * @param attributes The attributes.\n     * @param units The units.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n}\n\n/**\n * A class for representing an energy transfer model.\n */\nexport class EnergyTransferModel extends Attributes {\n\n    /**\n     * The DeltaEDown.\n     */\n    deltaEDown: DeltaEDown;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {DeltaEDown} deltaEDown The DeltaEDown.\n     */\n    constructor(attributes: Map<string, string>, deltaEDown: DeltaEDown) {\n        super(attributes);\n        this.deltaEDown = deltaEDown;\n    }\n\n    /**\n     * @param padding - Optional padding string for formatting the XML output.\n     * @returns An XML representation.\n     */\n    toXML(pad?: string, padding?: string): string {\n        if (pad == undefined) {\n            return getTag(this.deltaEDown.toXML(\"me.deltaEDown\", padding), \"me:energyTransferModel\",\n             this.attributes, undefined, undefined, padding, false);\n        } else {\n            return getTag(this.deltaEDown.toXML(\"me.deltaEDown\", padding), \"energyTransferModel\",\n             undefined, undefined, undefined, padding, true);\n        }\n    }\n}\n\n/**\n * A class for representing a method for calculating the density of states.\n */\nexport class DOSCMethod {\n    type: string;\n    constructor(type: string) {\n        this.type = type;\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        return `DOSCMethod(type(${this.type}))`;\n    }\n\n    /**\n     * @param padding The padding (Optional).\n     * @returns A tag representation.\n     */\n    toTag(padding?: string): string {\n        let s: string = `<me.DOSCMethod xsi:type=\"${this.type}\"/>`;\n        if (padding) {\n            return \"\\n\" + padding + s;\n        }\n        return \"\\n\" + s;\n    }\n}\n\n/**\n * A class for representing a molecule.\n * @param {string} id The id of the molecule.\n * @param {string} description The description of the molecule.\n * @param {boolean} active Indicates if the molecule is active.\n * @param {Map<string, Atom>} atoms A Map of atoms with keys as string atom ids and values as Atoms.\n * @param {Map<string, Bond>} bonds A Map of bonds with keys as string atom ids and values as Bonds.\n * @param {Map<string, Property>} properties A map of properties.\n * @param {EnergyTransferModel | null} energyTransferModel The energy transfer model.\n * @param {DOSCMethod | null} dOSCMethod The method for calculating density of states.\n */\nexport class Molecule extends Attributes {\n    id: string;\n    // Atoms\n    atoms: Map<string, Atom>;\n    // Bonds\n    bonds: Map<string, Bond>;\n    // Properties\n    properties: Map<string, Property>;\n    // EnergyTransferModel\n    energyTransferModel?: EnergyTransferModel;\n    // DOSCMethod\n    dOSCMethod?: DOSCMethod;\n\n    /**\n     * Create a molecule.\n     * @param {Map<string, string>} attributes The attributes. If there is no \"id\" key an error will be thrown.\n     * Additional attributes known about are \"description\" and \"active\", but these do not exist for all molecules\n     * in Mesmer XML input/output files.\n     * @param {Map<string, Atom>} atoms A Map of atoms with keys as ids.\n     * @param {Map<string, Bond>} bonds A Map of bonds with. The keys combine the ids of the two bonded atoms.\n     * @param {Map<string, Property>} properties A map of properties.\n     * @param {EnergyTransferModel | null} energyTransferModel The energy transfer model.\n     * @param {DOSCMethod | null} dOSCMethod The method for calculating density of states.\n     */\n    constructor(\n        attributes: Map<string, string>,\n        atoms: Map<string, Atom>,\n        bonds: Map<string, Bond>,\n        properties: Map<string, Property>,\n        energyTransferModel?: EnergyTransferModel,\n        dOSCMethod?: DOSCMethod) {\n        super(attributes);\n        let id: string | undefined = this.attributes.get(\"id\");\n        if (id == undefined) {\n            throw new Error('id is undefined');\n        }\n        this.id = id;\n        this.atoms = atoms;\n        this.bonds = bonds;\n        this.properties = properties;\n        this.energyTransferModel = energyTransferModel;\n        this.dOSCMethod = dOSCMethod;\n    }\n\n    /** \n     * @returns A string representation.\n     */\n    toString(): string {\n        let r = `Molecule(id(${this.getID()}), `;\n        let description: string | undefined = this.getDescription();\n        if (description != undefined) {\n            r += `description(${description}), `;\n        }\n        let active: boolean | undefined = this.getActive();\n        if (active != undefined) {\n            r += `active(${active}), `;\n        }\n        if (this.atoms.size > 0) {\n            r += `atoms(${mapToString(this.atoms)}), `;\n        }\n        if (this.bonds.size > 0) {\n            r += `bonds(${mapToString(this.bonds)}), `;\n        }\n        if (this.properties.size > 0) {\n            r += `properties(${mapToString(this.properties)}), `;\n        }\n        if (this.energyTransferModel) {\n            r += `energyTransferModel(${this.energyTransferModel.toString()}), `;\n        }\n        if (this.dOSCMethod) {\n            r += `dOSCMethod(${this.dOSCMethod.toString()}), `;\n        }\n        return r + `)`;\n    }\n\n    /**\n     * @return The id of the molecule.\n     */\n    getID(): string {\n        return this.attributes.get(\"id\") as string;\n    }\n\n    /**\n     * Gets the description of the molecule.\n     * @returns The description of the molecule, or undefined if it is not set.\n     */\n    getDescription(): string | undefined {\n        return this.attributes.get(\"description\");\n    }\n\n    /**\n     * Gets the active status of the molecule.\n     * @returns The active status of the molecule, or undefined if it is not set.\n     */\n    getActive(): boolean | undefined {\n        let active = this.attributes.get(\"active\");\n        if (active != undefined) {\n            return true;\n        }\n        return active;\n    }\n\n    /**\n     * @returns {number} The energy of the molecule or zero if the energy is not set.\n     * @throws An error if \"me.ZPE\" is a property, but is not mapped to a PropertyScalar.\n     */\n    getEnergy(): number {\n        let zpe: Property | undefined = this.properties.get('me:ZPE');\n        if (zpe == undefined) {\n            return 0;\n        }\n        if (zpe.property instanceof NumberWithAttributes) {\n            return zpe.property.value;\n        } else {\n            throw new Error(\"Expected a PropertyScalar but got a PropertyArray and not sure how to handle that.\");\n        }\n    }\n\n    /**\n     * Set the Energy of the molecule.\n     * @param {number} energy The energy of the molecule in kcal/mol.\n     */\n    setEnergy(energy: number) {\n        let property: Property | undefined = this.properties.get('me:ZPE');\n        if (property == undefined) {\n            throw new Error(\"No me.ZPE property found\");\n        }\n        if (property.property instanceof NumberArrayWithAttributes) {\n            throw new Error(\"Expected a NumberWithAttributes but got a NumberArrayWithAttributes and not sure how to handle that.\");\n        } else {\n            property.property.value = energy;\n        }\n    }\n\n    /**\n     * Get the RotationConstants of the molecule.\n     * @returns The RotationConstants of the molecule.\n     */\n    getRotationConstants(): number[] | undefined {\n        let property: Property | undefined = this.properties.get('me:rotConsts');\n        if (property != undefined) {\n            if (property.property != null) {\n                if (property.property instanceof NumberWithAttributes) {\n                    return [property.property.value];\n                } else {\n                    return property.property.values;\n                }\n            } else {\n                return undefined;\n            }\n        }\n        return property;\n    }\n\n    /**\n     * Get the VibrationFrequencies of the molecule.\n     * @returns The VibrationFrequencies of the molecule.\n     */\n    getVibrationFrequencies(): number[] | undefined {\n        let property: Property | undefined = this.properties.get('me:vibFreqs');\n        if (property != undefined) {\n            if (property.property instanceof NumberWithAttributes) {\n                return [property.property.value];\n            } else if (property.property instanceof NumberArrayWithAttributes) {\n                return property.property.values;\n            } else {\n                return undefined;\n            }\n        }\n        return property;\n    }\n\n    /**\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad (Optional).\n     * @param {number} level The level of padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName: string, pad?: string, level?: number): string {\n        // Padding\n        let padding0: string = \"\";\n        let padding1: string = \"\";\n        let padding2: string = \"\";\n        let padding3: string = \"\";\n        if (pad != undefined && level != undefined) {\n            padding0 = pad.repeat(level);\n            padding1 = padding0 + pad;\n            padding2 = padding1 + pad;\n            padding3 = padding2 + pad;\n        }\n        // Atoms\n        let atoms_xml: string = \"\";\n        for (let atom of this.atoms.values()) {\n            atoms_xml += atom.toTag(\"atom\", padding2);\n        }\n        if (this.atoms.size > 1) {\n            if (atoms_xml != \"\") {\n                atoms_xml = getTag(atoms_xml, \"atomArray\", undefined, undefined, undefined, padding1, true);\n            }\n        }\n        // Bonds\n        let bonds_xml: string = \"\";\n        for (let bond of this.bonds.values()) {\n            bonds_xml += bond.toTag(\"bond\", padding2);\n        }\n        if (bonds_xml != \"\") {\n            bonds_xml = getTag(bonds_xml, \"bondArray\", undefined, undefined, undefined, padding1, true);\n        }\n        // Properties\n        let properties_xml: string = \"\";\n        this.properties.forEach(property => {\n            let property_xml: string = \"\";\n            if (property.property instanceof NumberWithAttributes) {\n                property_xml += property.property.toXML(\"scalar\", padding3);\n            } else {\n                property_xml += property.property.toXML(\"array\", padding3);\n            }\n            properties_xml += getTag(property_xml, \"property\", property.attributes, undefined, undefined, padding2, true);\n        });\n        if (this.properties.size > 1) {\n            if (properties_xml != \"\") {\n                properties_xml = getTag(properties_xml, \"propertyList\", undefined, undefined, undefined, padding1, true);\n            }\n        }\n        // EnergyTransferModel\n        let energyTransferModel_xml: string = \"\";\n        if (this.energyTransferModel) {\n            energyTransferModel_xml = this.energyTransferModel.toXML(pad, padding1);\n        }\n        // DOSCMethod\n        let dOSCMethod_xml: string = \"\";\n        if (this.dOSCMethod) {\n            dOSCMethod_xml = this.dOSCMethod.toTag(padding1);\n        }\n        return getTag(atoms_xml + bonds_xml + properties_xml + energyTransferModel_xml + dOSCMethod_xml,\n            tagName, this.attributes, undefined, undefined, padding0, true);\n    }\n}","import { getSelfClosingTag } from \"./html\";\nimport { getTag } from \"./xml\";\n/**\n * A class for representing things with attributes.\n * @param {Map<string, string>} attributes The attributes.\n */\nexport class Attributes {\n    /**\n     * The attributes.\n     */\n    attributes;\n    /**\n     * @param attributes The attributes.\n     */\n    constructor(attributes) {\n        this.attributes = attributes;\n    }\n    /**\n     * @returns The name in lower case.\n     */\n    /*\n    get name(): string {\n        return this.constructor.name.toLowerCase().trim();\n    }\n    */\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        let r = this.constructor.name + `(`;\n        this.attributes.forEach((value, key) => {\n            r += `${key}(${value}), `;\n        });\n        return r;\n    }\n    /**\n     * Get the tag representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns A tag representation.\n     */\n    toTag(tagName, padding) {\n        let s = getSelfClosingTag(this.attributes, tagName);\n        if (padding) {\n            return \"\\n\" + padding + s;\n        }\n        return \"\\n\" + s;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, padding) {\n        return getTag(\"\", tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\n/**\n * A class for representing a number with attributes.\n * e.g. A value with units and measurement/uncertainty information.\n */\nexport class NumberWithAttributes extends Attributes {\n    value;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value.\n     */\n    constructor(attributes, value) {\n        super(attributes);\n        this.value = value;\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        return super.toString() + `, ${this.value.toString()})`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, padding) {\n        return getTag(this.value.toString().trim(), tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\n/**\n * A class for representing numerical values with a shared attributes.\n * e.g. An array values sharing the same units and measurement details.\n */\nexport class NumberArrayWithAttributes extends Attributes {\n    /**\n     * The values.\n     */\n    values;\n    /**\n     * The delimiter of the values.\n     */\n    delimiter = \",\";\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number[]} values The values.\n     * @param {string} delimiter The delimiter of the values (Optional - default will be \",\").\n     */\n    constructor(attributes, values, delimiter) {\n        super(attributes);\n        this.values = values;\n        if (delimiter) {\n            this.delimiter = delimiter;\n        }\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        return super.toString() + `, ${this.values.toString()})`;\n    }\n    /**\n     * Set the delimiter.\n     * @param {string} delimiter The delimiter.\n     */\n    setDelimiter(delimiter) {\n        this.delimiter = delimiter;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, padding) {\n        return getTag(this.values.toString().replaceAll(\",\", this.delimiter), tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\n//# sourceMappingURL=classes.js.map","import { \n    getSelfClosingTag \n} from \"./html\";\n\nimport {\n    getTag\n} from \"./xml\";\n\n/**\n * A class for representing things with attributes.\n * @param {Map<string, string>} attributes The attributes.\n */\nexport abstract class Attributes {\n\n    /**\n     * The attributes.\n     */\n    attributes: Map<string, string>;\n\n    /**\n     * @param attributes The attributes.\n     */\n    constructor(attributes: Map<string, string>) {\n        this.attributes = attributes;\n    }\n\n    /**\n     * @returns The name in lower case.\n     */\n    /*\n    get name(): string {\n        return this.constructor.name.toLowerCase().trim();\n    }\n    */\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        let r = this.constructor.name + `(`;\n        this.attributes.forEach((value, key) => {\n            r += `${key}(${value}), `;\n        });\n        return r;\n    }\n\n    /**\n     * Get the tag representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns A tag representation.\n     */\n    toTag(tagName: string, padding?: string): string {\n        let s = getSelfClosingTag(this.attributes, tagName);\n        if (padding) {\n            return \"\\n\" + padding + s;\n        }\n        return \"\\n\" + s;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName: string, padding?: string): string {\n        return getTag(\"\", tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\n\n/**\n * A class for representing a number with attributes.\n * e.g. A value with units and measurement/uncertainty information.\n */\nexport class NumberWithAttributes extends Attributes {\n    value: number;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes);\n        this.value = value;\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        return super.toString() + `, ${this.value.toString()})`;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    override toXML(tagName: string, padding?: string): string {\n        return getTag(this.value.toString().trim(), tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}\n\n/**\n * A class for representing numerical values with a shared attributes.\n * e.g. An array values sharing the same units and measurement details.\n */\nexport class NumberArrayWithAttributes extends Attributes {\n\n    /**\n     * The values.\n     */\n    values: number[];\n\n    /**\n     * The delimiter of the values.\n     */\n    delimiter: string = \",\";\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number[]} values The values.\n     * @param {string} delimiter The delimiter of the values (Optional - default will be \",\").\n     */\n    constructor(attributes: Map<string, string>, values: number[], delimiter?: string) {\n        super(attributes);\n        this.values = values;\n        if (delimiter) {\n            this.delimiter = delimiter;\n        }\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString(): string {\n        return super.toString() + `, ${this.values.toString()})`;\n    }\n\n    /**\n     * Set the delimiter.\n     * @param {string} delimiter The delimiter.\n     */\n    setDelimiter(delimiter: string) {\n        this.delimiter = delimiter;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName: string, padding?: string): string {\n        return getTag(this.values.toString().replaceAll(\",\", this.delimiter), tagName, this.attributes, undefined, undefined, padding, false);\n    }\n}","/**\n * Create a table header row.\n * @param {string[]} headings The headings.\n * @returns {string} Table row with headings.\n */\nexport function getTH(headings) {\n    var th = \"\";\n    for (let i = 0; i < headings.length; i++) {\n        th += \"<th>\" + headings[i] + \"</th>\";\n    }\n    return getTR(th);\n}\n/**\n * Create a table cell.\n * @param {string} x A cell for a table row.\n * @param {boolean} contentEditable If true then the cell is set to be editable.\n * @returns {string} x wrapped in td tags.\n */\nexport function getTD(x, contentEditable = false) {\n    let r = \"<td\";\n    if (contentEditable) {\n        r += \" contenteditable=\\\"true\\\"\";\n    }\n    r += \">\" + x + \"</td>\";\n    return r;\n}\n/**\n * Create a table row.\n * @param {string} x A row for a table.\n * @returns {string} x wrapped in tr tags.\n */\nexport function getTR(x) {\n    return \"<tr>\" + x + \"</tr>\\n\";\n}\n/**\n * Create a table.\n * @param {string} x Table rows for a table.\n * @returns {string} x wrapped in table tags.\n */\nexport function getTable(x) {\n    return \"<table>\" + x + \"</table>\";\n}\n/**\n * Create a div.\n * @param {string} x The content of the div.\n * @param {string | null} id The id of the div.\n * @param {string | null} html_class The class of the div.\n * @returns {string} x wrapped in div tags.\n */\nexport function getDiv(x, id, html_class) {\n    let r = \"<div\";\n    if (id !== null) {\n        r += \" id=\\\"\" + id + \"\\\"\";\n    }\n    if (html_class !== null) {\n        r += \" class=\\\"\" + html_class + \"\\\"\";\n    }\n    return r + \">\" + x + \"</div>\";\n}\n/**\n * Create a input.\n * @param {string} type The input type (e.g. text, number).\n * @param {string | null} id The id of the button.\n * @param {string | null} func The function called on a change.\n * @param {string | null} value The value of the input.\n * @returns {string} An input HTML element.\n */\nexport function getInput(type, id, func, value) {\n    let r = \"<input type=\\\"\" + type + \"\\\"\";\n    if (id !== null) {\n        r += \" id=\\\"\" + id + \"\\\"\";\n    }\n    if (func !== null) {\n        r += \" onchange=\\\"\" + func + \"\\\"\";\n    }\n    if (value !== null) {\n        r += \" value=\\\"\" + value + \"\\\"\";\n    }\n    return r + \">\";\n}\n/**\n * Create a self closing tag.\n * @param {Map<string, string> | null} attributes The attributes.\n * @param {string} tagName The tag name.\n */\nexport function getSelfClosingTag(attributes, tagName) {\n    let s = \"<\" + tagName;\n    if (attributes) {\n        for (let [key, value] of attributes) {\n            s += \" \" + key + \"=\\\"\" + value + \"\\\"\";\n        }\n    }\n    return s + \" />\";\n}\n//# sourceMappingURL=html.js.map","/**\n * Create a table header row.\n * @param {string[]} headings The headings.\n * @returns {string} Table row with headings.\n */\nexport function getTH(headings: string[]): string {\n    var th = \"\";\n    for (let i = 0; i < headings.length; i++) {\n        th += \"<th>\" + headings[i] + \"</th>\";\n    }\n    return getTR(th);\n}\n\n/**\n * Create a table cell.\n * @param {string} x A cell for a table row.\n * @param {boolean} contentEditable If true then the cell is set to be editable.  \n * @returns {string} x wrapped in td tags.\n */\nexport function getTD(x: string, contentEditable: boolean = false): string {\n    let r: string = \"<td\";\n    if (contentEditable) {\n        r += \" contenteditable=\\\"true\\\"\";\n    }\n    r += \">\" + x + \"</td>\";\n    return r;\n}\n\n/**\n * Create a table row.\n * @param {string} x A row for a table.\n * @returns {string} x wrapped in tr tags.\n */\nexport function getTR(x: string): string {\n    return \"<tr>\" + x + \"</tr>\\n\";\n}\n\n/**\n * Create a table.\n * @param {string} x Table rows for a table.\n * @returns {string} x wrapped in table tags.\n */\nexport function getTable(x: string): string {\n    return \"<table>\" + x + \"</table>\";\n}\n\n/**\n * Create a div.\n * @param {string} x The content of the div.\n * @param {string | null} id The id of the div.\n * @param {string | null} html_class The class of the div.\n * @returns {string} x wrapped in div tags.\n */\nexport function getDiv(x: string, id: string | null, html_class: string | null): string {\n    let r: string = \"<div\";\n    if (id !== null) {\n        r += \" id=\\\"\" + id + \"\\\"\";\n    }\n    if (html_class !== null) {\n        r += \" class=\\\"\" + html_class + \"\\\"\";\n    }\n    return r + \">\" + x + \"</div>\";\n}\n\n/**\n * Create a input.\n * @param {string} type The input type (e.g. text, number).\n * @param {string | null} id The id of the button.\n * @param {string | null} func The function called on a change.\n * @param {string | null} value The value of the input.\n * @returns {string} An input HTML element.\n */\nexport function getInput(type: string, id: string | null, func: string | null,\n    value : string | null): string {\n    let r: string = \"<input type=\\\"\" + type + \"\\\"\";\n    if (id !== null) {\n        r += \" id=\\\"\" + id + \"\\\"\";\n    }\n    if (func !== null) {\n        r += \" onchange=\\\"\" + func + \"\\\"\";\n    }\n    if (value !== null) {\n        r += \" value=\\\"\" + value + \"\\\"\";\n    }\n    return r + \">\";\n}\n\n/**\n * Create a self closing tag.\n * @param {Map<string, string> | null} attributes The attributes.\n * @param {string} tagName The tag name.\n */\nexport function getSelfClosingTag(attributes: Map<string, string> | null, tagName: string): string {\n    let s: string = \"<\" + tagName;\n    if (attributes) {\n        for (let [key, value] of attributes) {\n            s += \" \" + key + \"=\\\"\" + value + \"\\\"\";\n        }\n    }\n    return s + \" />\";\n}","/**\n * For convertina a map to a string.\n * @param map The map to convert to a string.\n * @returns A string representation of all the entries in the map.\n */\nexport function mapToString(map) {\n    if (map == null) {\n        return \"\";\n    }\n    return Array.from(map.entries()).map(([key, value]) => `${key == null ? \"null\" : key.toString()}(${value == null ? \"null\" : value.toString()})`).join(', ');\n}\n/**\n * For converting an array to a string.\n * @param {any[]} array The array to convert to a string.\n * @param {string} delimiter The (optional) delimiter.\n */\nexport function arrayToString(array, delimiter) {\n    if (array == null) {\n        return \"\";\n    }\n    if (delimiter == null) {\n        delimiter = ', ';\n    }\n    return array.map((value) => value == null ? \"null\" : value.toString()).join(delimiter);\n}\n/**\n * For converting a string array to a number array.\n * @param {string[]} s The string to convert to a number array.\n * @returns A number array.\n */\nexport function toNumberArray(s) {\n    let r = [];\n    for (let i = 0; i < s.length; i++) {\n        r.push(parseFloat(s[i]));\n    }\n    return r;\n}\n/**\n * Is the string numeric in that it can be parsed as a float that is not a NaN?\n * @param {string} s The string.\n * @returns True if the string can be parsed as a float that is not a NaN and false otherwise.\n */\nexport function isNumeric(s) {\n    return !isNaN(parseFloat(s));\n}\n//# sourceMappingURL=functions.js.map","/**\n * For convertina a map to a string.\n * @param map The map to convert to a string.\n * @returns A string representation of all the entries in the map.\n */\nexport function mapToString(map: Map<any, any>): string {\n    if (map == null) {\n        return \"\";\n    }\n    return Array.from(map.entries()).map(([key, value]) =>\n        `${key == null ? \"null\" : key.toString()}(${value == null ? \"null\" : value.toString()})`).join(', ');\n}\n\n/**\n * For converting an array to a string.\n * @param {any[]} array The array to convert to a string.\n * @param {string} delimiter The (optional) delimiter.\n */\nexport function arrayToString(array: any[], delimiter: string): string {\n    if (array == null) {\n        return \"\";\n    }\n    if (delimiter == null) {\n        delimiter = ', ';\n    }\n    return array.map((value) => value == null ? \"null\" : value.toString()).join(delimiter);\n}\n\n/**\n * For converting a string array to a number array.\n * @param {string[]} s The string to convert to a number array.\n * @returns A number array.\n */\nexport function toNumberArray(s: string[]): number[] {\n    let r: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        r.push(parseFloat(s[i]));\n    }\n    return r;\n}\n\n/**\n * Is the string numeric in that it can be parsed as a float that is not a NaN?\n * @param {string} s The string.\n * @returns True if the string can be parsed as a float that is not a NaN and false otherwise.\n */\nexport function isNumeric(s: string): boolean {\n    return !isNaN(parseFloat(s));\n}","import { mapToString } from './functions.js';\nimport { Attributes, NumberWithAttributes } from './classes.js';\nimport { getTag } from './xml.js';\n/**\n * A class for representing a Reaction Molecule.\n */\nexport class ReactionMolecule extends Attributes {\n    /**\n     * A reference to the molecule.\n     */\n    molecule;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes, molecule) {\n        super(attributes);\n        this.molecule = molecule;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad for an extra level of padding (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, pad, padding) {\n        let padding1 = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding1 = padding + pad;\n        }\n        let s = this.toTag(\"molecule\", padding1);\n        return getTag(s, tagName, undefined, undefined, undefined, padding, true);\n    }\n}\n/**\n * A class for representing a reactant.\n * This is a molecule often with a role in a reaction.\n */\nexport class Reactant extends ReactionMolecule {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes, molecule) {\n        super(attributes, molecule);\n    }\n}\n/**\n * A class for representing a product.\n * This is a molecule produced in a reaction.\n */\nexport class Product extends ReactionMolecule {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes, molecule) {\n        super(attributes, molecule);\n    }\n}\n/**\n * A class for representing a transition state.\n */\nexport class TransitionState extends ReactionMolecule {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes, molecule) {\n        super(attributes, molecule);\n    }\n    /**\n     * A convenience method to get the ref (the molecule ID) of the transition state.\n     * @returns The ref of the transition state.\n     */\n    getRef() {\n        let s = this.attributes.get(\"ref\");\n        if (s == null) {\n            throw new Error('Attribute \"ref\" is undefined.');\n        }\n        return s;\n    }\n}\n/**\n * A class for representing the Arrhenius pre-exponential factor.\n */\nexport class PreExponential extends NumberWithAttributes {\n    /**\n     * A class for representing the Arrhenius pre-exponential factor.\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n}\n/**\n * A class for representing the Arrhenius activation energy factor.\n */\nexport class ActivationEnergy extends NumberWithAttributes {\n    /**\n     * A class for representing the Arrhenius pre-exponential factor.\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n}\n/**\n * A class for representing the reference temperature.\n */\nexport class TInfinity extends NumberWithAttributes {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n}\n/**\n * A class for representing the modified Arrhenius parameter factor.\n */\nexport class NInfinity extends NumberWithAttributes {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n}\n/**\n * A class for representing tunneling.\n */\nexport class Tunneling extends Attributes {\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */\n    constructor(attributes) {\n        super(attributes);\n    }\n}\n/**\n * A class for representing the MCRCMethod specifications.\n * Extended classes indicate how microcanonical rate constant is to be treated.\n */\nexport class MCRCMethod extends Attributes {\n    /**\n     * The name of the method.\n     */\n    mCRCMethodName;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {string} name The name or xsi:type of the method.\n     */\n    constructor(attributes, name) {\n        super(attributes);\n        this.mCRCMethodName = name;\n    }\n    toString() {\n        return `MCRCMethod(name(${this.mCRCMethodName}))`;\n    }\n}\n/**\n * A class for representing the inverse Laplace transform (ILT) type of microcanonical rate constant.\n */\nexport class MesmerILT extends MCRCMethod {\n    /**\n     * The pre-exponential factor.\n     */\n    preExponential;\n    /**\n     * The activation energy.\n     */\n    activationEnergy;\n    /**\n     * The TInfinity.\n     */\n    tInfinity;\n    /**\n     * The nInfinity.\n     */\n    nInfinity;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {PreExponential | undefined} preExponential The pre-exponential factor.\n     * @param {ActivationEnergy | undefined} activationEnergy The activation energy.\n     * @param {TInfinity | undefined} tInfinity The TInfinity.\n     * @param {NInfinity | undefined} nInfinity The nInfinity.\n     */\n    constructor(attributes, preExponential, activationEnergy, tInfinity, nInfinity) {\n        super(attributes, \"MesmerILT\");\n        this.preExponential = preExponential;\n        this.activationEnergy = activationEnergy;\n        this.tInfinity = tInfinity;\n        this.nInfinity = nInfinity;\n    }\n    toString() {\n        return `MesmerILT(${super.toString()}, ` +\n            `preExponential(${this.preExponential}), ` +\n            `activationEnergy(${this.activationEnergy}), ` +\n            `TInfinity(${this.tInfinity}), ` +\n            `nInfinity(${this.nInfinity}))`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, padding) {\n        let padding1 = \"\";\n        if (padding != undefined) {\n            padding1 = padding + \"  \";\n        }\n        let preExponential_xml = \"\";\n        if (this.preExponential != undefined) {\n            preExponential_xml = this.preExponential.toXML(\"me.preExponential\", padding1);\n        }\n        let activationEnergy_xml = \"\";\n        if (this.activationEnergy != undefined) {\n            activationEnergy_xml = this.activationEnergy.toXML(\"me.activationEnergy\", padding1);\n        }\n        let tInfinity_xml = \"\";\n        if (this.tInfinity != undefined) {\n            tInfinity_xml = this.tInfinity.toXML(\"me.nInfinity\", padding1);\n        }\n        let nInfinity_xml = \"\";\n        if (this.nInfinity != undefined) {\n            nInfinity_xml = this.nInfinity.toXML(\"me.nInfinity\", padding1);\n        }\n        return getTag(preExponential_xml + activationEnergy_xml + tInfinity_xml + nInfinity_xml, tagName, this.attributes, undefined, undefined, padding, true);\n    }\n}\n/**\n * A class for representing the Zhu-Nakamura crossing MCRCMethod.\n */\nexport class ZhuNakamuraCrossing extends MCRCMethod {\n    harmonicReactantDiabat_FC;\n    harmonicReactantDiabat_XO;\n    harmonicProductDiabat_DE;\n    exponentialProductDiabat_A;\n    exponentialProductDiabat_B;\n    exponentialProductDiabat_DE;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} harmonicReactantDiabat_FC The harmonic reactant diabatic FC.\n     * @param {number} harmonicReactantDiabat_XO The harmonic reactant diabatic XO.\n     * @param {number} harmonicProductDiabat_DE The harmonic product diabatic DE.\n     * @param {number} exponentialProductDiabat_A The exponential product diabatic A.\n     * @param {number} exponentialProductDiabat_B The exponential product diabatic B.\n     * @param {number} exponentialProductDiabat_DE The exponential product diabatic DE.\n     */\n    constructor(attributes, harmonicReactantDiabat_FC, harmonicReactantDiabat_XO, harmonicProductDiabat_DE, exponentialProductDiabat_A, exponentialProductDiabat_B, exponentialProductDiabat_DE) {\n        super(attributes, \"ZhuNakamuraCrossing\");\n        this.harmonicReactantDiabat_FC = harmonicReactantDiabat_FC;\n        this.harmonicReactantDiabat_XO = harmonicReactantDiabat_XO;\n        this.harmonicProductDiabat_DE = harmonicProductDiabat_DE;\n        this.exponentialProductDiabat_A = exponentialProductDiabat_A;\n        this.exponentialProductDiabat_B = exponentialProductDiabat_B;\n        this.exponentialProductDiabat_DE = exponentialProductDiabat_DE;\n    }\n    toString() {\n        return `ZhuNakamuraCrossing(${super.toString()}, ` +\n            `harmonicReactantDiabat_FC(${this.harmonicReactantDiabat_FC.toString()}), ` +\n            `harmonicReactantDiabat_XO(${this.harmonicReactantDiabat_XO.toString()}), ` +\n            `harmonicProductDiabat_DE(${this.harmonicProductDiabat_DE.toString()}), ` +\n            `exponentialProductDiabat_A(${this.exponentialProductDiabat_A.toString()}), ` +\n            `exponentialProductDiabat_B(${this.exponentialProductDiabat_B.toString()}), ` +\n            `exponentialProductDiabat_DE(${this.exponentialProductDiabat_DE.toString()}))`;\n    }\n}\n/**\n * A class for representing the sum of states.\n * @param {string} units The units of energy.\n * @param {boolean} angularMomentum The angular momentum attribute.\n * @param {boolean} noLogSpline The no log spline attribute.\n * @param {SumOfStatesPoint[]} sumOfStatesPoints The sum of states points.\n */\n/*\nexport class SumOfStates extends NumberWithAttributes {\n    units: string;\n    angularMomentum: boolean;\n    noLogSpline: boolean;\n    sumOfStatesPoints: SumOfStatesPoint[];\n    constructor(units: string, angularMomentum: boolean, noLogSpline: boolean, sumOfStatesPoints: SumOfStatesPoint[]) {\n        this.units = units;\n        this.angularMomentum = angularMomentum;\n        this.noLogSpline = noLogSpline;\n        this.sumOfStatesPoints = sumOfStatesPoints;\n    }\n    toString() {\n        return `SumOfStates(` +\n            `units(${this.units}), ` +\n            `angularMomentum(${this.angularMomentum.toString()}), ` +\n            `noLogSpline(${this.noLogSpline.toString()}), ` +\n            `sumOfStatesPoints(${arrayToString(this.sumOfStatesPoints, \" \")}))`;\n    }\n}\n*/\n/**\n * A class for representing a sum of states point.\n * @param {number} value The value of the point.\n * @param {number} energy The energy of the point.\n * @param {number} angMomMag The angular momentum magnitude of the point.\n */\n/*\nexport class SumOfStatesPoint {\n    value: number;\n    energy: number;\n    angMomMag: number;\n    constructor(value: number, energy: number, angMomMag: number) {\n        this.value = value;\n        this.energy = energy;\n        this.angMomMag = angMomMag;\n    }\n    toString() {\n        return `SumOfStatesPoint(` +\n            `value(${this.value}), ` +\n            `energy(${this.energy.toString()}), ` +\n            `angMomMag(${this.angMomMag.toString()}))`;\n    }\n}\n*/\n/**\n * A class for representing the DefinedSumOfStates MCRCMethod.\n * @param {string} name The name or xsi:type of the method.\n * @param {SumOfStates} sumOfStates The sum of states.\n */\n/*\nexport class DefinedSumOfStates extends MCRCMethod {\n    sumOfStates: SumOfStates;\n\n    constructor(name: string, sumOfStates: SumOfStates) {\n        super(name);\n        this.sumOfStates = sumOfStates;\n    }\n    toString() {\n        return `DefinedSumOfStates(${super.toString()}, ` +\n            `sumOfStates(${this.sumOfStates.toString()}))`;\n    }\n}\n*/\n/**\n * A class for representing a reaction.\n */\nexport class Reaction extends Attributes {\n    /**\n     * The id of the reaction. This is also stored in the attributes, but is hee for convenience...\n     */\n    id;\n    /**\n     * The reactants in the reaction.\n     */\n    reactants;\n    /**\n     * The products of the reaction.\n     */\n    products;\n    /**\n     * The MCRCMethod.\n     */\n    mCRCMethod;\n    /**\n     * The transition state.\n     */\n    transitionState;\n    /**\n     * The tunneling.\n     */\n    tunneling;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {string} id The id of the reaction.\n     * @param {Map<string, Reactant>} reactants The reactants in the reaction.\n     * @param {Map<string, Product>} products The products of the reaction.\n     * @param {MCRCMethod | undefined} mCRCMethod The MCRCMethod (optional).\n     * @param {TransitionState | undefined} transitionState The transition state (optional).\n     * @param {Tunneling | undefined} tunneling The tunneling (optional).\n     */\n    constructor(attributes, id, reactants, products, mCRCMethod, transitionState, tunneling) {\n        super(attributes);\n        this.id = id;\n        this.reactants = reactants;\n        this.products = products;\n        this.mCRCMethod = mCRCMethod;\n        this.transitionState = transitionState;\n        this.tunneling = tunneling;\n    }\n    /**\n     * Convert the product to a string.\n     * @returns String representation of the product.\n     */\n    toString() {\n        let s = super.toString();\n        return super.toString() + `id(${this.id}), ` +\n            `reactants(${mapToString(this.reactants)}), ` +\n            `products(${mapToString(this.products)}), ` +\n            `mCRCMethod(${this.mCRCMethod?.toString()}), ` +\n            `transitionState(${this.transitionState?.toString()}), ` +\n            `tunneling(${this.tunneling?.toString()}))`;\n    }\n    /**\n     * Get the label of the reactants.\n     * @returns The label of the reactants.\n     */\n    getReactantsLabel() {\n        return Array.from(this.reactants.values()).map(reactant => reactant.molecule.id).join(' + ');\n    }\n    /**\n     * Get the combined energy of the reactants.\n     * @returns The combined energy of the reactants.\n     */\n    getReactantsEnergy() {\n        return Array.from(this.reactants.values()).map(reactant => reactant.molecule.getEnergy()).reduce((a, b) => a + b, 0);\n    }\n    /**\n     * Returns the label for the products.\n     * @returns The label for the products.\n     */\n    getProductsLabel() {\n        return Array.from(this.products.values()).map(product => product.molecule.id).join(' + ');\n    }\n    /**\n     * Returns the total energy of all products.\n     * @returns The total energy of all products.\n     */\n    getProductsEnergy() {\n        return Array.from(this.products.values()).map(product => product.molecule.getEnergy()).reduce((a, b) => a + b, 0);\n    }\n    /**\n     * Get the label of the reaction.\n     * @returns The label of the reaction.\n     */\n    getLabel() {\n        let label = this.getReactantsLabel() + ' -> ' + this.getProductsLabel();\n        return label;\n    }\n    /**\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad (Optional).\n     * @param {number} level The level of padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName, pad, level) {\n        // Padding\n        let padding0 = \"\";\n        let padding1 = \"\";\n        let padding2 = \"\";\n        let padding3 = \"\";\n        if (pad != undefined && level != undefined) {\n            padding0 = pad.repeat(level);\n            padding1 = padding0 + pad;\n            padding2 = padding1 + pad;\n            padding3 = padding2 + pad;\n        }\n        // Reactants\n        let reactants_xml = \"\";\n        this.reactants.forEach(reactant => {\n            reactants_xml += reactant.toXML(\"reactant\", pad, padding1);\n        });\n        // Products\n        let products_xml = \"\";\n        this.products.forEach(product => {\n            products_xml += product.toXML(\"product\", pad, padding1);\n        });\n        // Tunneling\n        let tunneling_xml = \"\";\n        if (this.tunneling != undefined) {\n            tunneling_xml = this.tunneling.toTag(\"me.tunneling\", padding1);\n        }\n        // TransitionState\n        let transitionState_xml = \"\";\n        if (this.transitionState != undefined) {\n            transitionState_xml = this.transitionState.toXML(\"transitionState\", pad, padding1);\n        }\n        // MCRCMethod\n        let mCRCMethod_xml = \"\";\n        if (this.mCRCMethod != undefined) {\n            if (this.mCRCMethod instanceof MesmerILT) {\n                mCRCMethod_xml = this.mCRCMethod.toXML(\"mCRCMethod\", padding1);\n            }\n            else {\n                mCRCMethod_xml = this.mCRCMethod.toTag(\"mCRCMethod\", padding1);\n            }\n        }\n        return getTag(reactants_xml + products_xml + tunneling_xml + transitionState_xml + mCRCMethod_xml, tagName, this.attributes, undefined, undefined, padding0, true);\n    }\n}\n//# sourceMappingURL=reaction.js.map","import {\n    mapToString\n} from './functions.js';\n\nimport {\n    Molecule\n} from './molecule.js';\n\nimport {\n    Attributes, NumberWithAttributes\n} from './classes.js';\n\nimport {\n    getTag\n} from './xml.js';\n\n/**\n * A class for representing a Reaction Molecule.\n */\nexport class ReactionMolecule extends Attributes {\n\n    /**\n     * A reference to the molecule.\n     */\n    molecule: Molecule;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes: Map<string, string>, molecule: Molecule) {\n        super(attributes);\n        this.molecule = molecule;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad for an extra level of padding (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName: string, pad?: string | undefined, padding?: string | undefined): string {\n        let padding1: string = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding1 = padding + pad;\n        }\n        let s: string = this.toTag(\"molecule\", padding1);\n        return getTag(s, tagName, undefined, undefined, undefined, padding, true);\n    }\n}\n\n/**\n * A class for representing a reactant.\n * This is a molecule often with a role in a reaction.\n */\nexport class Reactant extends ReactionMolecule {\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes: Map<string, string>, molecule: Molecule) {\n        super(attributes, molecule);\n    }\n}\n\n/**\n * A class for representing a product.\n * This is a molecule produced in a reaction.\n */\nexport class Product extends ReactionMolecule {\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes: Map<string, string>, molecule: Molecule) {\n        super(attributes, molecule);\n    }\n\n}\n\n/**\n * A class for representing a transition state.\n */\nexport class TransitionState extends ReactionMolecule {\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {Molecule} molecule The molecule.\n     */\n    constructor(attributes: Map<string, string>, molecule: Molecule) {\n        super(attributes, molecule);\n    }\n\n    /**\n     * A convenience method to get the ref (the molecule ID) of the transition state.\n     * @returns The ref of the transition state.\n     */\n    getRef(): string {\n        let s: string | undefined = this.attributes.get(\"ref\");\n        if (s == null) {\n            throw new Error('Attribute \"ref\" is undefined.');\n        }\n        return s;\n    }\n}\n\n\n/**\n * A class for representing the Arrhenius pre-exponential factor.\n */\nexport class PreExponential extends NumberWithAttributes {\n\n    /**\n     * A class for representing the Arrhenius pre-exponential factor.\n     * @param {Map<string, string>} attributes The attributes. \n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n}\n\n/**\n * A class for representing the Arrhenius activation energy factor.\n */\nexport class ActivationEnergy extends NumberWithAttributes {\n\n    /**\n     * A class for representing the Arrhenius pre-exponential factor.\n     * @param {Map<string, string>} attributes The attributes. \n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n}\n\n/**\n * A class for representing the reference temperature.\n */\nexport class TInfinity extends NumberWithAttributes {\n\n    /**\n     * @param {Map<string, string>} attributes The attributes. \n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n}\n\n/**\n * A class for representing the modified Arrhenius parameter factor.\n */\nexport class NInfinity extends NumberWithAttributes {\n\n    /**\n     * @param {Map<string, string>} attributes The attributes. \n     * @param {number} value The value of the factor.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n}\n\n/**\n * A class for representing tunneling.\n */\nexport class Tunneling extends Attributes {\n    \n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */\n    constructor(attributes: Map<string, string>) {\n        super(attributes);\n    }\n}\n\n/**\n * A class for representing the MCRCMethod specifications.\n * Extended classes indicate how microcanonical rate constant is to be treated.\n */\nexport class MCRCMethod extends Attributes {\n\n    /**\n     * The name of the method.\n     */\n    mCRCMethodName: string;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {string} name The name or xsi:type of the method.\n     */\n    constructor(attributes: Map<string, string>, name: string) {\n        super(attributes);\n        this.mCRCMethodName = name;\n    }\n    toString() {\n        return `MCRCMethod(name(${this.mCRCMethodName}))`;\n    }\n}\n\n/**\n * A class for representing the inverse Laplace transform (ILT) type of microcanonical rate constant.\n */\nexport class MesmerILT extends MCRCMethod {\n\n    /**\n     * The pre-exponential factor.\n     */\n    preExponential: PreExponential | undefined;\n    \n    /**\n     * The activation energy.\n     */\n    activationEnergy: ActivationEnergy | undefined;\n    \n    /**\n     * The TInfinity.\n     */\n    tInfinity: TInfinity | undefined;\n    \n    /**\n     * The nInfinity.\n     */\n    nInfinity: NInfinity | undefined;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {PreExponential | undefined} preExponential The pre-exponential factor.\n     * @param {ActivationEnergy | undefined} activationEnergy The activation energy.\n     * @param {TInfinity | undefined} tInfinity The TInfinity.\n     * @param {NInfinity | undefined} nInfinity The nInfinity.\n     */\n    constructor(attributes: Map<string, string>, preExponential: PreExponential | undefined,\n        activationEnergy: ActivationEnergy | undefined, tInfinity: TInfinity | undefined,\n        nInfinity: NInfinity | undefined) {\n        super(attributes, \"MesmerILT\");\n        this.preExponential = preExponential;\n        this.activationEnergy = activationEnergy;\n        this.tInfinity = tInfinity;\n        this.nInfinity = nInfinity;\n    }\n\n    toString() {\n        return `MesmerILT(${super.toString()}, ` +\n            `preExponential(${this.preExponential}), ` +\n            `activationEnergy(${this.activationEnergy}), ` +\n            `TInfinity(${this.tInfinity}), ` +\n            `nInfinity(${this.nInfinity}))`;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} tagName The tag name.\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    override toXML(tagName: string, padding?: string | undefined): string {\n        let padding1: string = \"\";\n        if (padding != undefined) {\n            padding1 = padding + \"  \";\n        }\n        let preExponential_xml: string = \"\";\n        if (this.preExponential != undefined) {\n            preExponential_xml = this.preExponential.toXML(\"me.preExponential\", padding1);\n        }\n        let activationEnergy_xml: string = \"\";\n        if (this.activationEnergy != undefined) {\n            activationEnergy_xml = this.activationEnergy.toXML(\"me.activationEnergy\", padding1);\n        }\n        let tInfinity_xml: string = \"\";\n        if (this.tInfinity != undefined) {\n            tInfinity_xml = this.tInfinity.toXML(\"me.nInfinity\", padding1);\n        }\n        let nInfinity_xml: string = \"\";\n        if (this.nInfinity != undefined) {\n            nInfinity_xml = this.nInfinity.toXML(\"me.nInfinity\", padding1);\n        }\n        return getTag(preExponential_xml + activationEnergy_xml + tInfinity_xml + nInfinity_xml,\n            tagName, this.attributes, undefined, undefined, padding, true);\n    }\n}\n\n/**\n * A class for representing the Zhu-Nakamura crossing MCRCMethod.\n */\nexport class ZhuNakamuraCrossing extends MCRCMethod {\n    harmonicReactantDiabat_FC: number;\n    harmonicReactantDiabat_XO: number;\n    harmonicProductDiabat_DE: number;\n    exponentialProductDiabat_A: number;\n    exponentialProductDiabat_B: number;\n    exponentialProductDiabat_DE: number;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {number} harmonicReactantDiabat_FC The harmonic reactant diabatic FC.\n     * @param {number} harmonicReactantDiabat_XO The harmonic reactant diabatic XO.\n     * @param {number} harmonicProductDiabat_DE The harmonic product diabatic DE.\n     * @param {number} exponentialProductDiabat_A The exponential product diabatic A.\n     * @param {number} exponentialProductDiabat_B The exponential product diabatic B.\n     * @param {number} exponentialProductDiabat_DE The exponential product diabatic DE.\n     */\n    constructor(attributes: Map<string, string>,\n        harmonicReactantDiabat_FC: number,\n        harmonicReactantDiabat_XO: number,\n        harmonicProductDiabat_DE: number,\n        exponentialProductDiabat_A: number,\n        exponentialProductDiabat_B: number,\n        exponentialProductDiabat_DE: number) {\n        super(attributes, \"ZhuNakamuraCrossing\");\n        this.harmonicReactantDiabat_FC = harmonicReactantDiabat_FC;\n        this.harmonicReactantDiabat_XO = harmonicReactantDiabat_XO;\n        this.harmonicProductDiabat_DE = harmonicProductDiabat_DE;\n        this.exponentialProductDiabat_A = exponentialProductDiabat_A;\n        this.exponentialProductDiabat_B = exponentialProductDiabat_B;\n        this.exponentialProductDiabat_DE = exponentialProductDiabat_DE;\n    }\n    toString() {\n        return `ZhuNakamuraCrossing(${super.toString()}, ` +\n            `harmonicReactantDiabat_FC(${this.harmonicReactantDiabat_FC.toString()}), ` +\n            `harmonicReactantDiabat_XO(${this.harmonicReactantDiabat_XO.toString()}), ` +\n            `harmonicProductDiabat_DE(${this.harmonicProductDiabat_DE.toString()}), ` +\n            `exponentialProductDiabat_A(${this.exponentialProductDiabat_A.toString()}), ` +\n            `exponentialProductDiabat_B(${this.exponentialProductDiabat_B.toString()}), ` +\n            `exponentialProductDiabat_DE(${this.exponentialProductDiabat_DE.toString()}))`;\n    }\n}\n\n/**\n * A class for representing the sum of states.\n * @param {string} units The units of energy.\n * @param {boolean} angularMomentum The angular momentum attribute.\n * @param {boolean} noLogSpline The no log spline attribute.\n * @param {SumOfStatesPoint[]} sumOfStatesPoints The sum of states points.\n */\n/*\nexport class SumOfStates extends NumberWithAttributes {\n    units: string;\n    angularMomentum: boolean;\n    noLogSpline: boolean;\n    sumOfStatesPoints: SumOfStatesPoint[];\n    constructor(units: string, angularMomentum: boolean, noLogSpline: boolean, sumOfStatesPoints: SumOfStatesPoint[]) {\n        this.units = units;\n        this.angularMomentum = angularMomentum;\n        this.noLogSpline = noLogSpline;\n        this.sumOfStatesPoints = sumOfStatesPoints;\n    }\n    toString() {\n        return `SumOfStates(` +\n            `units(${this.units}), ` +\n            `angularMomentum(${this.angularMomentum.toString()}), ` +\n            `noLogSpline(${this.noLogSpline.toString()}), ` +\n            `sumOfStatesPoints(${arrayToString(this.sumOfStatesPoints, \" \")}))`;\n    }\n}\n*/\n\n/**\n * A class for representing a sum of states point.\n * @param {number} value The value of the point.\n * @param {number} energy The energy of the point.\n * @param {number} angMomMag The angular momentum magnitude of the point.\n */\n/*\nexport class SumOfStatesPoint {\n    value: number;\n    energy: number;\n    angMomMag: number;\n    constructor(value: number, energy: number, angMomMag: number) {\n        this.value = value;\n        this.energy = energy;\n        this.angMomMag = angMomMag;\n    }\n    toString() {\n        return `SumOfStatesPoint(` +\n            `value(${this.value}), ` +\n            `energy(${this.energy.toString()}), ` +\n            `angMomMag(${this.angMomMag.toString()}))`;\n    }\n}\n*/\n\n/**\n * A class for representing the DefinedSumOfStates MCRCMethod.\n * @param {string} name The name or xsi:type of the method.\n * @param {SumOfStates} sumOfStates The sum of states.\n */\n/*\nexport class DefinedSumOfStates extends MCRCMethod {\n    sumOfStates: SumOfStates;\n\n    constructor(name: string, sumOfStates: SumOfStates) {\n        super(name);\n        this.sumOfStates = sumOfStates;\n    }\n    toString() {\n        return `DefinedSumOfStates(${super.toString()}, ` +\n            `sumOfStates(${this.sumOfStates.toString()}))`;\n    }\n}\n*/\n\n/**\n * A class for representing a reaction.\n */\nexport class Reaction extends Attributes {\n\n    /**\n     * The id of the reaction. This is also stored in the attributes, but is hee for convenience...\n     */\n    id: string;\n\n    /**\n     * The reactants in the reaction.\n     */\n    reactants: Map<string, Reactant>;\n\n    /**\n     * The products of the reaction.\n     */\n    products: Map<string, Product>;\n\n    /**\n     * The MCRCMethod.\n     */\n    mCRCMethod: MCRCMethod | undefined;\n\n    /**\n     * The transition state.\n     */\n    transitionState: TransitionState | undefined;\n\n    /**\n     * The tunneling.\n     */\n    tunneling: Tunneling | undefined;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     * @param {string} id The id of the reaction.\n     * @param {Map<string, Reactant>} reactants The reactants in the reaction.\n     * @param {Map<string, Product>} products The products of the reaction.\n     * @param {MCRCMethod | undefined} mCRCMethod The MCRCMethod (optional).\n     * @param {TransitionState | undefined} transitionState The transition state (optional).\n     * @param {Tunneling | undefined} tunneling The tunneling (optional).\n     */\n    constructor(attributes: Map<string, string>, id: string,\n        reactants: Map<string, Reactant>, products: Map<string, Product>,\n        mCRCMethod?: MCRCMethod | undefined,\n        transitionState?: TransitionState | undefined,\n        tunneling?: Tunneling | undefined) {\n        super(attributes);\n        this.id = id;\n        this.reactants = reactants;\n        this.products = products;\n        this.mCRCMethod = mCRCMethod;\n        this.transitionState = transitionState;\n        this.tunneling = tunneling;\n    }\n\n    /**\n     * Convert the product to a string.\n     * @returns String representation of the product.\n     */\n    toString(): string {\n        let s: string = super.toString();\n        return super.toString() + `id(${this.id}), ` +\n            `reactants(${mapToString(this.reactants)}), ` +\n            `products(${mapToString(this.products)}), ` +\n            `mCRCMethod(${this.mCRCMethod?.toString()}), ` +\n            `transitionState(${this.transitionState?.toString()}), ` +\n            `tunneling(${this.tunneling?.toString()}))`;\n    }\n\n    /**\n     * Get the label of the reactants.\n     * @returns The label of the reactants.\n     */\n    getReactantsLabel(): string {\n        return Array.from(this.reactants.values()).map(reactant => reactant.molecule.id).join(' + ');\n    }\n\n    /**\n     * Get the combined energy of the reactants.\n     * @returns The combined energy of the reactants.\n     */\n    getReactantsEnergy(): number {\n        return Array.from(this.reactants.values()).map(reactant => reactant.molecule.getEnergy()).reduce((a, b) => a + b, 0);\n    }\n\n    /**\n     * Returns the label for the products.\n     * @returns The label for the products.\n     */\n    getProductsLabel(): string {\n        return Array.from(this.products.values()).map(product => product.molecule.id).join(' + ');\n    }\n\n    /**\n     * Returns the total energy of all products.\n     * @returns The total energy of all products.\n     */\n    getProductsEnergy(): number {\n        return Array.from(this.products.values()).map(product => product.molecule.getEnergy()).reduce((a, b) => a + b, 0);\n    }\n\n    /**\n     * Get the label of the reaction.\n     * @returns The label of the reaction.\n     */\n    getLabel(): string {\n        let label: string = this.getReactantsLabel() + ' -> ' + this.getProductsLabel();\n        return label;\n    }\n\n    /**\n     * @param {string} tagName The tag name.\n     * @param {string} pad The pad (Optional).\n     * @param {number} level The level of padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(tagName: string, pad?: string, level?: number): string {\n        // Padding\n        let padding0: string = \"\";\n        let padding1: string = \"\";\n        let padding2: string = \"\";\n        let padding3: string = \"\";\n        if (pad != undefined && level != undefined) {\n            padding0 = pad.repeat(level);\n            padding1 = padding0 + pad;\n            padding2 = padding1 + pad;\n            padding3 = padding2 + pad;\n        }\n        // Reactants\n        let reactants_xml: string = \"\";\n        this.reactants.forEach(reactant => {\n            reactants_xml += reactant.toXML(\"reactant\", pad, padding1);\n        });\n        // Products\n        let products_xml: string = \"\";\n        this.products.forEach(product => {\n            products_xml += product.toXML(\"product\", pad, padding1);\n        });\n        // Tunneling\n        let tunneling_xml: string = \"\";\n        if (this.tunneling != undefined) {\n            tunneling_xml = this.tunneling.toTag(\"me.tunneling\", padding1);\n        }\n        // TransitionState\n        let transitionState_xml: string = \"\";\n        if (this.transitionState != undefined) {\n            transitionState_xml = this.transitionState.toXML(\"transitionState\", pad, padding1);\n        }\n        // MCRCMethod\n        let mCRCMethod_xml: string = \"\";\n        if (this.mCRCMethod != undefined) {\n            if (this.mCRCMethod instanceof MesmerILT) {\n                mCRCMethod_xml = this.mCRCMethod.toXML(\"mCRCMethod\", padding1);\n            } else {\n                mCRCMethod_xml = this.mCRCMethod.toTag(\"mCRCMethod\", padding1);\n            }\n        }\n        return getTag(reactants_xml + products_xml + tunneling_xml + transitionState_xml + mCRCMethod_xml,\n            tagName, this.attributes, undefined, undefined, padding0, true);\n    }\n}","/**\n * Draw a horizontal line and add labels.\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} strokeStyle The name of a style to use for the line.\n * @param {number} strokewidth The width of the line.\n * @param {number} x0 The start x-coordinate of the line.\n * @param {number} y0 The start y-coordinate of the line. Also used for an energy label.\n * @param {number} x1 The end x-coordinate of the line.\n * @param {number} y1 The end y-coordinate of the line.\n * @param {string} font The font to use.\n * @param {number} th The height of the text in pixels.\n * @param {string} label The label.\n * @param {string} energyString The energy.\n */\nexport function drawLevel(ctx, strokeStyle, strokewidth, x0, y0, x1, y1, font, th, label, energyString) {\n    let x_centre = x0 + ((x1 - x0) / 2);\n    writeText(ctx, energyString, font, strokeStyle, getTextStartX(ctx, energyString, font, x_centre), y1 + th);\n    writeText(ctx, label, font, strokeStyle, getTextStartX(ctx, label, font, x_centre), y1 + 3 * th);\n    drawLine(ctx, strokeStyle, strokewidth, x0, y0, x1, y1);\n}\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the start x-coordinate of.\n * @param {string} font The font to use.\n * @param {number} x_centre The x-coordinate of the centre of the text.\n * @returns The x-coordinate of the start of the text.\n */\nfunction getTextStartX(ctx, text, font, x_centre) {\n    let tw = getTextWidth(ctx, text, font);\n    return x_centre - (tw / 2);\n}\n/**\n * Draw a line (segment) on the canvas.\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} strokeStyle The name of a style to use for the line.\n * @param {Integer} x1 The start x-coordinate of the line.\n * @param {Integer} y1 The start y-coordinate of the line.\n * @param {Integer} x2 The end x-coordinate of the line.\n * @param {Integer} y2 The end y-coordinate of the line.\n */\nexport function drawLine(ctx, strokeStyle, strokewidth, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = strokewidth;\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n/**\n * Writes text to the canvas. (It is probably better to write all the labels in one go.)\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to write.\n * @param {string} font The font to use.\n * @param {string} colour The colour of the text.\n * @param {number} x The horizontal position of the text.\n * @param {number} y The vertical position of the text.\n */\nexport function writeText(ctx, text, font, colour, x, y) {\n    // Save the context (to restore after).\n    ctx.save();\n    // Translate to the point where text is to be added.\n    ctx.translate(x, y);\n    // Invert Y-axis.\n    ctx.scale(1, -1);\n    // Set the text font.\n    ctx.font = font;\n    // Set the text colour.\n    ctx.fillStyle = colour;\n    // Write the text.\n    ctx.fillText(text, 0, 0);\n    // Restore the context.\n    ctx.restore();\n}\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the height of.\n * @param {string} font The font to use.\n * @returns {number} The height of the text in pixels.\n */\nexport function getTextHeight(ctx, text, font) {\n    ctx.font = font;\n    var fontMetric = ctx.measureText(text);\n    return fontMetric.actualBoundingBoxAscent + fontMetric.actualBoundingBoxDescent;\n}\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the width of.\n * @param {string} font The font to use.\n * @returns {number} The width of the text in pixels.\n */\nexport function getTextWidth(ctx, text, font) {\n    ctx.font = font;\n    return ctx.measureText(text).width;\n}\n//# sourceMappingURL=canvas.js.map","/**\n * Draw a horizontal line and add labels.\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} strokeStyle The name of a style to use for the line.\n * @param {number} strokewidth The width of the line.\n * @param {number} x0 The start x-coordinate of the line.\n * @param {number} y0 The start y-coordinate of the line. Also used for an energy label.\n * @param {number} x1 The end x-coordinate of the line.\n * @param {number} y1 The end y-coordinate of the line.\n * @param {string} font The font to use.\n * @param {number} th The height of the text in pixels.\n * @param {string} label The label.\n * @param {string} energyString The energy.\n */\nexport function drawLevel(ctx: CanvasRenderingContext2D, strokeStyle: string, strokewidth: number,\n    x0: number, y0: number, x1: number, y1: number, font: string, th: number, label: string, \n    energyString: string) {\n    let x_centre: number = x0 + ((x1 - x0) / 2);\n    writeText(ctx, energyString, font, strokeStyle, getTextStartX(ctx, energyString, font, x_centre), y1 + th);\n    writeText(ctx, label, font, strokeStyle, getTextStartX(ctx, label, font, x_centre), y1 + 3 * th);\n    drawLine(ctx, strokeStyle, strokewidth, x0, y0, x1, y1);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the start x-coordinate of.\n * @param {string} font The font to use.  \n * @param {number} x_centre The x-coordinate of the centre of the text.\n * @returns The x-coordinate of the start of the text.\n */\nfunction getTextStartX(ctx: CanvasRenderingContext2D, text: string, font: string, x_centre: number) {\n    let tw: number = getTextWidth(ctx, text, font);\n    return x_centre - (tw / 2);\n}\n\n/**\n * Draw a line (segment) on the canvas.\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} strokeStyle The name of a style to use for the line.\n * @param {Integer} x1 The start x-coordinate of the line.\n * @param {Integer} y1 The start y-coordinate of the line.\n * @param {Integer} x2 The end x-coordinate of the line.\n * @param {Integer} y2 The end y-coordinate of the line.\n */\nexport function drawLine(ctx: CanvasRenderingContext2D, strokeStyle: string, strokewidth: number,\n    x1: number, y1: number, x2: number, y2: number) {\n    ctx.beginPath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = strokewidth;\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\n/**\n * Writes text to the canvas. (It is probably better to write all the labels in one go.)\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to write.\n * @param {string} font The font to use.\n * @param {string} colour The colour of the text.\n * @param {number} x The horizontal position of the text.\n * @param {number} y The vertical position of the text.\n */\nexport function writeText(ctx: CanvasRenderingContext2D, text: string, font: string,\n    colour: string, x: number, y: number) {\n    // Save the context (to restore after).\n    ctx.save();\n    // Translate to the point where text is to be added.\n    ctx.translate(x, y);\n    // Invert Y-axis.\n    ctx.scale(1, -1);\n    // Set the text font.\n    ctx.font = font;\n    // Set the text colour.\n    ctx.fillStyle = colour;\n    // Write the text.\n    ctx.fillText(text, 0, 0);\n    // Restore the context.\n    ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the height of.\n * @param {string} font The font to use.\n * @returns {number} The height of the text in pixels.\n */\nexport function getTextHeight(ctx: CanvasRenderingContext2D, text: string, font: string): number {\n    ctx.font = font;\n    var fontMetric = ctx.measureText(text);\n    return fontMetric.actualBoundingBoxAscent + fontMetric.actualBoundingBoxDescent;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx The context to use.\n * @param {string} text The text to get the width of.\n * @param {string} font The font to use.\n * @returns {number} The width of the text in pixels.\n */\nexport function getTextWidth(ctx: CanvasRenderingContext2D, text: string, font: string): number {\n    ctx.font = font;\n    return ctx.measureText(text).width;\n}","import { Attributes } from \"./classes.js\";\nimport { ReactionMolecule } from \"./reaction.js\";\nimport { getTag } from \"./xml.js\";\n/**\n * A class for representing a Pressure and Temperature pair.\n */\nexport class PTpair extends Attributes {\n    /**\n     * The pressure also stored as a string in the attributes.\n     */\n    P;\n    /**\n     * The temperature also stored as a string in the attributes.\n     */\n    T;\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */\n    constructor(attributes) {\n        super(attributes);\n        let p = attributes.get(\"P\");\n        if (p) {\n            this.P = parseFloat(p);\n        }\n        else {\n            throw new Error(\"P is undefined\");\n        }\n        let t = attributes.get(\"T\");\n        if (t) {\n            this.T = parseFloat(t);\n        }\n        else {\n            throw new Error(\"T is undefined\");\n        }\n    }\n}\n/**\n * A class for representing a bath gas reaction molecule.\n */\nexport class BathGas extends ReactionMolecule {\n    constructor(attributes, molecule) {\n        super(attributes, molecule);\n    }\n}\n/**\n * A class for representing the experiment conditions.\n */\nexport class Conditions {\n    /**\n     * The bath gas.\n     */\n    bathGas;\n    /**\n     * The Pressure and Temperature pair.\n     */\n    pTs;\n    /**\n     * @param {BathGas} bathGas The bath gas.\n     * @param {PTpair} pTs The Pressure and Temperature pairs.\n     */\n    constructor(bathGas, pTs) {\n        this.bathGas = bathGas;\n        this.pTs = pTs;\n    }\n    /**\n     * @returns A string representation.\n     */\n    toString() {\n        return `Conditions(` +\n            `bathGas(${this.bathGas.toString()}), ` +\n            `pTs(${this.pTs.toString()}))`;\n    }\n    /**\n     * @param padding The padding (optional).\n     * @returns An XML representation.\n     */\n    toXML(pad, padding) {\n        let padding1 = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding1 = padding + pad;\n        }\n        let s = this.bathGas.toXML(\"bathGas\", pad, padding1);\n        this.pTs.forEach((pt) => {\n            s += pt.toTag(\"PTpair\", padding1);\n        });\n        return getTag(s, \"conditions\", undefined, undefined, undefined, padding, true);\n    }\n}\n//# sourceMappingURL=conditions.js.map","import {\n    Attributes, NumberWithAttributes\n} from \"./classes.js\";\n\nimport {\n    Molecule\n} from \"./molecule.js\";\n\nimport {\n    ReactionMolecule\n} from \"./reaction.js\";\nimport { getEndTag, getStartTag, getTag } from \"./xml.js\";\n\n\n/**\n * A class for representing a Pressure and Temperature pair.\n */\nexport class PTpair extends Attributes {\n\n    /**\n     * The pressure also stored as a string in the attributes.\n     */\n    P: number;\n\n    /**\n     * The temperature also stored as a string in the attributes.\n     */\n    T: number;\n\n    /**\n     * @param {Map<string, string>} attributes The attributes.\n     */\n    constructor(attributes: Map<string, string>) {\n        super(attributes);\n        let p: string | undefined = attributes.get(\"P\");\n        if (p) {\n            this.P = parseFloat(p);\n        } else {\n            throw new Error(\"P is undefined\");\n        }\n        let t: string | undefined = attributes.get(\"T\");\n        if (t) {\n            this.T = parseFloat(t);\n        } else {\n            throw new Error(\"T is undefined\");\n        }\n    }\n}\n\n\n/**\n * A class for representing a bath gas reaction molecule.\n */\nexport class BathGas extends ReactionMolecule {\n    constructor(attributes: Map<string, string>, molecule: Molecule) {\n        super(attributes, molecule);\n    }\n}\n\n/**\n * A class for representing the experiment conditions.\n */\nexport class Conditions {\n\n    /**\n     * The bath gas.\n     */\n    bathGas: BathGas;\n\n    /**\n     * The Pressure and Temperature pair.\n     */\n    pTs: PTpair[];\n\n    /**\n     * @param {BathGas} bathGas The bath gas.\n     * @param {PTpair} pTs The Pressure and Temperature pairs.\n     */\n    constructor(bathGas: BathGas, pTs: PTpair[]) {\n        this.bathGas = bathGas;\n        this.pTs = pTs;\n    }\n\n    /**\n     * @returns A string representation.\n     */\n    toString() : string {\n        return `Conditions(` +\n            `bathGas(${this.bathGas.toString()}), ` +\n            `pTs(${this.pTs.toString()}))`;\n    }\n\n    /**\n     * @param padding The padding (optional).\n     * @returns An XML representation.\n     */\n    toXML(pad?: string, padding?: string): string {\n        let padding1: string = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding1 = padding + pad;\n        }\n        let s: string = this.bathGas.toXML(\"bathGas\", pad, padding1);\n        this.pTs.forEach((pt) => {\n            s += pt.toTag(\"PTpair\", padding1);\n        });\n        return getTag(s, \"conditions\", undefined, undefined, undefined, padding, true);\n    }\n}","import { NumberWithAttributes } from \"./classes\";\nimport { getTag } from \"./xml\";\n/**\n * A class for measures of grain size.\n */\nexport class GrainSize extends NumberWithAttributes {\n    /**\n     * @param {string} units The units.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n    toString() {\n        return `GrainSize(${super.toString()})`;\n    }\n}\n/**\n * A class for model parameters.\n */\nexport class ModelParameters {\n    /**\n     * The grain size.\n     */\n    grainSize;\n    /**\n     * The energy above the top hill.\n     */\n    energyAboveTheTopHill;\n    /**\n     * @param {GrainSize} grainSize The grain size.\n     * @param {number} energyAboveTheTopHill The energy above the top hill.\n     */\n    constructor(grainSize, energyAboveTheTopHill) {\n        this.grainSize = grainSize;\n        this.energyAboveTheTopHill = energyAboveTheTopHill;\n    }\n    toString() {\n        return `ModelParameters(` +\n            `grainSize(${this.grainSize.toString()}), ` +\n            `energyAboveTheTopHill(${this.energyAboveTheTopHill.toString()}))`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} pad The pad (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(pad, padding) {\n        let padding2 = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding2 = padding + pad;\n        }\n        let s = this.grainSize.toXML(\"me:GrainSize\", padding2);\n        s += getTag(this.energyAboveTheTopHill.toString(), \"me:EnergyAboveTheTopHill\", undefined, undefined, undefined, padding2, false);\n        return getTag(s, \"me:modelParameters\", undefined, undefined, undefined, padding, true);\n    }\n}\n//# sourceMappingURL=modelParameters.js.map","import {\n    NumberWithAttributes\n} from \"./classes\";\nimport { getEndTag, getStartTag, getTag } from \"./xml\";\n\n/**\n * A class for measures of grain size.\n */\nexport class GrainSize extends NumberWithAttributes {\n\n    /**\n     * @param {string} units The units.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n    toString() {\n        return `GrainSize(${super.toString()})`;\n    }\n}\n\n/**\n * A class for model parameters.\n */\nexport class ModelParameters {\n\n    /**\n     * The grain size.\n     */\n    grainSize: GrainSize;\n    \n    /**\n     * The energy above the top hill.\n     */\n    energyAboveTheTopHill: number;\n\n    /**\n     * @param {GrainSize} grainSize The grain size.\n     * @param {number} energyAboveTheTopHill The energy above the top hill.\n     */\n    constructor(grainSize: GrainSize, energyAboveTheTopHill: number) {\n        this.grainSize = grainSize;\n        this.energyAboveTheTopHill = energyAboveTheTopHill;\n    }\n\n    toString() {\n        return `ModelParameters(` +\n            `grainSize(${this.grainSize.toString()}), ` +\n            `energyAboveTheTopHill(${this.energyAboveTheTopHill.toString()}))`;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} pad The pad (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(pad?: string, padding?: string): string {\n        let padding2: string = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding2 = padding + pad;\n        }\n        let s: string = this.grainSize.toXML(\"me:GrainSize\", padding2);\n        s += getTag(this.energyAboveTheTopHill.toString(), \"me:EnergyAboveTheTopHill\", undefined, undefined, undefined, padding2, false);\n        return getTag(s, \"me:modelParameters\", undefined, undefined, undefined, padding, true);\n    }\n}\n","import { NumberWithAttributes } from \"./classes\";\nimport { getSelfClosingTag } from \"./html\";\nimport { getTag } from \"./xml\";\n/**\n * A class for the diagram energy offset.\n */\nexport class DiagramEnergyOffset extends NumberWithAttributes {\n    /**\n     * @param {Map<string, string>} attributes The attributes (ref refers to a particular reaction).\n     * @param {number} value The value.\n     */\n    constructor(attributes, value) {\n        super(attributes, value);\n    }\n}\n/**\n * A class for the control.\n */\nexport class Control {\n    testDOS;\n    printSpeciesProfile;\n    testMicroRates;\n    testRateConstant;\n    printGrainDOS;\n    printCellDOS;\n    printReactionOperatorColumnSums;\n    printTunnellingCoefficients;\n    printGrainkfE;\n    printGrainBoltzmann;\n    printGrainkbE;\n    eigenvalues;\n    hideInactive;\n    diagramEnergyOffset;\n    constructor(testDOS, printSpeciesProfile, testMicroRates, testRateConstant, printGrainDOS, printCellDOS, printReactionOperatorColumnSums, printTunnellingCoefficients, printGrainkfE, printGrainBoltzmann, printGrainkbE, eigenvalues, hideInactive, diagramEnergyOffset) {\n        this.testDOS = testDOS;\n        this.printSpeciesProfile = printSpeciesProfile;\n        this.testMicroRates = testMicroRates;\n        this.testRateConstant = testRateConstant;\n        this.printGrainDOS = printGrainDOS;\n        this.printCellDOS = printCellDOS;\n        this.printReactionOperatorColumnSums = printReactionOperatorColumnSums;\n        this.printTunnellingCoefficients = printTunnellingCoefficients;\n        this.printGrainkfE = printGrainkfE;\n        this.printGrainBoltzmann = printGrainBoltzmann;\n        this.printGrainkbE = printGrainkbE;\n        this.eigenvalues = eigenvalues;\n        this.hideInactive = hideInactive;\n        this.diagramEnergyOffset = diagramEnergyOffset;\n    }\n    toString() {\n        return `Control(` +\n            `testDOS(${this.testDOS?.toString()}), ` +\n            `printSpeciesProfile(${this.printSpeciesProfile?.toString()}), ` +\n            `testMicroRates(${this.testMicroRates?.toString()}), ` +\n            `testRateConstant(${this.testRateConstant?.toString()}), ` +\n            `printGrainDOS(${this.printGrainDOS?.toString()}), ` +\n            `printCellDOS(${this.printCellDOS?.toString()}), ` +\n            `printReactionOperatorColumnSums(${this.printReactionOperatorColumnSums?.toString()}), ` +\n            `printTunnellingCoefficients(${this.printTunnellingCoefficients?.toString()}), ` +\n            `printGrainkfE(${this.printGrainkfE?.toString()}), ` +\n            `printGrainBoltzmann(${this.printGrainBoltzmann?.toString()}), ` +\n            `printGrainkbE(${this.printGrainkbE?.toString()}), ` +\n            `eigenvalues(${this.eigenvalues?.toString()}), ` +\n            `hideInactive(${this.hideInactive?.toString()}))`;\n    }\n    /**\n     * Get the XML representation.\n     * @param {string} pad The pad (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(pad, padding) {\n        let padding1 = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding1 = padding + pad;\n        }\n        let s = \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:testDOS\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printSpeciesProfile\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:testMicroRates\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:testRateConstant\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainDOS\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printCellDOS\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printReactionOperatorColumnSums\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printTunnellingCoefficients\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainkfE\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainBoltzmann\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainkbE\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:eigenvalues\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:hideInactive\");\n        s += this.diagramEnergyOffset?.toXML(\"me:diagramEnergyOffset\", padding1);\n        return getTag(s, \"control\", undefined, undefined, null, padding, true);\n    }\n}\n//# sourceMappingURL=control.js.map","import { \n    NumberWithAttributes\n } from \"./classes\";\nimport { getSelfClosingTag } from \"./html\";\nimport { getTag } from \"./xml\";\n\n/**\n * A class for the diagram energy offset.\n */\nexport class DiagramEnergyOffset extends NumberWithAttributes {\n    \n    /**\n     * @param {Map<string, string>} attributes The attributes (ref refers to a particular reaction). \n     * @param {number} value The value.\n     */\n    constructor(attributes: Map<string, string>, value: number) {\n        super(attributes, value);\n    }\n}\n\n/**\n * A class for the control.\n */\nexport class Control {\n    testDOS: boolean | undefined;\n    printSpeciesProfile: boolean | undefined;\n    testMicroRates: boolean | undefined;\n    testRateConstant: boolean | undefined;\n    printGrainDOS: boolean | undefined;\n    printCellDOS: boolean | undefined;\n    printReactionOperatorColumnSums: boolean | undefined;\n    printTunnellingCoefficients: boolean | undefined;\n    printGrainkfE: boolean | undefined;\n    printGrainBoltzmann: boolean | undefined;\n    printGrainkbE: boolean | undefined;\n    eigenvalues: number | undefined;\n    hideInactive: boolean | undefined;\n    diagramEnergyOffset: DiagramEnergyOffset | undefined;\n    constructor(testDOS?: boolean, printSpeciesProfile?: boolean, testMicroRates?: boolean, testRateConstant?:\n        boolean, printGrainDOS?: boolean, printCellDOS?: boolean, printReactionOperatorColumnSums?:\n            boolean, printTunnellingCoefficients?: boolean, printGrainkfE?: boolean, printGrainBoltzmann?: boolean,\n        printGrainkbE?: boolean, eigenvalues?: number, hideInactive?: boolean, diagramEnergyOffset?: DiagramEnergyOffset) {\n        this.testDOS = testDOS;\n        this.printSpeciesProfile = printSpeciesProfile;\n        this.testMicroRates = testMicroRates;\n        this.testRateConstant = testRateConstant;\n        this.printGrainDOS = printGrainDOS;\n        this.printCellDOS = printCellDOS;\n        this.printReactionOperatorColumnSums = printReactionOperatorColumnSums;\n        this.printTunnellingCoefficients = printTunnellingCoefficients;\n        this.printGrainkfE = printGrainkfE;\n        this.printGrainBoltzmann = printGrainBoltzmann;\n        this.printGrainkbE = printGrainkbE;\n        this.eigenvalues = eigenvalues;\n        this.hideInactive = hideInactive;\n        this.diagramEnergyOffset = diagramEnergyOffset;\n    }\n    toString() {\n        return `Control(` +\n            `testDOS(${this.testDOS?.toString()}), ` +\n            `printSpeciesProfile(${this.printSpeciesProfile?.toString()}), ` +\n            `testMicroRates(${this.testMicroRates?.toString()}), ` +\n            `testRateConstant(${this.testRateConstant?.toString()}), ` +\n            `printGrainDOS(${this.printGrainDOS?.toString()}), ` +\n            `printCellDOS(${this.printCellDOS?.toString()}), ` +\n            `printReactionOperatorColumnSums(${this.printReactionOperatorColumnSums?.toString()}), ` +\n            `printTunnellingCoefficients(${this.printTunnellingCoefficients?.toString()}), ` +\n            `printGrainkfE(${this.printGrainkfE?.toString()}), ` +\n            `printGrainBoltzmann(${this.printGrainBoltzmann?.toString()}), ` +\n            `printGrainkbE(${this.printGrainkbE?.toString()}), ` +\n            `eigenvalues(${this.eigenvalues?.toString()}), ` +\n            `hideInactive(${this.hideInactive?.toString()}))`;\n    }\n\n    /**\n     * Get the XML representation.\n     * @param {string} pad The pad (Optional).\n     * @param {string} padding The padding (Optional).\n     * @returns An XML representation.\n     */\n    toXML(pad: string, padding?: string): string {\n        let padding1: string = \"\";\n        if (pad != undefined && padding != undefined) {\n            padding1 = padding + pad;\n        }\n        let s: string = \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:testDOS\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printSpeciesProfile\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:testMicroRates\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:testRateConstant\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainDOS\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printCellDOS\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printReactionOperatorColumnSums\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printTunnellingCoefficients\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainkfE\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainBoltzmann\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:printGrainkbE\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:eigenvalues\") + \"\\n\";\n        s += padding1 + getSelfClosingTag(null, \"me:hideInactive\");\n        s += this.diagramEnergyOffset?.toXML(\"me:diagramEnergyOffset\", padding1);\n        return getTag(s, \"control\", undefined, undefined, null, padding, true);\n    }\n}","module.exports = new __parcel__URL__(\"sw.464808ce.js\").toString();"],"names":["$850cc5ea4a4ae46d$var$title","$850cc5ea4a4ae46d$var$mesmerStartTag","$850cc5ea4a4ae46d$var$mesmerEndTag","$850cc5ea4a4ae46d$var$input_xml_filename","$850cc5ea4a4ae46d$var$loadButton","$850cc5ea4a4ae46d$var$saveButton","$850cc5ea4a4ae46d$var$me_title","$850cc5ea4a4ae46d$var$molecules_title","$850cc5ea4a4ae46d$var$molecules_table","$850cc5ea4a4ae46d$var$reactions_title","$850cc5ea4a4ae46d$var$reactions_table","$850cc5ea4a4ae46d$var$reactions_diagram_title","$850cc5ea4a4ae46d$var$conditions_title","$850cc5ea4a4ae46d$var$modelParameters_title","$850cc5ea4a4ae46d$var$xml_title","$850cc5ea4a4ae46d$var$xml_text","$850cc5ea4a4ae46d$var$inputElement","$850cc5ea4a4ae46d$var$conditions","$850cc5ea4a4ae46d$var$modelParameters","$850cc5ea4a4ae46d$var$control","$5a4e4b2707638a1c$export$3988ae62b71be9a3","map","key","has","Error","get","$2772ddfff48d4e5b$export$735ee1799fd02602","xml","name","v","getAttribute","$2772ddfff48d4e5b$export$91e73a91db22e6a2","element","tagName","el","getElementsByTagName","$2772ddfff48d4e5b$export$4e07613bf412feb7","cn","childNodes","$2772ddfff48d4e5b$export$13cb40e9b656ab9e","node","nodeValue","$2772ddfff48d4e5b$export$34b7e1ae786b72b0","padding","padValue","s","undefined","$2772ddfff48d4e5b$export$dad497fe1f6e27c0","content","attributes","attributeName","attributeValue","startTag","$2772ddfff48d4e5b$export$2cd488e9ab180ce2","k","toString","$2772ddfff48d4e5b$export$fe94072fee8a6976","attributeNames","getAttributeNames","Map","forEach","set","$2772ddfff48d4e5b$export$b7531b8ff18dc588","e","length","$b78502e6136d7337$export$3359980f21752184","headings","th","i","$b78502e6136d7337$export$b5ad96d32b19f99","$b78502e6136d7337$export$983f4376b55e6517","x","contentEditable","r","$b78502e6136d7337$export$ff083c49da8fe0f9","value","$736d23970649c300$export$21991851b0bb231f","constructor","toTag","toXML","$736d23970649c300$export$bf6a5b951c66187b","trim","$736d23970649c300$export$a66b3a80833b522b","values","delimiter","setDelimiter","replaceAll","$be2031a98996b20c$export$dc22ec7f8e0b9ac","Array","from","entries","join","$be2031a98996b20c$export$4323cc4280d5be7","array","$7d93ba3ef281f49d$export$80986e6afdd7e0cb","id","elementType","$7d93ba3ef281f49d$export$153327fc99ac0c53","$7d93ba3ef281f49d$export$41b04b3a73e7216d","property","pad","padding1","$7d93ba3ef281f49d$export$16fc56ab40b12b45","$7d93ba3ef281f49d$export$499950da20810ac9","deltaEDown","$7d93ba3ef281f49d$export$bbdce6c921702068","type","$7d93ba3ef281f49d$export$3da9759ad07746a3","atoms","bonds","properties","energyTransferModel","dOSCMethod","getID","description","getDescription","active","getActive","size","getEnergy","zpe","setEnergy","energy","getRotationConstants","getVibrationFrequencies","level","padding0","padding2","padding3","repeat","atoms_xml","atom","bonds_xml","bond","properties_xml","property_xml","energyTransferModel_xml","dOSCMethod_xml","$8f7fe2903675adfb$export$e8a062bb2fc9e2ba","molecule","$8f7fe2903675adfb$export$dcfd4302d04b7fb6","$8f7fe2903675adfb$export$264ad599d7cef668","$8f7fe2903675adfb$export$145c1ed87b1a2216","getRef","$8f7fe2903675adfb$export$38ce90ac8b004d85","$8f7fe2903675adfb$export$1bdc69d2439d749d","$8f7fe2903675adfb$export$d08982dd841d496f","$8f7fe2903675adfb$export$c3cf6f96dac11421","$8f7fe2903675adfb$export$6fa70ee10f356b6","mCRCMethodName","$8f7fe2903675adfb$export$191e95ebb11cc88","preExponential","activationEnergy","tInfinity","nInfinity","preExponential_xml","activationEnergy_xml","tInfinity_xml","nInfinity_xml","$8f7fe2903675adfb$export$d2ae4167a30cf6bb","reactants","products","mCRCMethod","transitionState","tunneling","getReactantsLabel","reactant","getReactantsEnergy","reduce","a","b","getProductsLabel","product","getProductsEnergy","getLabel","reactants_xml","products_xml","tunneling_xml","transitionState_xml","mCRCMethod_xml","$3342a40c3ce9ada4$export$479ac392a7fb4419","ctx","strokeStyle","strokewidth","x0","y0","x1","y1","font","label","energyString","x_centre","$3342a40c3ce9ada4$export$bec150f75a9b8f11","tw","$3342a40c3ce9ada4$export$37827d046293d309","$3342a40c3ce9ada4$export$819db45aec5fcbe5","x2","y2","beginPath","lineWidth","moveTo","lineTo","stroke","text","colour","y","save","translate","scale","fillStyle","fillText","restore","measureText","width","$e684439c17ac535a$export$3fe97ecb6b172244","P","T","p","parseFloat","t","$e684439c17ac535a$export$b33a132661f4be58","$e684439c17ac535a$export$363c7374d425f4ad","bathGas","pTs","pt","$bdb7ec0f19c747d8$export$26e33f0df9ce919d","$bdb7ec0f19c747d8$export$77f098867dc64198","grainSize","energyAboveTheTopHill","$fa7565c9b69426dc$export$159b5d3263f1049a","$fa7565c9b69426dc$export$7a7fa4424cb20976","testDOS","printSpeciesProfile","testMicroRates","testRateConstant","printGrainDOS","printCellDOS","printReactionOperatorColumnSums","printTunnellingCoefficients","printGrainkfE","printGrainBoltzmann","printGrainkbE","eigenvalues","hideInactive","diagramEnergyOffset","$1fcfddc64feeb124$exports","URL","url","navigator","window","addEventListener","swUrl","serviceWorker","register","$850cc5ea4a4ae46d$var$me_title_s","$850cc5ea4a4ae46d$var$molecules","$850cc5ea4a4ae46d$var$maxMoleculeEnergy","Infinity","$850cc5ea4a4ae46d$var$minMoleculeEnergy","$850cc5ea4a4ae46d$var$reactions","$850cc5ea4a4ae46d$var$header","document","event","getElementById","loadXML","$850cc5ea4a4ae46d$var$reload","createElement","onchange","files","console","log","file","reader","FileReader","start","contents","onload","target","result","blob","slice","readAsText","innerHTML","replace","$850cc5ea4a4ae46d$var$parse","bathGas_element","PTs_element","table","me_modelParameters_s","xml_modelParameters","xml_grainSize","modelParameters_element","control_table_element","documentElement","first","names","attribute","na","$850cc5ea4a4ae46d$var$setTitle","$850cc5ea4a4ae46d$var$initMolecules","moleculeList_s","xml_moleculeList","moleculeListTagNames","Set","add","nodeName","error","xml_molecules","els","moleculeTagNames","cns","delete","xml_atoms","j","attribs","xml_bonds","xml_properties","children","nodeAttributes","textContent","dictRef","Math","min","max","push","split","xml_deltaEDown","energyKey","inputElement","inputValue","eventTarget","isNaN","alert","$850cc5ea4a4ae46d$var$displayMoleculesTable","moleculesTable","energyNumber","rotationConstants","rotConsts","vibrationFrequencies","vibFreqs","$850cc5ea4a4ae46d$var$initReactions","reactionList_s","xml_reactions","xml_reactionList","xml_reactions_length","reactionID","xml_reactants","xml_molecule","moleculeID","xml_products","xml_MCRCMethod","xml_preExponential","xml_activationEnergy","xml_tInfinity","xml_nInfinity","xml_transitionState","xml_tunneling","reaction","$850cc5ea4a4ae46d$var$displayReactionsTable","reactionsTable","keys","$850cc5ea4a4ae46d$var$displayReactionsDiagram","canvas","style","display","$850cc5ea4a4ae46d$var$drawReactionDiagram","molecules","reactions","dark","lw","lwc","fontMetric","black","getContext","actualBoundingBoxAscent","actualBoundingBoxDescent","intProducts","transitionStates","orders","energies","energyMin","Number","MAX_VALUE","energyMax","MIN_VALUE","reactantsLabel","productsLabel","tsn","energyRange","reorders","xmax","reactantsInXY","reactantsOutXY","productsInXY","productsOutXY","transitionStatesInXY","transitionStatesOutXY","energyRescaled","height","range","canvasHeightWithBorder","originalCanvasHeight","transform","reactantOutXY","productInXY","transitionStateLabel","transitionStateInXY","transitionStateOutXY","$850cc5ea4a4ae46d$var$initConditions","me_conditions_s","xml_conditions","xml_bathGas","xml_PTPairs","xml_PTs","PTs","pTpair","$850cc5ea4a4ae46d$var$initControl","me_control_s","xml_control","control_title","xml_testDOS","xml_printSpeciesProfile","xml_testMicroRates","xml_testRateConstant","xml_printGrainDOS","xml_printCellDOS","xml_printReactionOperatorColumnSums","xml_printTunnellingCoefficients","xml_printGrainkfE","xml_printGrainBoltzmann","xml_printGrainkbE","xml_eigenvalues","xml_hideInactive","xml_diagramEnergyOffset","parser","DOMParser","parseFromString","fetch","method","headers","body","then","response","ok","status","data","catch","click","input","id_energy","saveXML","title_xml","moleculeList","reactionList","Blob","createObjectURL","href","download","appendChild","removeChild"],"version":3,"file":"GUI.24c233e8.js.map"}